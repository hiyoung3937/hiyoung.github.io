---
title: 计算机组成原理-指令系统
tags: [计组,指令系统]
date: 2023-05-27 21:01:50
categories: [计算机基础,计算机组成原理]
mathjax: true
cover: 
---

## 简介
计算机组成原理系列其三，主要是针对中国大陆考研所要求的内容对计算机组成原理的知识体系进行总结和梳理，本篇内容是计算机的指令系统介绍，主要包含以下几点：
- 指令格式的基本内容
- 指令格式
- 寻址方式
- 汇编基础
- CISC和RISC的基本概念

<!--more-->
## 大纲
- 指令系统
  - 指令系统简述
  - 指令的基本格式
  - 定长与变长指令字结构
    - 定长操作码指令格式
    - 拓展操作码指令格式
  - 寻址方式（重点）
    - 指令寻址
    - 数据寻址
  - 汇编基础
    - 基础知识
    - 常用指令
  - CISC和RISC
  - 典型例题

## 指令系统简述
指令是指示计算机执行某些操作的命令。一台计算机的所有指令的集合构成该机器的指令集。指令集体系结构（ISA）规定了：指令格式、数据类型和格式、操作数的存放方式、存储空间的大小和编址方式、寻址方式etc.

## 指令的基本格式

>Tips：几种字长的区别
>机器字长：CPU一次能处理数据的位数，通常与CPU的寄存器位数有关。
>存储字长：存储器中一个存储单元(存储地址)所存储的二进制代码的位数，即存储器中的MDR的位数。
>指令字长：计算机指令字的位数。
>数据字长：计算机数据存储所占用的位数。
>其中：
>机器字长、存储字长：一般不变，固定长度
>指令字长：长度可能会改变

一条指令就是机器语言的一个语句，是一段有意义的二进制代码。一条指令通常包括操作码和地址码两部分

<table>
<th>操作码字段</th>  <th>地址码字段</th>  
</table>

操作码是识别指令、了解指令功能以及区分操作数地址内容的组成和使用方法等信息。
地址码给出被操作的信息（指令或数据）的地址。
指令的长度是指一条指令中所包含二进制代码的位数，指令的长度与机器字长没有**固定的关系**，不过主存一般按照字节编址，所有指令字长多为字节的整数倍。

## 定长与变长指令字结构
在一个指令系统中，若所有指令的长度都相等，则称为定长指令字结构、若各种指令的长度随指令功能而异，则称为变长指令字结构
根据操作数地址码的数目不同可以分为
1. 零地址指令：如停机指令、空操作指令、关中断指令etc.
2. 一地址指令：如加1、减1、求反、求补etc.
3. 二地址指令：如算术和逻辑运算指令，需要给出源操作数和目的操作数
4. 三地址指令
5. 四地址指令

### 定长操作码指令格式
定长操作码指令在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般n位操作码字段的定长指令系统最大能表示$2^n$条指令

### 拓展操作码指令格式
即定长指令字结构+可变长操作码，拓展操作码使得操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码
例如：
在下图中，指令字长为16位，其中4位作为基本操作码字段OP，另有3个4位长的地址字段$A_1、A_2、A_3$。若4位基本操作码全用于三地址指令，则有16条。下图中所示的三地址指令为15条，1111留作拓展操作码用（即1111 0000-1110 XXXX XXXX 为二地址指令），二地址指令为15条；（同理 1111 1111 0000-1110 XXXX 为一地址指令），一地址指令为15条；（1111 1111 1111 0000-1110 为零地址指令）有16条。
![计组-指令系统-1](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-1.1rp8r9467jhc.webp)

除上方拓展方法外，还有其他多种拓展方法比如：
[0000-1110 **XXXX** **XXXX** **XXXX**]：表示三地址指令，有15条
[1111 0000-1011 **XXXX** **XXXX**]：表示二地址指令，这里取12条，留2条拓展
[1111 ***1100-1110|1111***  ***0000-1111|0000-1101***  **XXXX**]：表示一地址指令，这里取62条，留2条拓展
[1111 1111 1110-1111 0000-1111]：表示零地址，这里有32条

**设地址长度为n，上一层留出m种状态，下一层可拓展出$m\times2^n$种状态**

下面来看一道例题可能会更明显一些：
![计组-指令系统-2](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-2.4rf8xhbhuv40.webp)

![计组-指令系统-3](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-3.memtamrvqow.webp)

## 寻址方式（重点）

寻址方式是指寻找指令或操作数的有效地址的方式，分为指令寻址和数据寻址两大类
指令中的地址码字段并不代表操作数的真是地址，这种称为形式地址(A)。
形式地址结合寻址方式，可以找到操作数在存储器中的真实地址，称为有效地址(EA)
注意，(A)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。例如，EA=(A)意思是有效地址是地址A中的数值

### 指令寻址
寻找下一条将要执行的指令地址称为指令寻址
指令寻址有两种：顺序寻址和跳跃寻址
1. 顺序寻址
    通过程序计数器PC+1（这里的“1”是指一个指令字长），自动形成下一条指令的地址。{PC + “1” -> PC}
2. 跳跃寻址
    通过转移类指令实现，下一条指令不是由PC**自动**给出，而是由本条指令给出下条指令地址的计算方式。跳跃的结果是当前指令**修改**PC指，所以下一条指令仍然通过PC给出。跳跃寻址分为绝对地址（由标记符直接得到）和相对地址（相对于当前指令地址的偏移量）
    
### 数据寻址
寻找本条指令的数据地址称为数据寻址
数据寻址可分为三大类具体十种寻址方式，下图包含前九种还有一个堆栈寻址
其中基址寻址、变址寻址和相对寻址称为偏移寻址
![计组-指令系统-4](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-4.4flvt3d8ga20.webp)

数据寻址的方式较多，为了区别不同方式，会在指令字中设置一个字段，用来指明属于那种寻址方式。

<table>
    <th>操作码字段</th>  <th>寻址方式位</th>    <th>形式地址A</th>  
</table>

寻址方式位结合形式地址A求出操作数的真实地址，称为有效地址EA

#### 隐含寻址
隐含寻址是不明显地给出操作数地址，而是在指令中隐含操作数地址。
例如，单地址的指令只显式的给出第一操作数地址，而规定累加器（ACC）作为第二操作数地址

![计组-指令系统-5](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-5.2gd6wd9owbgg.webp)

#### 立即(数)寻址
立即寻址形式地址段给出的不是操作数地址，而是操作数本身，有称为立即数，使用补码表示
![计组-指令系统-6](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-6.7kivdh4vw2o0.webp)

#### 直接寻址
直接寻址中的形式地址A就是操作数的真实地址EA，即**EA=A**。
这与立即寻址不同，注意区别
![计组-指令系统-7](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-7.3i71pa3ukfw0.webp)

#### 间接寻址
间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作的真实地址，而是操作数有效地址EA所在的存储单元的地址，也就是是操作数地址的地址，即**EA=(A)**。
间接寻址可以是一次，也可以是多次
![计组-指令系统-8](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-8.6t3djb6azuc0.webp)

#### 寄存器寻址
寄存器寻址是指在指令字中直接给出操作数所在的寄存器编号，即$EA = R_i$，其操作数在由$R_i$所指的寄存器内
![计组-指令系统-9](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-9.8td6fu9fpko.webp)

#### 寄存器间接寻址
相对的，寄存器间接寻址是指在寄存器$R_i$中给出的是操作数所在的主存单元的地址，即$EA = (R_i)$
![计组-指令系统-10](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-10.kz8h7t82q5c.webp)

#### 相对寻址
相对寻址是把PC的内容加上形式地址A而形成的操作数的有效地址，即**EA = (PC)+A**，其中A是相对于当前PC指的偏移量，可正可负，由补码表示。

可以理解为是以PC所指的地址作为“起点”，A为偏移量。

相对寻址广泛应用于转移指令
![计组-指令系统-11](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-11.ckuowkosz5c.webp)

#### 基址寻址
基址寻址是指将CPU中基址寄存器(BR)的内容加上形式地址A，即**EA = (BR)+A**。其中BR既可以用专用的寄存器，也可以采用通用寄存器。

基址寄存器是面向操作系统的，其内容只能由操作系统或者程序决定，程序员无法修改其内容，但可以选择使用哪一个BR。

有利于多道程序设计，并可以用于编写浮动程序。
![计组-指令系统-12](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-12.kdo6rp88rf4.webp)

#### 变址寻址
变址寻址是指有效地址EA是形式地址A和变址寄存器IX内容之和，即**EA = (IX)+A**

IX是面向程序员的，在程序执行中，IX中的内容可以由程序员改变（作为偏移量），而形式地址A不变（作为基地址）。

这有利于处理循环程序和数组问题。
![计组-指令系统-13](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-13.5vujno1n2t00.webp)

#### 堆栈寻址
堆栈是存储器中一块特定的、按后进先出（LIFO）原则管理的存储区，该存储区中读/写单元的地址是由一个特定的寄存器给出，该寄存器称为堆栈指针（SP）
堆栈分为硬堆栈和软堆栈。
硬堆栈：又称寄存器堆栈
软堆栈：从主存中划出一段区域作为堆栈
在使用堆栈的系统中，大部分指令表面上都表现为无操作数指令形式，因为操作数地址隐含使用了SP。一般来说，在读/写一个堆栈的一个单元前后都会自动地完成对SP内容的增量或减量操作。

记栈顶元素为$M_(sp)$
栈顶在小地址方向：
出栈：$M_(sp) \rightarrow ACC$，$(SP)+1 \rightarrow SP$
入栈：$(SP)-1 \rightarrow SP$，$(X) \rightarrow M_(sp)$

栈顶在小地址方向：
出栈：$M_(sp) \rightarrow ACC$，$(SP)-1 \rightarrow SP$
入栈：$(SP)+1 \rightarrow SP$，$(X) \rightarrow M_(sp)$

## 汇编基础
这里只简单说明一些考研可能会涉及到的汇编知识，只要求在考试中能结合高级语言代码看懂汇编即可，不会要求写出汇编代码

### 基础知识
1. 常用的有两种汇编格式：AT&T和Intel格式，AT&T是Unix和Linux使用的格式，Intel格式即x86格式。
2. 注意，x86格式中第一个为目的操作数，第二个为源操作数，方式从右向左
3. x86中主要的寄存器
   ![计组-指令系统-14](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-14.414ill6fsdk0.webp)
4. 两者差别：**[点我查看](https://zhuanlan.zhihu.com/p/527208939)**
   ![计组-指令系统-15](https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/计组-指令系统-15.4tr50nd0wrc0.webp)

### 常用指令
偷懒了，具体指令意思可以参考网络上的内容**[点我查看](https://zhuanlan.zhihu.com/p/53394807)**，下面只列出一些书中出现的命令。

1. 数据传送指令
   1. mov(move)：将第二个操作数内容复制到第一个中
   2. push
   3. pop
2. 算术和逻辑运算指令
   1. add/sub
   2. inc/dec(increase/decrease)：操作数自增1、自减1
   3. imul/mul(multiply)：带符号整数乘法
   4. idiv/div(divide)：带符号整数除法
   5. and/or/xor：与、或、异或
   6. not
   7. neg(negative)
   8. shr/shl：shr逻辑右移、shl逻辑左移
3. 控制流指令
   1. jmp
   2. jcondition
   3. cmp/test
   4. call/ret

## CISC和RISC

CISC的英文全称是complex instruction set computer,既复杂指令系统。RISC的英文全称是reduced instruction set computer,既精简指令系统。CISC兼容性性强，指令繁多，长度可变，由微程序实现。而RISC则指令少，使用频率接近，主要是依靠硬件实现（通用寄存器、硬布线逻辑控制）。

CISC与RISC的具体区别以表格的形式呈现，如下图：

<table>
    <tbody>
        <tr>
            <td>指令系统类型</td>
            <td>指令</td>
            <td>寻址方式</td>
            <td>实现方式</td>
            <td>其他</td>
        </tr>
        <tr>
            <td>CISC（复杂指令系统）</td>
            <td>数量多，使用频率差别大，可变长格式</td>
            <td>支持多种寻址方式</td>
            <td>微程序控制技术</td>
            <td>研制周期长</td>
        </tr>
        <tr>
            <td>RISC（精简指令系统）</td>
            <td>数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存</td>
            <td>支持方式少</td>
            <td>增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线</td>
            <td>优化编译，有效支持高级语言</td>
        </tr>
    </tbody>
</table>

## 典型例题
待补充

-------------------------------------
参考文献：
《王道考研-计算机组成原理复习指导》
《Computer Systems A Programer's Perspective Third Edition》
 [CISC与RISC的区别](https://zhuanlan.zhihu.com/p/343652303)