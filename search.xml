<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>游戏叙事技巧</title>
    <url>/2022/10/23/85e66183f869/</url>
    <content><![CDATA[<h2 id="1-冲突"><a class="header-anchor" href="#1-冲突">¶</a>1. 冲突</h2>
<p>冲突是游戏故事的燃料，也是游戏玩法的燃料，冲突就是故事的核心。 “故事就是冲突（的集合）”</p>
<span id="more"></span>
<p>就故事而言，冲突就是：某人想要或需要某物，但其他人或者其他无造成了障碍</p>
<p>冲突是 <strong>想要/但</strong> 的模式</p>
<p>想要是角色的行动动力，“但” 是玩家所面临的障碍背后的事务，游戏的关卡和任务就是冲突所产生的障碍的实体表现</p>
<p>冲突是必须的，但是冲突的规模并不一定要大，更重要的是<strong>与某个角色产生了感情上的联系（共情）</strong></p>
<h2 id="2-三幕结构"><a class="header-anchor" href="#2-三幕结构">¶</a>2. 三幕结构</h2>
<ol>
<li>
<p>开始/铺陈</p>
<p>（故事发生的世界介绍）冲突发生之前的人物、地点、事件</p>
<p>为了理解故事的任何变化，我们需要对变化之前和之后的情况都有清晰的认识（前后对比）</p>
<p>我们要理解主角为什么要面对冲突，开始有一个特别重要的因素是<strong>诱发事件</strong>，这是介绍主角面对主要冲突的活动、事件或行动。通过这个事件让主角意识到冲突的存在</p>
<p>第一幕和第二幕分割点：<strong>主角开始完全致力于解决冲突开始</strong></p>
</li>
<li>
<p>中间/对抗</p>
<p>故事的&quot;精髓&quot;</p>
<p>第二幕从主角决定致力于解决冲突开始</p>
<p>第二幕包括：</p>
<ul>
<li>
<p>兑现第一幕设置的内容</p>
</li>
<li>
<p>铺陈第三幕最终解决冲突的解决方法</p>
</li>
</ul>
<p>第二幕和第三幕的分割点：<strong>主角已经克服许多困难，但仍面临抉择，主角有所顿悟，明白自己需要做什么，但困难在于能否做到</strong></p>
</li>
<li>
<p>结尾/解决</p>
</li>
</ol>
<h2 id="3-原型与故事结构"><a class="header-anchor" href="#3-原型与故事结构">¶</a>3. 原型与故事结构</h2>
<h3 id="3-1原型"><a class="header-anchor" href="#3-1原型">¶</a>3.1原型</h3>
<p><strong>1. 主角</strong><br>
<strong>2. 信使</strong></p>
<ul>
<li>主要是向主角传递主要冲突（或者潜在冲突），俗称“谜语人”</li>
<li>游戏中可能为NPC或者UI等<br>
<strong>3. 导师型角色</strong></li>
<li>提供知识、技能、建议等</li>
<li>赠与礼物、任务向导（存疑）</li>
<li>为主角提供解决主要冲突的方法或者动机（一般会通过某种方式：死亡、重伤等，来强迫和证明主角成长<br>
<strong>4. 最终BOSS下的主角前期面对的敌人\阻碍</strong></li>
<li>在与最终BOSS决战前阻碍主角前进的敌人\阻碍</li>
<li>可能会转变为主角盟友</li>
<li>帮助主角成长<br>
<strong>5. 搞笑艺人（搞笑担当）</strong></li>
<li>为故事注入喜剧色彩和轻松氛围</li>
<li>即使是严肃紧张的故事也需要某些角色来舒缓气氛</li>
<li>（游戏中常用主角的好朋友或者没头脑担当）<br>
<strong>6. 中立角色（左右摇摆）</strong></li>
<li>类似与灰色的、不确定的角色，不值得信任、不能依靠、可能会背叛主角的角色</li>
<li>可能是盟友变敌人，也可能是敌人变盟友，提供反转情节（类似幕后操作）<br>
<strong>7. 反派\最终BOSS</strong></li>
</ul>
<h3 id="3-2故事结构"><a class="header-anchor" href="#3-2故事结构">¶</a>3.2故事结构</h3>
<p><strong>1. 平常世界</strong></p>
<ul>
<li>介绍故事背景，主角日常生活，直面冲突之前生活</li>
</ul>
<p><strong>2. 引出主要冲突</strong></p>
<p><strong>3. 拒绝\不接受主要冲突</strong></p>
<ul>
<li>这里主要是在认识到世界的真相（主要冲突）后不愿接受现实</li>
<li>需要导师角色（或某事）来帮助主角改变主意</li>
</ul>
<p><strong>4. 遇到导师型角色</strong></p>
<ul>
<li>获取初始道具和新手教程等</li>
</ul>
<p><strong>5. 开始面对主要冲突</strong></p>
<ul>
<li>故事正式开始</li>
<li>类似三幕结构的第一幕和第二幕过渡</li>
</ul>
<p><strong>6. 考验、盟友、敌人</strong></p>
<ul>
<li>开始深入故事之中</li>
</ul>
<p><strong>7. 深入面对主要冲突</strong></p>
<ul>
<li>到达解决主要冲突的地点、时间或者是直面主要冲突之前</li>
<li>通常是个特殊的时间节点或者宏大的建筑</li>
</ul>
<p><strong>8. 直面主要冲突</strong></p>
<ul>
<li>全故事最高潮，解决主要冲突</li>
</ul>
<p><strong>9. 获得解决冲突奖励</strong></p>
<p><strong>10. 回归</strong></p>
<ul>
<li>解决了主要冲突但平常世界仍有问题亟待解决，带着奖励回到平常世界</li>
</ul>
<p><strong>11. 英雄归来（复活）</strong></p>
<ul>
<li>在某些情况下可能会出现主角“失败死亡”的情况，在某种神秘力量作用下主角复活回归打败反派</li>
<li>制造反转</li>
</ul>
<p><strong>12. 平常世界改善</strong></p>
<ul>
<li>主角解决主要冲突，平常世界得到改变，反派得到惩罚</li>
<li>主角成长，罪有应得，故事结束</li>
</ul>
<h2 id="4-角色和角色弧"><a class="header-anchor" href="#4-角色和角色弧">¶</a>4. 角色和角色弧</h2>
<h3 id="主角的描写"><a class="header-anchor" href="#主角的描写">¶</a>主角的描写</h3>
<ul>
<li><strong>玩家要与主角共情，玩家即是主角</strong></li>
<li>主角开始是不完美的、有缺陷的</li>
<li>主角随着故事的发展要有所成长</li>
<li>主角的成长要用行动来反映，要主动的采取行动，不能<strong>总是</strong>被动的接受命令，发挥主观能动性，否则会导致玩家共情下降，主角塑造失败</li>
<li>吸引玩家，让玩家<strong>关心</strong>正发生在主角身上的事（可能并不关心主角，但关心发生在他旁边是事）</li>
<li>主角承担解决冲突所要面对的<strong>代价</strong>（类似于魂类游戏的死亡惩罚），或者在故事中要失去的某些人或物</li>
</ul>
<h3 id="反派的描写"><a class="header-anchor" href="#反派的描写">¶</a>反派的描写</h3>
<ul>
<li>反派的核心功能是直接或简介的创造主要冲突，将其作为更大目标的一部分</li>
<li>弱小的反派意味着弱小的主角</li>
<li>反派和主角一样，是有自身想法、欲望、想念和计划的角色，他并不是简单的给主角设置障碍的机器</li>
<li>反叛的“坏”是因为他在实现自己欲望的道路上所做的事——为了达到自己的目标，甘愿伤害或者毁灭一切</li>
</ul>
<h3 id="角色弧（角色发展）"><a class="header-anchor" href="#角色弧（角色发展）">¶</a>角色弧（角色发展）</h3>
<p>定义：冲突的对抗以及随之而来的角色潜在性格和/或处境的变化称之为弧</p>
<ul>
<li>任何故事中最明显、最具戏剧性的角色弧几乎总是属于主角的，主角的成长和变化——他的弧——是主角的决定性特征</li>
<li>弧也是由开始、中间、结尾（铺陈、对抗、解决）组成的</li>
<li>
<ol>
<li>成长弧：记录了一个角色的价值观、他所代表的价值以及他是谁的深刻变化称为成长弧</li>
<li>处境弧：即使某个人物在故事发展中没有成长或者改变但他的处境发生了变化</li>
</ol>
</li>
</ul>
<h2 id="5-阐述"><a class="header-anchor" href="#5-阐述">¶</a>5. 阐述</h2>
<p>定义：观众理解和欣赏故事所需的信息</p>
<ul>
<li>处理这些信息最好的办法是用<strong>行动</strong>去表达出来而不是去<strong>说</strong>出来，大段的文字对白会导致玩家失去注意力甚至烦躁。要用适当的演出去传达这些信息</li>
<li>最好的方法是让玩家去做，其实是看，最差是直接叙述</li>
</ul>
<h3 id="播种"><a class="header-anchor" href="#播种">¶</a>播种</h3>
<ul>
<li>
<p>叙事的过程应当是有节奏的，循序渐进的</p>
</li>
<li>
<p>玩家接受信息需要时间去消化，尤其是在故事开始的阶段有大量信息需要玩家去接收，所以在故事开始的时候最忌讳的是：向玩家抛出大量信息</p>
</li>
<li>
<p>给需要传递的信息给予一个优先级，分批分时机的向玩家传递或者根本不传递</p>
</li>
<li>
<p>对于一个需要传递的信息，是否暂时保留不传递取决于它能否让玩家感到有趣（留下伏笔，保持神秘感）</p>
</li>
<li>
<p>对于需要传达的信息可以分为三类</p>
</li>
<li>
<p>需要知道的，前情提要等</p>
</li>
<li>
<p>可以等待的，是需要知道的但在当下并不是必要，需要等待时机变为“需要知道的”</p>
</li>
<li>
<p>次要的，对于整个故事的完整性来说相对不重要的，可能起到锦上添花的作用但去掉也无关紧要的信息</p>
</li>
<li>
<p>要在<strong>适当</strong>的时间点补完完前文未交代的信息</p>
</li>
</ul>
<h3 id="植入"><a class="header-anchor" href="#植入">¶</a>植入</h3>
<p>在故事中，植入就是确立一些特定的东西，这些东西会在以后变得很重要</p>
<ul>
<li>从最终的目标开始，然后回溯到过去去完成铺垫</li>
<li>成功植入的关键在于</li>
</ul>
<ol>
<li>以一种无害的方式引入想要植入的内容，同时不会引起不必要的注意</li>
<li>在铺垫和回收之间留出足够长的时间，最好让观众忘记一开始植入的东西（给人一种恍然大悟的感觉）</li>
</ol>
<h3 id="伏笔"><a class="header-anchor" href="#伏笔">¶</a>伏笔</h3>
<p>暗示故事后期会发生或变得更清晰、更重要的事情</p>
<ul>
<li>伏笔通常是故事的增强元素，而不是核心元素</li>
<li>伏笔和植入相似，但伏笔最初呈现的信息是模糊的，但在后来会变得清晰（类似现在说的竖旗）</li>
</ul>
<h2 id="6-故事可信度"><a class="header-anchor" href="#6-故事可信度">¶</a>6. 故事可信度</h2>
<p>故事可信度的关键是说服玩家/观众去相信你创造的虚拟世界和人物，更进一步来说是增强沉浸感不让玩家出戏（保持“搁置怀疑”的状态）</p>
<h3 id="一致性"><a class="header-anchor" href="#一致性">¶</a>一致性</h3>
<p>观众期待任何故事都具有一定的内在逻辑和一致性：世界一致性和角色一致性</p>
<ol>
<li>
<p>世界一致性<br>
无论故事中的世界是完全虚拟的、科幻的还是贴近现实的，都应该要使发生在其中的事符合其自身的物理规则，使得能够逻辑自洽。与观众一起制定世界规则，然后遵守这些规则，保持一致性</p>
</li>
<li>
<p>角色一致性<br>
让故事中的角色成为一个<strong>真正的人</strong>，他所做的所有事都是对他来说有意义的事情，应该是“他接下来会做什么”而不是“接下来<strong>我</strong>需要让什么事发生”</p>
</li>
</ol>
<h3 id="巧合"><a class="header-anchor" href="#巧合">¶</a>巧合</h3>
<ul>
<li>
<p>用巧合让角色陷入困难是好的，但用巧合让他们摆脱困难是糟糕的</p>
</li>
<li>
<p>让观众注意不到的巧合是良性的巧合</p>
</li>
<li>
<p>处理巧合</p>
</li>
</ul>
<ol>
<li>改变情节，消除巧合</li>
<li>回溯翻新，在不该剧情大体走向情况下去改进故事适得他不那么凑巧</li>
<li>淡化巧合</li>
</ol>
<h3 id="出其不意"><a class="header-anchor" href="#出其不意">¶</a>出其不意</h3>
<p>故事的发展应当是<strong>意料之外，情理之中</strong>，没人会喜欢一眼就能看到结局的故事</p>
<ul>
<li>创造一个精彩的惊喜</li>
<li>你知道故事会发展到哪里，但不知道故事会怎么发展到那里</li>
</ul>
<h3 id="奇观"><a class="header-anchor" href="#奇观">¶</a>奇观</h3>
<p>奇观就是大场面，能给人最直观的感官刺激，但一味的追求奇观会导致故事崩坏</p>
<h2 id="7-个人感悟"><a class="header-anchor" href="#7-个人感悟">¶</a>7. 个人感悟</h2>
<h3 id="人物前进的逻辑关系"><a class="header-anchor" href="#人物前进的逻辑关系">¶</a>人物前进的逻辑关系</h3>
<p>人物要获得成长要在前文做一定铺垫，不能让人物成长过于突兀，成长动力不一定是冲突，可以结合人物性格精神等方面，发出类似于普通人想要获得自我突破和成长的想法（激发人内在的、潜意识的向好或向恶）</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>游戏制作</category>
      </categories>
      <tags>
        <tag>游戏制作,游戏叙事</tag>
      </tags>
  </entry>
  <entry>
    <title>《恋爱节拍器》——路人女主的结束</title>
    <url>/2022/07/04/fc9920cd7f84/</url>
    <content><![CDATA[<h2 id="为何加藤惠会是第一女主"><a class="header-anchor" href="#为何加藤惠会是第一女主">¶</a>为何加藤惠会是第一女主</h2>
<p>  初次结缘路人女主应该是在三四年前了，也算是初次正式接触丸户史明的作品（白色相簿2久仰大名）。加藤惠最为我最喜欢的女主之一，甚至影响了我的择偶标准，正好以看完《恋爱节拍器》为契机，我觉得我应当为这部作品写点什么。</p>
<span id="more"></span>
<p>  在看路人女主之前也并没有接触过原作，作为一个单纯的动画观众，路人女主给我的观感确实是不错的。现在想来，当初应当是入宅不久。并且作为纯爱战士（现在也已经扭曲了（悲）），也没有感觉路人女主是后宫但确实是党争，或者说这只是披着后宫皮的纯爱故事吧。</p>
<p>  从故事总体来看，主线故事正是加藤惠从路人到女主的转变。按照与男主相识的时长来看，英梨梨&gt;学姐&gt;加藤惠，所以在故事的前中期男主伦也喜欢的还是英梨梨，但在经历学姐和英梨梨的“背叛”之后，伦也明白了一直陪伴的身边的只有加藤惠。在经历英梨梨的第二次“背叛”之后，这里也是伦也和加藤惠关系正式由暗转明的开始，伦也也在这里开始正视他的女主。</p>
<p>  诚然，加藤惠为何会接受初次见面的伦也的邀请来担当游戏的女主角请求也并不明确。（实际上在男主第一次邂逅时惠就已经记住男主，故事背景中伦也与惠同班，并且也并称丰之崎三大怪人也早为惠所知）依我来说，应当可以从故事背景中看出端倪，在故事设定中惠应当是属于好看的那一档，设定上不如学姐和英梨梨那样引人注目，但在侦探坡吸引伦也来看，她的相貌其实不逊于学姐、英梨梨的。在前期一直强调惠的“路人”这一属性，这是贯彻整部作品的标签；与之并列的“女主”则是贴在惠身上的另一个标签，不同于路人<strong>环境</strong>赋予惠的标签，<strong>女主</strong>是伦也一直强调的并且只属于惠一个人的标签。或许这种<strong>偏爱</strong>正是为何惠会接受男主的邀请，一开始或许并没有喜欢的情感，正是这份偏爱让惠会愿意继续了解伦也，从而继续故事的发展。</p>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/public/51.5lugnvxjo9w0.jpg" alt="加藤惠" title="我永远喜欢加藤惠！！！"></p>
<h2 id="关于在学姐外传中不敢让加藤惠出场这件事"><a class="header-anchor" href="#关于在学姐外传中不敢让加藤惠出场这件事">¶</a>关于在学姐外传中不敢让加藤惠出场这件事</h2>
<p>  据传闻英梨梨外传中就因为惠出场导致被腰斩（败犬在个人线也是败犬啊 悲~），为什么英梨梨会从第一女主沦为败犬的形象代表呢？ 或许，有人说是因为她的傲娇属性，然而我认为她无法于惠相比的有两点——陪伴和自知之明。学姐在原作中是主动认输，她知道惠喜欢伦也并且对他的占有欲很强，他也知道伦也对她并没有男女之情，更多的是崇拜之情（在这里我就想提一嘴了，学姐个人线中最后确定伦理表白确认关系我也觉得很突兀，我甚至更喜欢相乐真由一些）。<strong><s>学姐输在那一点呢？除开最后的背叛来说，我认为是在“痴”上。原作中学姐无疑是一个痴女（仅对伦理来说，这也是萌点之一啊），因为她的痴女形象</s></strong><br>
  说回英梨梨，在三女中她与伦也相识最久，陪在伦也身边的时间相较于其他两人来说是最长的，这里说的陪伴并不是时间上的长短，更多的是在伦也低落和失意的时候无条件陪在他身边（应该不会有男人不喜欢惠这种女生吧？）</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>二次元</category>
        <category>《路人女主的养成方法》</category>
      </categories>
      <tags>
        <tag>路人女主的养成方法</tag>
        <tag>霞之丘诗羽</tag>
        <tag>完结读评</tag>
        <tag>加藤惠</tag>
        <tag>完结后有感</tag>
        <tag>丸户史明</tag>
      </tags>
  </entry>
  <entry>
    <title>Godot基本操作</title>
    <url>/2023/12/26/398901abd605/</url>
    <content><![CDATA[<h3 id="配置外部编辑器"><a class="header-anchor" href="#配置外部编辑器">¶</a>配置外部编辑器</h3>
<p>使用idea发现不能idea中的tab在godot脚本中会变成空格导致错误，还有不能同步的奇怪问题，所以还是决定使用vscode做外部编辑器。</p>
<ol>
<li>在下载vscode中下载godot的插件(适用于GDScript的那一个)</li>
<li>配置好lunch.json文件
<ol>
<li>参考网站<a href="https://docs.godotengine.org/en/stable/tutorials/editor/external_editor.html">外部编辑器设置</a></li>
<li>修改json代码</li>
</ol>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Godot Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;godot&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;project&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">6007</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;debugServer&quot;</span><span class="punctuation">:</span> <span class="number">6005</span><span class="punctuation">,</span> <span class="comment">//godot4.x修改了默认的端口，这里也要修改插件中对应的端口号(Gdscript_lsp_server_port也改为6005)</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;launch_game_instance&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;launch_scene&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="基础操作"><a class="header-anchor" href="#基础操作">¶</a>基础操作</h3>
<h4 id="节点的基础操作"><a class="header-anchor" href="#节点的基础操作">¶</a>节点的基础操作</h4>
<ul>
<li>Q，选择工具，最强大的工具</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alt + 拖曳边框缩放点，保持选中目标中心位置不变进行缩放</span><br><span class="line">Shift + 等比列缩放</span><br><span class="line">Ctrl + 鼠标拖曳，以pivot为中心旋转当前对象</span><br><span class="line">Alt + Shift + 拖曳边框缩放点，保持选中目标中心位置不变进行等比例缩放</span><br></pre></td></tr></table></figure>
<ul>
<li>E，旋转工具，改变 Rotation</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">轴心点，又称中心点，是节点的旋转中心</span><br><span class="line"></span><br><span class="line">V，移动轴心点，Shift + V 拖拽轴心点</span><br><span class="line"></span><br><span class="line">中心点是一个物体的中心，当我们对物体进行操作的时候，都是以中心点为中心进行对物体的操作</span><br><span class="line">轴心点可以理解为把物体抽象成一个点，物体的位置就是指其轴心点的位置，就是该物体坐标系的原点</span><br><span class="line"></span><br><span class="line">Rotate Mode 对象的旋转</span><br><span class="line">沿轴心点旋转</span><br></pre></td></tr></table></figure>
<ul>
<li>F，定位到选中对象</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>游戏制作</category>
      </categories>
      <tags>
        <tag>godot</tag>
        <tag>game engine</tag>
      </tags>
  </entry>
  <entry>
    <title>unity笔记</title>
    <url>/2024/03/02/6d3a7a302452/</url>
    <content><![CDATA[<h3 id="基础操作记录"><a class="header-anchor" href="#基础操作记录">¶</a>基础操作记录</h3>
<p><a href="https://www.bilibili.com/video/BV1gQ4y1e7SS">跟学视频</a><br>
<a href="https://blog.hiyoung.xyz/2024/03/13/d11c2f40712b/">脚本文件</a></p>
<span id="more"></span>
<h3 id="第一天学习P6-P10-创建物体、坐标系"><a class="header-anchor" href="#第一天学习P6-P10-创建物体、坐标系">¶</a>第一天学习P6-P10 创建物体、坐标系</h3>
<ol>
<li>
<p>创建3D物体<br>
在层级下鼠标右击选择 3D object中选择各种形状</p>
</li>
<li>
<p>坐标系<br>
分为世界坐标系和物体坐标系<br>
选中物体后在属性中transform.position的数值是相对于世界坐标系计算的<br>
将一个物体变为另一个物体的子类后单独移动，position还是相对世界坐标系的，但在移动父类时它和父类的相对位置不会改变(上手实践一下)</p>
</li>
<li>
<p>对物体的基本操作</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/unity%E7%AC%94%E8%AE%B0-1.36nq5cnboce0.webp" alt="unity笔记-1"></p>
<p>依次为:</p>
<ul>
<li>移动视角(可以按住鼠标中键),快捷键-Q</li>
<li>移动物体,快捷键-W</li>
<li>旋转物体,快捷键-E</li>
<li>放缩物体,快捷键-R</li>
<li>矩形工具,快捷键-T</li>
<li>综合变换,快捷键-Y</li>
</ul>
<ol start="4">
<li>导入模型和修改材质<br>
模型资源导入在assets中，还可以修改材质(materials)，选择外部材质即可。project中选中物体-&gt;Inspector-&gt;Materials</li>
</ol>
<p>也可以自己设置新材质，project右击-&gt;Create-&gt;Material</p>
<ol start="5">
<li>资源商定<br>
导航栏中Windows选中asset store，在商店中购买需要的素材。在package manager中下载和导入素材</li>
</ol>
<h3 id="第二天学习P11-P16-地编、脚本"><a class="header-anchor" href="#第二天学习P11-P16-地编、脚本">¶</a>第二天学习P11-P16 地编、脚本</h3>
<ol>
<li>地形编辑</li>
</ol>
<p>在3D object中新建一个Terrain。在属性中可以修改地形地貌，创建山川等。还可以添加贴图和森林</p>
<ol start="2">
<li>添加C#脚本</li>
</ol>
<p><a href="https://docs.unity3d.com/cn/2022.3/Manual/ExecutionOrder.html">Unity中事件函数的执行顺序</a></p>
<p>脚本要发挥作用需要添加到相应物体上才能实现</p>
<p>关于脚本的执行顺序：<br>
可以使用 Script Execution Order 设置（菜单：Edit &gt; Project Settings，然后选择 Script Execution Order 类别）<br>
或者在脚本的inspector中点击 Execution Order添加脚本如何修改优先级</p>
<h3 id="第三天学习P17-P23-标记、图层、预制体、向量、四元数"><a class="header-anchor" href="#第三天学习P17-P23-标记、图层、预制体、向量、四元数">¶</a>第三天学习P17-P23 标记、图层、预制体、向量、四元数</h3>
<ol>
<li>标记（Tag）和图层（Layer）</li>
</ol>
<p>给物体添加一个标记（tag），用来标记物体便于查找<br>
可以使用图层可以标记一类物体，一般用于碰撞检测、摄像机捕捉和显示</p>
<ol start="2">
<li>预制体（prefab）和预制体变体（prefab variant）</li>
</ol>
<p>将物体从图层Hierarchy移至项目project即可生成一个预制体</p>
<p>一个预制体就是一个模板，可以批量生成和修改类似的物体。而预制体变体类似于继承某一预制体并加上自己的需求（例如：某一预制体是不带帽子的个体而不同的预制体变体可以带帽子、带项链等），并且通过原始预制体可以统一修改预制体变体</p>
<ol start="3">
<li>向量、欧拉角、四元数和Vector3的一些使用</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//旋转，欧拉角、四元数</span></span><br><span class="line">    Vector3 rotate = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//定义一个四元数</span></span><br><span class="line">    Quaternion quaternion = Quaternion.identity;</span><br><span class="line">    <span class="comment">//四元数转换为欧拉角</span></span><br><span class="line">    rotate = quaternion.eulerAngles;</span><br><span class="line">    <span class="comment">//欧拉角转换为四元数</span></span><br><span class="line">    quaternion = Quaternion.Euler(rotate);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//物体指向某个角度</span></span><br><span class="line">    quaternion = Quaternion.LookRotation(<span class="keyword">new</span> Vector3(<span class="number">90</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第四天P24-GameObject类"><a class="header-anchor" href="#第四天P24-GameObject类">¶</a>第四天P24 GameObject类</h3>
<p>使用脚本动态控制物体的属性，GameObject类的使用，和一些API的使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmptyTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameObject emptyCube;</span><br><span class="line">    <span class="comment">//获取预设体，程序化生成物体</span></span><br><span class="line">    <span class="keyword">public</span> GameObject prefab;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到当前脚本所挂载的物体</span></span><br><span class="line">        GameObject go = <span class="keyword">this</span>.gameObject;</span><br><span class="line">        <span class="comment">//名称</span></span><br><span class="line">        Debug.Log(go.name);</span><br><span class="line">        <span class="comment">// = Debug.Log(gameObject.name);</span></span><br><span class="line">        <span class="comment">//tag</span></span><br><span class="line">        Debug.Log(gameObject.tag);</span><br><span class="line">        <span class="comment">//layer</span></span><br><span class="line">        Debug.Log(gameObject.layer);</span><br><span class="line">        <span class="comment">//Empty_Cube的名称</span></span><br><span class="line">        Debug.Log(emptyCube.name);</span><br><span class="line">        <span class="comment">//物体本身是否处于激活状态</span></span><br><span class="line">        Debug.Log(emptyCube.activeSelf);</span><br><span class="line">        <span class="comment">//物体在图层中是否实际处于激活状态</span></span><br><span class="line">        Debug.Log(emptyCube.activeInHierarchy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取transform组件</span></span><br><span class="line">        <span class="comment">// transform tans = this.transform; ==</span></span><br><span class="line">        Debug.Log(transform.position);</span><br><span class="line">        <span class="comment">//获取其他组件</span></span><br><span class="line">        BoxCollider bc = GetComponent&lt;BoxCollider&gt;();</span><br><span class="line">        <span class="comment">//获取当前物体的子物体身上的某个组件</span></span><br><span class="line">        GetComponentInChildren&lt;CapsuleCollider&gt;(<span class="literal">true</span>);</span><br><span class="line">        GetComponentsInChildren&lt;CapsuleCollider&gt;(bc);</span><br><span class="line">        <span class="comment">//获取当前物体父物体身上的某个组件</span></span><br><span class="line">        GetComponentInParent&lt;BoxCollider&gt;();</span><br><span class="line">        <span class="comment">//添加组件</span></span><br><span class="line">        emptyCube.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过游戏物体的名称来获取游戏物体，若物体同名则返回所有同名物体</span></span><br><span class="line">        GameObject enemy = GameObject.Find(<span class="string">&quot;enemy&quot;</span>);</span><br><span class="line">        <span class="comment">//通过标签来获取游戏物体，多个相同标签则返回最后一个创建的物体</span></span><br><span class="line">        GameObject enemy1 = GameObject.FindWithTag(<span class="string">&quot;enemy&quot;</span>);</span><br><span class="line">        Debug.Log(enemy.transform.position);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过预设体来实例化一个游戏物体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Instantiate(prefab,Vector3.zero, Quaternion.identity);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第五天P25-P29-一些类的使用"><a class="header-anchor" href="#第五天P25-P29-一些类的使用">¶</a>第五天P25-P29 一些类的使用</h3>
<p>主要是Time类、Application类、场景类、异步加载场景、transform类相关的一些方法使用<br>
笔记内容见脚本文件</p>
<h3 id="第六天P30-P31-鼠标键盘操作"><a class="header-anchor" href="#第六天P30-P31-鼠标键盘操作">¶</a>第六天P30-P31 鼠标键盘操作</h3>
<p>键盘、鼠标操作和虚拟轴的使用<br>
笔记内容见脚本文件</p>
<h3 id="第七天P32-P33-灯光、摄像机"><a class="header-anchor" href="#第七天P32-P33-灯光、摄像机">¶</a>第七天P32-P33 灯光、摄像机</h3>
<p>灯光、摄像机的使用</p>
<h4 id="灯光"><a class="header-anchor" href="#灯光">¶</a>灯光</h4>
<p>按照类型主要分为：定向光、聚光、点光源和区域光（仅烘培）</p>
<p>其中定向光类似于太阳光仅代表光线方向与光影物体位置无关</p>
<p>区域光（仅烘培）：由于实时光照性能消耗较大，在一个光源固定的场景中可以预先烘培光照来减轻负担。</p>
<p>要使用烘培我们首先需要设定对象为Contribute GI，选中对象，勾选Static下的Contribute GI（组成GI）。然后在Windows-&gt;Rendering-&gt;Lighting(快捷键Crtl+9)中点击Generate Lighting渲染</p>
<p>Lightmap适用于静态光照贴图对象，所有标记为Contribute GI的物体都会被被渲染到Lightmap（光照贴图）中</p>
<p>除了类型外，还可以选择光照的渲染方式（Mode）、强度（Intensity）、阴影类型（Shadow Type）、剪影（Cookie）</p>
<p>在光照下选择剔除遮罩（Culling Mask）可以选择是否渲染不同图层</p>
<h4 id="摄像机"><a class="header-anchor" href="#摄像机">¶</a>摄像机</h4>
<p>摄像机可以选择透视摄像机或者正交摄像机。其中透视摄像机在3D游戏中使用，有近大远小的特点。正交摄像机在2D游戏中使用，所有物体都被放在一个平面上。</p>
<p>在摄像机Clear Flags中可以选择在空区域中显示什么，例如天空盒（SkyBox）、纯色（Soiled color）、仅深度（Depth Only）或者不显示（Don`t clear）<br>
若选择了天空盒则可以在摄像机中添加Skybox组件来更换不同天空。</p>
<p>深度（Depth）属性：若有多个摄像机会根据深度属性数值大小来决定哪个摄像机会优先显示在游戏界面。深度数值越大的会优先显示。</p>
<p>若有多个摄像机时选择仅深度可以实现在游戏（Game）视窗同时显示多个摄像机捕捉的物体</p>
<p>视野（Filed of View）可以调节摄像机视野</p>
<p>裁切平面（Clipping Planes）可以调节摄像机的远面和近面</p>
<p>Viewpoint Rect可以调整摄像机在游戏（Game）视窗的位置和高度宽度</p>
<p>目标显示（Target Display）可以修改摄像机的显示目标，在游戏（Game）视窗可以切换Display</p>
<p>在Project中可以新建一个目标纹理（Render Texture）（需挂载在一个物体上），然后将目标纹理拖到摄像机的Target Texture上即可实现将摄像机捕捉的画面映射在物体上</p>
<h3 id="第八天P35-P38-声音、视频和角色移动控制"><a class="header-anchor" href="#第八天P35-P38-声音、视频和角色移动控制">¶</a>第八天P35-P38 声音、视频和角色移动控制</h3>
<p>声音、视频和角色移动控制</p>
<h4 id="声音"><a class="header-anchor" href="#声音">¶</a>声音</h4>
<p>在物体上添加Audio Source组件后即可播放声音，只需将音频拖到AudioClip上即可，同时可以在Audio Source中调节声音效果<br>
还可以使用脚本来控制声音的播放暂停等操作，具体细节可以看脚本<br>
要听见声音需要一个Audio Listener组件，一般在摄像机上。若有多个摄像机则只能有一个有Audio Listener组件</p>
<h3 id="视频"><a class="header-anchor" href="#视频">¶</a>视频</h3>
<p>视频和声音的一些操作类似<br>
需要一个Video Player组件，在组件的Video Clip上添加上需要播放的视频。此外，可以将Video Player的渲染模式（Render Mode）改为渲染器纹理（Render Texture），新建一个渲染器纹理将其拖到目标纹理上。再将该目标纹理拖到物体上即可。使用这种渲染器纹理方式可以统一改变所有使用该渲染器纹理的视频，在需要重复使用在多个物体上的视频来说很便捷。</p>
<p>还可以通过脚本来控制视频的播放暂停。（见脚本文件）</p>
<h3 id="角色控制器"><a class="header-anchor" href="#角色控制器">¶</a>角色控制器</h3>
<p>见脚本文件</p>
<h3 id="第九天P39-P40"><a class="header-anchor" href="#第九天P39-P40">¶</a>第九天P39-P40</h3>
<h4 id="碰撞"><a class="header-anchor" href="#碰撞">¶</a>碰撞</h4>
<p>Tips：选中摄像机，Ctrl+Shift+F可以对齐视图，快速调节视角</p>
<p>产生碰撞的条件：</p>
<ul>
<li>2个游戏对象都有Collider</li>
<li>至少有一个游戏对象有Rigidbody</li>
<li>2个游戏对象保持相对运动（一个Cube放在Plane上，不会产生碰撞，因为没有相对运动）</li>
</ul>
<h4 id="触发"><a class="header-anchor" href="#触发">¶</a>触发</h4>
<p>要将物体改为触发器，只需在Box Collider中将is trigger勾选上，然后使用脚本完成触发逻辑（见脚本文件）</p>
<h3 id="第十天P41-47"><a class="header-anchor" href="#第十天P41-47">¶</a>第十天P41-47</h3>
<h4 id="铰链、弹簧和物理关节"><a class="header-anchor" href="#铰链、弹簧和物理关节">¶</a>铰链、弹簧和物理关节</h4>
<p>为物体添加铰链组件：<strong>Hinge Joint</strong></p>
<p>弹簧组件：需要选中两个物体，添加<strong>Spring Joint</strong>，在Connected Body选中要连接的物体（连接的物体需要有刚体才可添加）</p>
<p>物理关节：添加<strong>Fixed Joint</strong></p>
<h4 id="物理材质（摩擦力）"><a class="header-anchor" href="#物理材质（摩擦力）">¶</a>物理材质（摩擦力）</h4>
<p>在Assets中新建-&gt;物理材质（Physic Material），然后在Collider的材质中将物理材质拖入即可<br>
在Physic Material中可以调节材质的动摩擦，静摩擦和弹力数值</p>
<h4 id="射线检测"><a class="header-anchor" href="#射线检测">¶</a>射线检测</h4>
<p>类似于从摄像机发出一条射线，点击某个位置可以检测出位置等信息</p>
<h4 id="粒子系统"><a class="header-anchor" href="#粒子系统">¶</a>粒子系统</h4>
<p>添加Particle System组件，来设置粒子效果</p>
<h4 id="绘制线条和拖尾"><a class="header-anchor" href="#绘制线条和拖尾">¶</a>绘制线条和拖尾</h4>
<p>添加Line Renderer组件</p>
<h4 id="动画"><a class="header-anchor" href="#动画">¶</a>动画</h4>
<p>有老版的Animation组件和新版的Animator组件<br>
使用Animator组件需要给模型挂载一个Animator组件，然后再打开Animator窗口即可使用类似于蓝图的方式来完成动画</p>
<h3 id="第十一天P48-P50"><a class="header-anchor" href="#第十一天P48-P50">¶</a>第十一天P48-P50</h3>
<p>按键控制角色移动+角色动画的使用，见脚本文件</p>
<p>动画剪辑</p>
<h3 id="第十二天P51-P54"><a class="header-anchor" href="#第十二天P51-P54">¶</a>第十二天P51-P54</h3>
<h4 id="动画曲线"><a class="header-anchor" href="#动画曲线">¶</a>动画曲线</h4>
<p>在动画文件中可以找到Curves（曲线），并在animator中添加一个float与<strong>曲线名同名参数</strong>，相当于一个随动画播放而变化的<strong>数值函数</strong>，可以获得一个随动画播放而不断变化的数值。例如，如果做一个挥拳的动画，可以通过这个数值来控制挥拳可能用到的特效、声音等。</p>
<h4 id="动画事件"><a class="header-anchor" href="#动画事件">¶</a>动画事件</h4>
<p>动画事件（Evevts），<strong>事件是一个函数</strong>，事件名即函数名，可以在挂载在物体的脚本上调用同名函数。通过设置事件在动画中发生的时间点则可以调用事件函数中的代码，实现需要的效果。</p>
<h4 id="混合动画"><a class="header-anchor" href="#混合动画">¶</a>混合动画</h4>
<p>在animator界面中可以右键-&gt;Create State-&gt;From Blend Tree，添加一个混合动画，在Blend Tree中可以添加多个动作，修改动画的比例来混合动画。</p>
<h4 id="动画遮罩"><a class="header-anchor" href="#动画遮罩">¶</a>动画遮罩</h4>
<p>在Assets-&gt;Create-&gt;Avatar Mask，新建一个动画遮罩，在遮罩里选择Humanoid，可以选择只使用那一身体部分的动画，然后在Animator的动画层级中选择添加Mask即可</p>
<h3 id="第十三天P55"><a class="header-anchor" href="#第十三天P55">¶</a>第十三天P55-</h3>
<h4 id="IK-反向动力学"><a class="header-anchor" href="#IK-反向动力学">¶</a>IK(反向动力学)</h4>
<h4 id="导航的使用"><a class="header-anchor" href="#导航的使用">¶</a>导航的使用</h4>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>游戏制作</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>笔记</tag>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>unity脚本</title>
    <url>/2024/03/01/abe151f591a2/</url>
    <content><![CDATA[<h3 id="脚本文件"><a class="header-anchor" href="#脚本文件">¶</a>脚本文件</h3>
<span id="more"></span>
<h3 id="Vector3"><a class="header-anchor" href="#Vector3">¶</a>Vector3</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//向量，坐标，旋转，缩放</span></span><br><span class="line">    Vector3 v = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>,<span class="number">0</span> );</span><br><span class="line">    Vector3 v1 = Vector3.right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算两个向量夹角</span></span><br><span class="line">    Debug.Log(Vector3.Angle(v,v1));</span><br><span class="line">    <span class="comment">//计算两点间距离</span></span><br><span class="line">    Debug.Log(Vector3.Distance(v,v1));</span><br><span class="line">    <span class="comment">//点乘</span></span><br><span class="line">    Debug.Log(Vector3.Dot(v,v1));</span><br><span class="line">    <span class="comment">//叉乘</span></span><br><span class="line">    Debug.Log(Vector3.Cross(v,v1));</span><br><span class="line">    <span class="comment">//插值</span></span><br><span class="line">    Debug.Log(Vector3.Lerp(Vector3.left,Vector3.right,<span class="number">0.5f</span>));</span><br><span class="line">    <span class="comment">//向量的模</span></span><br><span class="line">    Debug.Log(v.magnitude);</span><br><span class="line">    <span class="comment">//规范化向量</span></span><br><span class="line">    Debug.Log(v.normalized);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Time类"><a class="header-anchor" href="#Time类">¶</a>Time类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Timetest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> _timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Time时间类</span></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//游戏开始到现在所花的时间</span></span><br><span class="line">        Debug.Log(Time.time);</span><br><span class="line">        <span class="comment">//时间缩放值，加速减速</span></span><br><span class="line">        Debug.Log(Time.timeScale);</span><br><span class="line">        <span class="comment">//固定时间间隔</span></span><br><span class="line">        Debug.Log(Time.fixedDeltaTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Time.deltaTime : 上一帧到这这一帧所用的游戏时间</span></span><br><span class="line">        <span class="comment">//这里类似于计时器的作用 </span></span><br><span class="line">        _timer += Time.deltaTime;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Debug.Log(Time.deltaTime);</span></span><br><span class="line">        <span class="keyword">if</span> (_timer &gt; <span class="number">3</span>)     </span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;时间大于3&quot;</span>);</span><br><span class="line">            _timer = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Application类"><a class="header-anchor" href="#Application类">¶</a>Application类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//游戏数据文件夹路径（只读，打包后会加密压缩）</span></span><br><span class="line">        Debug.Log(UnityEngine.Application.dataPath);</span><br><span class="line">        <span class="comment">//持久化文件夹路径（可以放存档）</span></span><br><span class="line">        Debug.Log(UnityEngine.Application.persistentDataPath);</span><br><span class="line">        <span class="comment">//StreamingAssets文件夹路径（只读，但打包后不会加密压缩，可以放一些配置文件等）</span></span><br><span class="line">        Debug.Log(UnityEngine.Application.streamingAssetsPath);</span><br><span class="line">        <span class="comment">//临时文件夹</span></span><br><span class="line">        Debug.Log((UnityEngine.Application.temporaryCachePath));</span><br><span class="line">        <span class="comment">//控制是否在后台运行</span></span><br><span class="line">        Debug.Log(UnityEngine.Application.runInBackground);</span><br><span class="line">        <span class="comment">//打开URL</span></span><br><span class="line">        <span class="comment">// UnityEngine.Application.OpenURL(&quot;https://www.bilibili.com/&quot;);</span></span><br><span class="line">        <span class="comment">//退出游戏</span></span><br><span class="line">        UnityEngine.Application.Quit();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="场景类"><a class="header-anchor" href="#场景类">¶</a>场景类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//场景类、场景管理类</span></span><br><span class="line">    <span class="comment">//场景跳转</span></span><br><span class="line">    <span class="comment">// SceneManager.LoadScene(&quot;MyScene&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前场景</span></span><br><span class="line">    Scene scene = SceneManager.GetActiveScene();</span><br><span class="line">    Debug.Log(scene.name);</span><br><span class="line">    <span class="comment">// Debug.Log(SceneManager.GetActiveScene().name);</span></span><br><span class="line">    <span class="comment">//场景是否已经加载</span></span><br><span class="line">    Debug.Log(scene.isLoaded);</span><br><span class="line">    <span class="comment">//场景路径</span></span><br><span class="line">    Debug.Log(scene.path);</span><br><span class="line">    <span class="comment">//场景索引</span></span><br><span class="line">    Debug.Log(scene.buildIndex);</span><br><span class="line">    <span class="comment">//获取场景中所有物体</span></span><br><span class="line">    Debug.Log(scene.GetRootGameObjects().Length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//场景管理类</span></span><br><span class="line">    <span class="comment">//创建新场景</span></span><br><span class="line">    Scene newScene =  SceneManager.CreateScene(<span class="string">&quot;NewScene&quot;</span>);</span><br><span class="line">    <span class="comment">//已加载的场景个数</span></span><br><span class="line">    Debug.Log(SceneManager.sceneCount);</span><br><span class="line">    <span class="comment">//卸载一个场景</span></span><br><span class="line">    SceneManager.UnloadSceneAsync(newScene);</span><br><span class="line">    <span class="comment">//加载场景（Signal和Additive方式）</span></span><br><span class="line">    SceneManager.LoadScene(<span class="string">&quot;MyScene&quot;</span>,LoadSceneMode.Additive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="异步加载场景"><a class="header-anchor" href="#异步加载场景">¶</a>异步加载场景</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Async</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> AsyncOperation _operation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(LoadScene());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用协程方法来异步加载场景</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">LoadScene</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _operation = SceneManager.LoadSceneAsync(<span class="string">&quot;MyScene&quot;</span>);</span><br><span class="line">        <span class="comment">//加载完场景不要自动跳转</span></span><br><span class="line">        _operation.allowSceneActivation = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> _operation;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//输出加载进度0-0.9</span></span><br><span class="line">        Debug.Log(_operation.progress);</span><br><span class="line">        timer += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (timer &gt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _operation.allowSceneActivation = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="transform类"><a class="header-anchor" href="#transform类">¶</a>transform类</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">transform</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取位置</span></span><br><span class="line">        <span class="comment">//position为物体所在的世界位置</span></span><br><span class="line">        Debug.Log(transform.position);</span><br><span class="line">        <span class="comment">//localPosition为物体所在的相对父物体的位置（如何有的话）</span></span><br><span class="line">        Debug.Log(transform.localPosition);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取旋转</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;旋转：&quot;</span>+transform.rotation);</span><br><span class="line">        Debug.Log(transform.localPosition);</span><br><span class="line">        Debug.Log(<span class="string">&quot;欧拉角：&quot;</span> + transform.eulerAngles);</span><br><span class="line">        Debug.Log(<span class="string">&quot;相对父物体的欧拉角：&quot;</span>+transform.localPosition);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取缩放</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;获取缩放:&quot;</span>+transform.localScale);</span><br><span class="line">        <span class="comment">//向量</span></span><br><span class="line">        Debug.Log(transform.forward);</span><br><span class="line">        Debug.Log(transform.right);</span><br><span class="line">        Debug.Log(transform.up);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//父子关系</span></span><br><span class="line">        <span class="comment">//获取父物体</span></span><br><span class="line">        GameObject go =  transform.parent.gameObject;</span><br><span class="line">        <span class="comment">//子物体个数</span></span><br><span class="line">        Debug.Log(transform.childCount);</span><br><span class="line">        <span class="comment">//解除与子物体的父子关系</span></span><br><span class="line">        transform.DetachChildren();</span><br><span class="line">        <span class="comment">//获取子物体的两种方法</span></span><br><span class="line">        Transform trans = transform.Find(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">        Transform trans1 = transform.GetChild(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//判断一个物体是否是另一个物体的子物体</span></span><br><span class="line">        <span class="built_in">bool</span> res = trans.IsChildOf(transform);</span><br><span class="line">        Debug.Log(res);</span><br><span class="line">        <span class="comment">//设置为父物体</span></span><br><span class="line">        trans.SetParent(transform);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//固定看向某一点</span></span><br><span class="line">        transform.LookAt(Vector3.zero);</span><br><span class="line">        <span class="comment">//旋转</span></span><br><span class="line">        transform.Rotate(Vector3.right, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//绕某个物体旋转</span></span><br><span class="line">        transform.RotateAround(Vector3.zero, Vector3.up, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//移动</span></span><br><span class="line">        transform.Translate(Vector3.forward * <span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="鼠标、键盘操作"><a class="header-anchor" href="#鼠标、键盘操作">¶</a>鼠标、键盘操作</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//鼠标的点击</span></span><br><span class="line">    <span class="comment">//按下鼠标 0左键 1右键 2按下滚轮</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;鼠标左键点击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;持续按下鼠标左键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;抬起鼠标左键&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按下键盘按键</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(<span class="string">&quot;w&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;按下w&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Input.GetKey(KeyCode.W))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;持续按w&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyUp(KeyCode.W))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;松开w&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="触摸操作"><a class="header-anchor" href="#触摸操作">¶</a>触摸操作</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//开启多点触摸</span></span><br><span class="line">    Input.multiTouchEnabled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断单点触摸</span></span><br><span class="line">    <span class="keyword">if</span> (Input.touchCount == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//触摸对象</span></span><br><span class="line">        UnityEngine.Touch touch = Input.touches[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//触摸位置</span></span><br><span class="line">        Debug.Log(touch.position);</span><br><span class="line">        <span class="comment">//触摸阶段</span></span><br><span class="line">        <span class="keyword">switch</span> (touch.phase)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> TouchPhase.Began:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TouchPhase.Moved:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TouchPhase.Stationary:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TouchPhase.Ended:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TouchPhase.Canceled:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断多点触摸</span></span><br><span class="line">    <span class="keyword">if</span> (Input.touchCount == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Touch touch1 = Input.touches[<span class="number">0</span>];</span><br><span class="line">        UnityEngine.Touch touch2 = Input.touches[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚拟轴"><a class="header-anchor" href="#虚拟轴">¶</a>虚拟轴</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //获取水平轴</span></span><br><span class="line"><span class="comment">        float horizontal = Input.GetAxis(&quot;Horizontal&quot;);</span></span><br><span class="line"><span class="comment">        float vertical = Input.GetAxis(&quot;Vertical&quot;);</span></span><br><span class="line"><span class="comment">        Debug.Log(horizontal + &quot;------&quot;+ vertical);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//虚拟按键</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;space down&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonUp(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;space up&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="声音-v2"><a class="header-anchor" href="#声音-v2">¶</a>声音</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Audio</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//AudioClip</span></span><br><span class="line">    <span class="keyword">public</span> AudioClip music;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AudioClip se;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//播放器组件</span></span><br><span class="line">    <span class="keyword">private</span> AudioSource _player;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player = GetComponent&lt;AudioSource&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设定播放的音频</span></span><br><span class="line">        _player.clip = music;</span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        _player.loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//音量</span></span><br><span class="line">        _player.volume = <span class="number">0.5f</span>;</span><br><span class="line">        <span class="comment">//播放</span></span><br><span class="line">        _player.Play();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按空格控制播放</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_player.isPlaying)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//暂停播放</span></span><br><span class="line">                _player.Pause();</span><br><span class="line">                <span class="comment">//停止播放（下次从头开始播放）</span></span><br><span class="line">                <span class="comment">// _player.Stop();</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//重新播放</span></span><br><span class="line">                _player.UnPause();</span><br><span class="line">                <span class="comment">//与Stop一起使用</span></span><br><span class="line">                <span class="comment">// _player.Play();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//播放一次音效</span></span><br><span class="line">            _player.PlayOneShot(se);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="视频-v2"><a class="header-anchor" href="#视频-v2">¶</a>视频</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Video</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> VideoPlayer _player;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player = GetComponent&lt;VideoPlayer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_player.isPlaying)</span><br><span class="line">            &#123;</span><br><span class="line">                _player.Stop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _player.Play();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="控制角色移动"><a class="header-anchor" href="#控制角色移动">¶</a>控制角色移动</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerControl</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CharacterController _character;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _character = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//水平轴</span></span><br><span class="line">        <span class="built_in">float</span> horizontal = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="comment">//垂直轴</span></span><br><span class="line">        <span class="built_in">float</span> vertical = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="comment">//创建成一个方向向量</span></span><br><span class="line">        Vector3 dir = <span class="keyword">new</span> Vector3(-horizontal, <span class="number">0</span>, -vertical);</span><br><span class="line">        Debug.DrawRay(transform.position,dir,Color.red);</span><br><span class="line">        <span class="comment">//朝向该方向移动</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.LeftShift))</span><br><span class="line">        &#123;</span><br><span class="line">            _character.SimpleMove(dir * <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _character.SimpleMove(dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="触发器"><a class="header-anchor" href="#触发器">¶</a>触发器</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以使用三个函数来实现触发进入、持续、退出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GameObject door = GameObject.Find(<span class="string">&quot;trigger1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (door != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        door.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制角色移动并播放动画P48"><a class="header-anchor" href="#控制角色移动并播放动画P48">¶</a>控制角色移动并播放动画P48</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerControl</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Animator _animator;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//水平轴</span></span><br><span class="line">        <span class="built_in">float</span> horizontal = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="comment">//垂直轴</span></span><br><span class="line">        <span class="built_in">float</span> vertical = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="comment">//创建成一个方向向量</span></span><br><span class="line">        Vector3 dir = <span class="keyword">new</span> Vector3(horizontal, <span class="number">0</span>, vertical);</span><br><span class="line">        Debug.DrawRay(transform.position,dir,Color.red);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dir != Vector3.zero)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//朝向该方向移动</span></span><br><span class="line">            transform.rotation = Quaternion.LookRotation(dir);</span><br><span class="line">            _animator.SetBool(<span class="string">&quot;iswalk_bool&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//朝向前方移动</span></span><br><span class="line">            transform.Translate(Vector3.forward * <span class="number">1</span> *Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _animator.SetBool(<span class="string">&quot;iswalk_bool&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.LeftShift) &amp;&amp; dir != Vector3.zero)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//切换跑步</span></span><br><span class="line">            _animator.SetBool(<span class="string">&quot;isrun&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            transform.Translate(Vector3.forward * <span class="number">3</span> *Time.deltaTime);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _animator.SetBool(<span class="string">&quot;isrun&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>游戏制作</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>笔记</tag>
        <tag>游戏脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS笔记</title>
    <url>/2022/08/18/7e184a929561/</url>
    <content><![CDATA[<style>
    .class_1{
    color: red;
  }
</style>
<p>近日为实现萌娘百科上的小黑条功能，特学习一番CSS<span class="heimu" title="你知道的太多了">，已经实现了捏</span></p>
<span id="more"></span>
<h2> 一、CSS语法</h2>
<h4 id="1-基本属性"><a class="header-anchor" href="#1-基本属性">¶</a>1.基本属性</h4>
<ol>
<li>CSS 规则集（rule-set）由选择器和声明块组成：<br>
<code> h1 &#123;color:red;font-size:14px;&#125;</code></li>
</ol>
<blockquote>
<ul>
<li>h1-&gt;选择器</li>
<li>color-&gt;属性</li>
<li>red-&gt;属性值</li>
<li>{color:red;}-&gt;声明</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>选择器指向您需要设置样式的 HTML 元素。</li>
<li>声明块包含一条或多条用分号分隔的声明。</li>
<li>每条声明都包含一个 CSS 属性名称和一个值，以<strong>冒号</strong>分隔。</li>
<li><strong>多条 CSS 声明用分号</strong>分隔，<strong>声明块用花括号</strong>括起来。</li>
</ul>
</blockquote>
<h5 id="实例1-1"><a class="header-anchor" href="#实例1-1">¶</a>实例1.1</h5>
<p>在此例中，所有 <code>&lt;p&gt;</code>元素都将居中对齐，并带有红色文本颜色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-CSS选择器"><a class="header-anchor" href="#2-CSS选择器">¶</a>2.CSS选择器</h4>
<h4 id="1-分类"><a class="header-anchor" href="#1-分类">¶</a>1. 分类</h4>
<p>CSS 选择器用于“查找”（或选取）要设置样式的 HTML 元素。</p>
<p>我们可以将 CSS 选择器分为五类：</p>
<ul>
<li>简单选择器（根据名称、id、类来选取元素）</li>
<li>组合器选择器（根据它们之间的特定关系来选取元素）</li>
<li>伪类选择器（根据特定状态选取元素）</li>
<li>伪元素选择器（选取元素的一部分并设置其样式）</li>
<li>属性选择器（根据属性或属性值来选取元素）</li>
</ul>
<h4 id="2-CSS元素选择器"><a class="header-anchor" href="#2-CSS元素选择器">¶</a>2. CSS元素选择器</h4>
<p>元素选择器根据元素名称来选择 HTML 元素</p>
<h5 id="实例1-2"><a class="header-anchor" href="#实例1-2">¶</a>实例1.2</h5>
<p>在此例中，所有 <code>&lt;p&gt;</code>元素都将居中对齐，并带有红色文本颜色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-CSS-id-选择器"><a class="header-anchor" href="#3-CSS-id-选择器">¶</a>3. CSS id 选择器</h4>
<p>id 选择器使用 HTML 元素的 id 属性来选择特定元素。</p>
<p>元素的 id 在页面中是唯一的，因此 id 选择器用于选择一个唯一的元素！</p>
<p>要选择具有特定 id 的元素，请写一个井号（#），后跟该元素的 id。</p>
<p><strong>注意</strong>：id 名称不能以数字开头。</p>
<h5 id="实例1-3"><a class="header-anchor" href="#实例1-3">¶</a>实例1.3</h5>
<p>这条 CSS 规则将应用于 id=“para1” 的 HTML 元素：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-id">#para1</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">p</span> id=&quot;para1&quot;&gt;Hello World!&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;本段不受样式的影响。&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-CSS-类选择器"><a class="header-anchor" href="#4-CSS-类选择器">¶</a>4. CSS 类选择器</h4>
<p>类选择器选择有特定 class 属性的 HTML 元素。</p>
<p>如需选择拥有特定 class 的元素，请写一个句点（.）字符，后面跟类名。</p>
<p><strong>注意</strong>：类名不能以数字开头！</p>
<h5 id="实例1-4"><a class="header-anchor" href="#实例1-4">¶</a>实例1.4</h5>
<p>在此例中，所有带有 class=“center” 的 HTML 元素将为红色且居中对齐：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">h1</span> class=&quot;center&quot;&gt;居中的红色标题&lt;/<span class="selector-tag">h1</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span> class=&quot;center&quot;&gt;居中的红色段落。&lt;/<span class="selector-tag">p</span>&gt; </span><br></pre></td></tr></table></figure>
<h5 id="实例1-5"><a class="header-anchor" href="#实例1-5">¶</a>实例1.5</h5>
<p>也可以指定只有特定的 HTML 元素会受类的影响。</p>
<p>在这个例子中，只有具有 class=“center” 的 <code>&lt;p&gt;</code>元素会居中对齐：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实例1-6"><a class="header-anchor" href="#实例1-6">¶</a>实例1.6</h5>
<p>HTML 元素也可以引用多个类。</p>
<p>在这个例子中，<p> 元素将根据 class=“center” 和 class=“large” 进行样式设置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">p</span> class=&quot;center large&quot;&gt;这个段落引用两个类。&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Tips：class和id的区别</strong></p>
<blockquote></blockquote>
<p>id是一个标签，只能用在一个结构或内容上，用于区分不同的结构和内容</p>
<p>class是一个样式，可以用在任何结构和内容上</p>
<blockquote></blockquote>
<h4 id="5-CSS-通用选择器"><a class="header-anchor" href="#5-CSS-通用选择器">¶</a>5. CSS 通用选择器</h4>
<p>通用选择器（*）选择页面上的所有的 HTML 元素。</p>
<h5 id="实例1-7"><a class="header-anchor" href="#实例1-7">¶</a>实例1.7</h5>
<p>下面的 CSS 规则会影响页面上的每个 HTML 元素：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-CSS-分组选择器"><a class="header-anchor" href="#6-CSS-分组选择器">¶</a>6. CSS 分组选择器</h4>
<p>分组选择器选取所有具有相同样式定义的 HTML 元素</p>
<p>如需对选择器进行分组，请用逗号来分隔每个选择器</p>
<h5 id="实例1-8"><a class="header-anchor" href="#实例1-8">¶</a>实例1.8</h5>
<p>在这个例子中，<code>&lt;h1&gt;,&lt;h2&gt;,&lt;p&gt;</code> 具有相同的属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-总结"><a class="header-anchor" href="#7-总结">¶</a>7. 总结</h4>
<table>
<tr>
<th>选择器</th>     <th>例子</th>       <th>例子描述</th>
</tr>
<tr>
<td>.class</td>   <td>.intro</td>   <td>选取所有 class="intro" 的元素</td>
</tr>
<tr>
<td>#id</td>   <td>#firstname</td>   <td>选取 id="firstname" 的那个元素</td>
</tr>
<tr>
<td>*</td>   <td>*</td>   <td>选取所有元素。</td>
</tr>
<tr>
<td>element</td>   <td>p</td>   <td>选取所有&lt;p&gt;元素</td>
</tr>
<tr>
<td>element,element,..</td>   <td>div, p</td>   <td>选取所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素</td>
</tr>
</table>
<h3 id="二、如何添加CSS"><a class="header-anchor" href="#二、如何添加CSS">¶</a>二、如何添加CSS</h3>
<h4 id="有四种插入样式表的方法："><a class="header-anchor" href="#有四种插入样式表的方法：">¶</a>有四种插入样式表的方法：</h4>
<ul>
<li><a href="#%E5%A4%96%E9%83%A8css">外部(链接方式) CSS</a></li>
<li><a href="#%E5%86%85%E9%83%A8css">内部(嵌入方式) CSS</a></li>
<li><a href="#%E8%A1%8C%E5%86%85css">行内 CSS</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5css">导入(导入方式) CSS</a></li>
</ul>
<h4 id="外部CSS"><a class="header-anchor" href="#外部CSS">¶</a>外部CSS</h4>
<p>通过使用外部样式表，只需修改一个文件即可改变整个网站的外观</p>
<p>每张 HTML 页面必须在 <code>&lt;head&gt;</code>部分的<code>&lt;link&gt;</code>元素内包含对外部样式表文件的引用</p>
<p>外部样式表必须以 .css 扩展名保存，外部 .css 文件不应包含HTML标签，仅需写入css代码即可</p>
<p>外部CSS是目前使用最多的引入CSS的方式，比较推荐使用此方式添加CSS</p>
<p><strong><span class="class_1">注意</span></strong>：请勿在属性值和单位之间添加空格（例如<code> margin-left: 20 px;</code>）正确的写法是：<code>margin-left: 20px;</code></p>
<h5 id="实例2-1"><a class="header-anchor" href="#实例2-1">¶</a>实例2.1</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="内部CSS"><a class="header-anchor" href="#内部CSS">¶</a>内部CSS</h4>
<p>如果一张 HTML 页面拥有唯一的样式，那么可以使用内部样式表。</p>
<p>内部样式是在<code>&lt;head&gt;</code>部分的<code>&lt;style&gt;</code>元素中进行定义，直接在style中添加css代码即可</p>
<h5 id="实例2-2"><a class="header-anchor" href="#实例2-2">¶</a>实例2.2</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: linen;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: maroon;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-left</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">&#125; </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="行内CSS"><a class="header-anchor" href="#行内CSS">¶</a>行内CSS</h4>
<p>行内样式（也称内联样式）可用于为单个元素应用唯一的样式。</p>
<p>如需使用行内样式，请将 style 属性添加到相关元素。style 属性可包含任何 CSS 属性。</p>
<p>并不建议使用此方式</p>
<h5 id="实例2-3"><a class="header-anchor" href="#实例2-3">¶</a>实例2.3</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 行内样式在相关元素的 &quot;style&quot; 属性中定义： --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color:blue;text-align:center;&quot;</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red;&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="导入CSS"><a class="header-anchor" href="#导入CSS">¶</a>导入CSS</h4>
<p>导入方式指的是使用 CSS 规则引入外部 CSS 文件。<br>
非必要情况下建议使用外部CSS(link标签引入)，原因如下：</p>
<blockquote>
<ul>
<li>link 属于 HTML，通过 <link> 标签中的 href 属性来引入外部文件，而 @import 属于 CSS，所以导入语句应写在 CSS 中，要注意的是导入语句应写在样式表的开头，否则无法正确导入外部文件；<br>
<br></li>
<li>@import 是 CSS2.1 才出现的概念，所以如果浏览器版本较低，无法正确导入外部样式文件；<br>
<br></li>
<li>当 HTML 文件被加载时，link 引用的文件会同时被加载，而 @import 引用的文件则会等页面全部下载完毕再被加载；</li>
</ul>
</blockquote>
<h5 id="实例2-4"><a class="header-anchor" href="#实例2-4">¶</a>实例2.4</h5>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="keyword">@import</span> url(style.css);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp语言基础</title>
    <url>/2024/01/15/de51b4aa334f/</url>
    <content><![CDATA[<h2 id="部分内容复习"><a class="header-anchor" href="#部分内容复习">¶</a>部分内容复习</h2>
<span id="more"></span>
<h3 id="二级指针的作用"><a class="header-anchor" href="#二级指针的作用">¶</a><a href="https://www.cnblogs.com/yongdaimi/p/13936028.html">二级指针的作用</a></h3>
<ol>
<li>指向指针的指针的作用:当要<strong>修改实参指针的指向</strong>的时候，<strong>形参</strong>必须使用指向指针的指针。</li>
<li>当修改的是<strong>实参指针指向的内容</strong>时，则<strong>形参</strong>只需是指针即可</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> *p,<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    p=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*num);<span class="comment">//p是形参指向的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str=<span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str,<span class="number">100</span>);<span class="comment">//str是实参指向的地址，不能通过调用函数来申请内存</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结构是编译能通过，却不能运行，为什么呢？</p>
<p>先说一下指针作为函数参数的意义：当将指针作为参数时，实参向形参传递的是地址，在函数执行过程中，既可以对该参数指针进行处理，也可以对该参数指针所指向的数据进行处理，（以上程序段来说就是可以对p或*p进行处理）。<strong>由于此时形参和实参都是指向同一个存储单元，因此当形参指针所指向的数据改变时，实参指针所指向的数据也作相应的改变，因此这时的形参可以作为输出参数使用。</strong>（str和p应同时更改！）</p>
<p>按照上面的说法，这个程序应该没有问题的啊，实参str和形参p指向同一个存储单元，给形参分配的内存单元应该也给实参分配了才对啊，问题就是在这里</p>
<p style="color:red"><b>实参和形参是指向同一个地址，它们只是指向相同，但它们自身的地址不是同时申请的，就是说p在申请内存时，相当于是把p的指向给改了，但是str的指向仍然没有改！所以尽管str调用了GetMemory，但它仍然是个空指针，所以进行strcpy是就不能运行</b></p>
<p>要使程序可以运行，只要小小的改动就行了（用指向指针的指针）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> **p,<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">　　*p=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*num); <span class="comment">//此时*p就变成了是形参本身的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="type">char</span> *str=<span class="literal">NULL</span>;</span><br><span class="line">　　GetMemory(&amp;str,<span class="number">100</span>);<span class="comment">//&amp;str是实参的地址，所以实参和形参之间就可以直接调用</span></span><br><span class="line">　　<span class="built_in">strcpy</span>(str,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">　　<span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-对C语言的加强"><a class="header-anchor" href="#C-对C语言的加强">¶</a>C++对C语言的加强</h2>
<h3 id="namespace命名空间"><a class="header-anchor" href="#namespace命名空间">¶</a>namespace命名空间</h3>
<h4 id="C-命名空间基本常识"><a class="header-anchor" href="#C-命名空间基本常识">¶</a>C++命名空间基本常识</h4>
<p>所谓namespace，是指<strong>标识符的各种可见范围</strong>。C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。</p>
<p>c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h</p>
<ol>
<li>当使用&lt;iostream.h&gt;时，相当于在c中调用库函数，使用的是全局命名空间，也就是早期的c++实现;</li>
<li>当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespace std;这样才能正确使用cout。</li>
<li>在程序开头使用<code>using namespace std;</code>，即可使命名空间std内定义的所有标识符都有效</li>
</ol>
<h4 id="与C的区别"><a class="header-anchor" href="#与C的区别">¶</a>与C的区别</h4>
<ol>
<li>C中的命名空间
<ul>
<li>在C语言中只有一个全局作用域</li>
<li>C语言中所有的全局标识符共享同一个作用域</li>
<li>标识符之间可能发生冲突</li>
</ul>
</li>
<li>C++中的命名空间
<ul>
<li>命名空间将全局作用域分成不同的部分</li>
<li>不同命名空间中的标识符可以同名而不会发生冲突</li>
<li>命名空间可以相互嵌套</li>
<li>全局作用域也叫默认命名空间</li>
</ul>
</li>
</ol>
<h4 id="在程序中使用命名空间"><a class="header-anchor" href="#在程序中使用命名空间">¶</a>在程序中使用命名空间</h4>
<ol>
<li>
<p>定义命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns1<span class="comment">//ns1为自定的命名空间名</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> RATE=<span class="number">0.08</span>; <span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line">　　doublepay;       <span class="comment">//变量(可带有初始化)</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">doubletax</span>()       <span class="comment">//函数(可以是定义或声明)</span></span><br><span class="line">    &#123;</span><br><span class="line">　　　　<span class="keyword">return</span> a*RATE;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　namespacens2   <span class="comment">//嵌套的命名空间</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="type">int</span> age;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用命名空间别名</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Television <span class="comment">//声明命名空间，名为Television</span></span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>可以用一个较短而易记的别名代替它。如：<br>
<code>namespace TV=Television;//别名TV与原名Television等价</code></p>
</li>
<li>
<p>使用using命名空间成员名<br>
<code>using nsl::Student</code><br>
在用上面的using声明后，在其后程序中出现的Student就是隐含地指nsl::Student</p>
</li>
</ol>
<h4 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h4>
<p>在程序中如果直接使用<code>using namespace std</code>可以减少在变量前添加<code>std::</code>的繁琐编程，但是另一方面在多文件编译时可能会导致不同文件中定义的任何标识符可能与std命名空间中的同名标识符冲突，因此可以考虑使用，<strong>若干个&quot;using命名空间成员”声明来代替“using namespace命名空间”声明</strong>，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br></pre></td></tr></table></figure>
<p>等。</p>
<h3 id="三目运算符"><a class="header-anchor" href="#三目运算符">¶</a>三目运算符</h3>
<ol>
<li>C语言返回变量的值 C<ins>语言是返回变量本身C语言中的三目运算符返回的是变量值，不能作为左值使用C</ins>中的三目运算符可直接返回变量本身，因此可以出现在程序的任何地方</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//返回一个最小数 并且给最小数赋值成30</span></span><br><span class="line">    <span class="comment">//三目运算符是一个表达式 ，表达式不可能做左值</span></span><br><span class="line">    (a &lt; b ? a : b ) = <span class="number">30</span>;<span class="comment">//在Cpp中是可行的，而C中是错误的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用<code>(a &lt; b ? 1 : b )= 30;</code></li>
</ol>
<h3 id="const增强"><a class="header-anchor" href="#const增强">¶</a>const增强</h3>
<p>外链<a href="https://www.cnblogs.com/jiabei521/p/3335676.html">C++中const关键字的使用方法总结</a></p>
<p>C++中的const修饰的，是一个真正的常量，而不是C中变量（<strong>只读</strong>）。在const修饰的常量编译期间，就已经确定下来了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C中</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)&amp;a;</span><br><span class="line">*p = <span class="number">11</span>;<span class="comment">//即可修改a中的值</span></span><br></pre></td></tr></table></figure>
<p>C++中的const常量类似于宏定义<br>
<code>const int c =5; 约等于 #define 5</code></p>
<p>C++中的const常量与宏定义不同<br>
const常量是由编译器处理的，提供类型检查和作用域检查。<br>
宏定义由预处理器处理，单纯的文本替换</p>
<h3 id="枚举"><a class="header-anchor" href="#枚举">¶</a>枚举</h3>
<p>c 语言中枚举本质就是整型,枚举变量可以用任意整型赋值。而c++中枚举变量,只能用被枚举出来的元素初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">season</span> &#123;SPR=<span class="number">1</span>,SUM,AUT,WIN&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">season</span> s = SPR;</span><br><span class="line">    <span class="comment">//s = 0; // error, 但是C语⾔言可以通过</span></span><br><span class="line">    s = SUM;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s = &quot;</span> &lt;&lt; s &lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用"><a class="header-anchor" href="#引用">¶</a>引用</h3>
<ul>
<li><a href="/2023/02/04/1cfe99df0026/">C 和 C++ 中引用</a></li>
</ul>
<!-- - <a href="#">Post not found: C和C++中引用</a> -->
<p>变量名，本身是一段内存的引用，即别名(alias)。引用可以看作一个<strong>已定义变量</strong>的别名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//c编译器分配4个字节内存, a内存空间的别名</span></span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">//b就是a的别名</span></span><br><span class="line">a = <span class="number">11</span>; <span class="comment">//直接赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">b = <span class="number">14</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt;a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<ol>
<li>引用没有定义,是一种关系型声明。声明它和原有某一变量(实体)的关系。故而类型与原类型保持一致,且不分配内存。与被引用的变量有相同的地址</li>
<li><strong>&amp;符号前有数据类型时,是引用。其它皆为取地址</strong></li>
<li>声明的时候必须初始化,一经声明,不可变更</li>
<li>可对引用,再次引用。多次引用的结果,是某一变量具有多个别名</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> &amp;r = a;</span><br><span class="line"><span class="type">int</span> &amp;r = b; <span class="comment">//错误,不可更改原有的引⽤关系</span></span><br><span class="line"><span class="type">float</span> &amp;rr = b; <span class="comment">//错误,引⽤类型不匹配 cout&lt;&lt;&amp;a&lt;&lt;&amp;r&lt;&lt;endl; //变量与引⽤具有相同的地址。</span></span><br><span class="line"><span class="type">int</span> &amp;ra = r; <span class="comment">//可对引⽤更次引用,表⽰ a 变量有两个别名,分别是 r 和 ra</span></span><br></pre></td></tr></table></figure>
<h4 id="引用的意义"><a class="header-anchor" href="#引用的意义">¶</a>引用的意义</h4>
<ol>
<li>引用作为其它变量的别名而存在，因此在一些场合可以代替指针</li>
<li>引用相对于指针来说具有更好的可读性和实用性</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; <span class="comment">//无法实现两数据的交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> *q)</span></span>; <span class="comment">//开辟了两个指针空间实现交换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    tmp = a; a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>,b = <span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;b = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;b = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引用的本质"><a class="header-anchor" href="#引用的本质">¶</a>引用的本质</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b = a; <span class="comment">// 注意： 单独定义的引用时，必须初始化。</span></span><br><span class="line">    b = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:%d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b:%d\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a:%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;b:%p\n&quot;</span>, &amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:<span class="number">11</span></span><br><span class="line">b:<span class="number">11</span></span><br><span class="line">&amp;a:<span class="number">000000000061</span>fe14</span><br><span class="line">&amp;b:<span class="number">000000000061</span>fe14</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>可见得Cpp编译器在定义引用时是将两个变量名指向同一个内存地址：引用在C++中的内部实现是一个常指针<br>
<code>Type&amp; name &lt;===&gt; Type* const name</code></p>
</li>
<li>
<p>C++编译器在编译过程中使用常指针作为引用的内部实现，<strong>因此引用所占用的空间大小与指针相同</strong></p>
</li>
<li>
<p>从使用的角度，引用会让人误会其只是一个别名，没有自己的存储空间。这是C++为了实用性而做出的细节隐藏。</p>
</li>
</ol>
<p>间接赋值的三个必要条件</p>
<ol>
<li>定义两个变量 （一个实参一个形参）</li>
<li>建立关联 实参取地址传给形参</li>
<li>*p形参去间接的修改实参的值</li>
</ol>
<p><strong>引用在实现上，只不过是把：间接赋值成立的三个条件的后两步和二为一</strong><br>
当实参传给形参引用的时候，只不过是c++编译器帮我们程序员手工取了一个实参地址，传给了形参引用（常量指针）。</p>
<h4 id="引用作为函数的返回值（引用当左值）"><a class="header-anchor" href="#引用作为函数的返回值（引用当左值）">¶</a>引用作为函数的返回值（引用当左值）</h4>
<ol>
<li>当函数返回值为引用时,若返回栈变量:不能成为其它引用的初始值（不能作为右值使用）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getA1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getA2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将⼀一个引⽤用赋给另⼀一个引⽤用作为初始值，由于是栈的引⽤用，内存⾮非法</span></span><br><span class="line"><span class="type">int</span> &amp;a3 = <span class="built_in">getA2</span>();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>当函数返回值为引用时,若返回静态变量或全局变量可以成为其他引用的初始值（可作为右值使用，也可作为左值使用）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getA2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将⼀一个引⽤用赋给另⼀一个引⽤用作为初始值，由于是静态区域，内存合法</span></span><br><span class="line"><span class="type">int</span> &amp;a3 = <span class="built_in">getA2</span>();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>引用作为函数返回值，如果返回值为引用可以当左值，如果返回值为普通变量不可以当左值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数当左值</span></span><br><span class="line"><span class="comment">//返回变量的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回变量本⾝</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数当右值</span></span><br><span class="line">    <span class="type">int</span> c1 = <span class="built_in">func1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1 = &quot;</span> &lt;&lt; c1 &lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> c2 = <span class="built_in">func2</span>(); <span class="comment">//函数返回值是一个引⽤,并且当右值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c2 = &quot;</span> &lt;&lt; c2 &lt;&lt;endl;</span><br><span class="line">    <span class="comment">//函数当左值</span></span><br><span class="line">    <span class="comment">//func1() = 100; //error</span></span><br><span class="line">    <span class="built_in">func2</span>() = <span class="number">100</span>; <span class="comment">//函数返回值是一个引用,并且当左值</span></span><br><span class="line">    c2 = <span class="built_in">func2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c2 = &quot;</span> &lt;&lt; c2 &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="指针引用"><a class="header-anchor" href="#指针引用">¶</a>指针引用</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> age ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在被调用函数 获取资源</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTeacher</span><span class="params">(Teacher **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Teacher *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    tmp = (Teacher*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Teacher));</span><br><span class="line">    tmp-&gt;age = <span class="number">33</span>;</span><br><span class="line">    <span class="comment">// p是实参的地址 *实参的地址 去间接的修改实参的值</span></span><br><span class="line">    *p = tmp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针的引用 做函数参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTeacher2</span><span class="params">(Teacher* &amp;myp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 给myp赋值 相当于给main函数中的pT1赋值</span></span><br><span class="line">    myp = (Teacher *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Teacher));</span><br><span class="line">    <span class="keyword">if</span> (myp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myp-&gt;age = <span class="number">36</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FreeTeacher</span><span class="params">(Teacher *pT1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pT1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Teacher *pT1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 1 c语⾔言中的二级指针</span></span><br><span class="line">    <span class="built_in">getTeacher</span>(&amp;pT1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; pT1 -&gt; age &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">FreeTeacher</span>(pT1);</span><br><span class="line">    <span class="comment">// 2 c++中的引用（指针的引用）</span></span><br><span class="line">    <span class="comment">// 引用的本质间接赋值后2个条件，让c++编译器帮我们程序员做了。</span></span><br><span class="line">    <span class="built_in">getTeacher2</span>(pT1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; pT1 -&gt; age &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">FreeTeacher</span>(pT1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="const-引用"><a class="header-anchor" href="#const-引用">¶</a>const 引用</h4>
<p>const引用，它可以防止对象的值被随意修改。具有一些特性。</p>
<ol>
<li><strong>const对象的引用必须是const的,将普通引用绑定到const对象是不合法的</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;<span class="comment">//这是不合法的</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>const引用可使用相关类型的对象(常量,非同类型的变量或表达式)初始化</strong>。这个是const引用与普通引用最大的区别。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下语句是合法的</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = <span class="number">2</span>;</span><br><span class="line"><span class="type">double</span> x =<span class="number">3.1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b =a;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通引用</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常引用</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;y = x; <span class="comment">//常引用是限制变量为只读不能通过y去修改x了</span></span><br><span class="line"><span class="comment">//y = 21; //error</span></span><br></pre></td></tr></table></figure>
<h4 id="const-引用的原理"><a class="header-anchor" href="#const-引用的原理">¶</a>const 引用的原理</h4>
<p>const引用是指向const对象的引用：<br>
通过ref2对ival赋值会导致修改const对象的值，为防止这样的修改，需要规定将普通的引用绑定到const对象是不合法的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ival =<span class="number">1024</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;refVal = ival; <span class="comment">//两者均为const对象</span></span><br><span class="line">    <span class="type">int</span> &amp;ref2 = ival; <span class="comment">//error！不能使用非const引用指向const变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> val =<span class="number">3.14</span>;</span><br><span class="line">    <span class="comment">// double *ref = &amp;val;</span></span><br><span class="line">    <span class="comment">// const double&amp; ref = val;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; ref = val;</span><br><span class="line">    <span class="comment">// int&amp; refi = vali; //error</span></span><br><span class="line">    <span class="type">double</span> &amp; ref2 = val;</span><br><span class="line">    cout &lt;&lt; ref &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ref2 &lt;&lt;endl;</span><br><span class="line">    val = <span class="number">5.22</span>;</span><br><span class="line">    cout &lt;&lt; ref &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ref2 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样的初始化对于非const引用却是不合法的，而且会导致编译时错误，观察将引用绑定到不同的类型时所发生的事情，最容易理解上述行为。对于以下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器会将这些代码转换为以下形式</span></span><br><span class="line"><span class="type">int</span> temp = dval;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure>
<p>可以发现对于将引用绑定到不同类型时，编译器会创建一个int型的暂时变量存储dval，然后将ri绑定到temp上</p>
<p><strong>(Tips:引用在内部存放的是一个对象的地址，它是该对象的别名。对于不可寻址的值，如文字常量，以及不同类型的对象，编译器为了实现引用，必须生成一个临时对象，引用实际上指向该对象，但用户不能访问它。)</strong></p>
<ul>
<li><strong>结论</strong>
<ol>
<li><code>const int &amp; e</code> 相当于 <code>const int * const e</code></li>
<li>普通引用 相当于 <code>int *const e</code></li>
<li>当使用常量（字面量）对const引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为这段空间的别名</li>
<li>使用字面量对const引用初始化后，将生成一个只读变量</li>
</ol>
</li>
</ul>
<h3 id="inline内联函数"><a class="header-anchor" href="#inline内联函数">¶</a>inline内联函数</h3>
<p>类似于C语言中宏函数，但是C中的宏函数处理发生在预处理阶段，没有语法检测。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //编译器将内联函数的函数体直接展开</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    a = 20;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; a &lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>特点：</p>
<ol>
<li>内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求。</li>
<li>C++编译器直接将函数体插入在函数调用的地方。</li>
<li>内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)。</li>
<li>内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型等）。</li>
<li>内联函数由编译器处理，直接将编译后的函数体插入调用的地方，宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程。</li>
<li>C++的内联编译应该不包含循环、过多的条件判断、不宜实现太过复杂的的功能。</li>
<li>内联函数相对于普通函数的优势只是<strong>省去了函数调用时压栈，跳转和返回的开销</strong>。因此，<strong>当函数体的执行开销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。</strong></li>
</ol>
</li>
<li>
<p>总结：</p>
<ul>
<li>本质:以牺牲代码段空间为代价,提高程序的运行时间的效率。</li>
<li>适用场景:函数体很“小”,且被“频繁”调用</li>
</ul>
</li>
</ol>
<h3 id="函数默认参数"><a class="header-anchor" href="#函数默认参数">¶</a>函数默认参数</h3>
<h4 id="单个默认参数"><a class="header-anchor" href="#单个默认参数">¶</a>单个默认参数</h4>
<p>对于多次调用一函数同一实参时,C++给出了更简单的处理办法。给形参以默认值,这样就不用从实参那里取值了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 若你填写参数,使⽤用你填写的,不填写默认</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> x = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;x: &quot;</span>&lt;&lt;x&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多个默认参数"><a class="header-anchor" href="#多个默认参数">¶</a>多个默认参数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2 在默认参数规则 ，如果默认参数出现，那么右边的都必须有默认参数</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">volume</span><span class="params">(<span class="type">float</span> length, <span class="type">float</span> weight = <span class="number">4</span>,<span class="type">float</span> high = <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length*weight*high;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> v = <span class="built_in">volume</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">float</span> v1 = <span class="built_in">volume</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">float</span> v2 = <span class="built_in">volume</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    cout&lt;&lt;v&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;v1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;v2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="占位参数"><a class="header-anchor" href="#占位参数">¶</a>占位参数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数占位参数</span></span><br><span class="line"><span class="comment">占位参数只有参数类型声明，⽽而没有参数名声明</span></span><br><span class="line"><span class="comment">⼀一般情况下，在函数体内部⽆无法使⽤用占位参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//error,必须把最后一个占位参数补上</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以将占位参数与默认参数结合起来使用</span></span><br><span class="line"><span class="comment">意义:为以后程序的扩展留下线索兼容C语⾔言程序中可能出现的不规范写法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++可以声明占位符参数，占位符参数⼀一般⽤用于程序扩展和对C代码的兼容</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果默认参数和占位参数在一起，都能调用起来</span></span><br><span class="line">    <span class="built_in">func2</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">func2</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载"><a class="header-anchor" href="#函数重载">¶</a>函数重载</h3>
<h4 id="规则-类似Java"><a class="header-anchor" href="#规则-类似Java">¶</a>规则(类似Java)</h4>
<ol>
<li>函数名相同。</li>
<li>参数个数不同,参数的类型不同,参数顺序不同,均可构成重载。</li>
<li>返回值类型不同则不可以构成重载。</li>
<li>一个函数,不能既作重载,又作默认参数的函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c = <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//error. 存在二义性，调用失败，编译不能通过</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-基本"><a class="header-anchor" href="#C-基本">¶</a>C++基本</h2>
<h3 id="头文件保护"><a class="header-anchor" href="#头文件保护">¶</a>头文件保护</h3>
<h4 id="引出：重复定义问题"><a class="header-anchor" href="#引出：重复定义问题">¶</a>引出：<strong>重复定义问题</strong></h4>
<p>考虑以下示例：<br>
<strong>File_1.h</strong>头文件包含以下内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>File_2.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;File_1.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;File_1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;File_2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个看似正常的程序<strong>无法编译</strong>！下面是所发生的事情。首先，main.cpp包含File_1.h，它将函数getNumber的定义复制到main.cpp中。然后，main.cpp包含File_2.h，间接包含File_1.h。这会将File_1.h的内容（包括函数getNumber的定义）复制到File_2.h中，然后将其复制到main.cpp中。</p>
<p>因此，在解析所有#include之后，main.cpp最终如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNumber</span><span class="params">()</span> <span class="comment">//from File_1.h</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNumber</span><span class="params">()</span> <span class="comment">//from File_2.h</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="头文件保护-v2"><a class="header-anchor" href="#头文件保护-v2">¶</a>头文件保护</h4>
<p>我们可以通过一种称为头文件保护（也称为包含保护）的机制来避免上述问题。头文件保护是采用以下形式的条件编译指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//但根据惯例，它被设置为头文件的完整文件名，以大写字母键入，使用下划线表示空格或标点</span></span><br><span class="line"><span class="comment">//例如：square.h将被表示为：SQUARE_H    </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOME_UNIQUE_NAME_HERE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOME_UNIQUE_NAME_HERE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里放置你的声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="基本调试策略"><a class="header-anchor" href="#基本调试策略">¶</a>基本调试策略</h3>
<ol>
<li>注释代码</li>
<li>验证代码流程<br>
在需要验证的代码前添加调试输出语句。<br>
打印用于调试的信息时，请使用<code>std::cerr</code>而不是<code>std:∶cout</code>。因为，std::cout可能有缓冲区而std::cerr没有缓冲，这意味着您发送给它的任何内容都将立即输出</li>
<li>条件化调试代码<br>
在引入调试代码后，完成调试后，您要么需要删除它们，要么将它们注释掉。如果以后需要它们，则必须重新添加它们，或取消注释它们。非常麻烦且容易扰乱正常的代码功能。<br>
使用预处理指令，可以很容易的在整个程序中启用或禁用调试语句<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_DEBUG <span class="comment">// 注释掉这一行，可以禁用掉调试输出</span></span></span><br><span class="line"><span class="comment">//如果这是一个多文件程序，#define ENABLE_DEBUG 将放在头文件中，被所有用到的地方引用，方便我们可以在单个位置注释/取消注释#define，并将其传播到所有代码文件。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> ENABLE_DEBUG</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;getUserInput() called\n&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    <span class="type">int</span> x&#123;&#125;;</span><br><span class="line">    std::cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> ENABLE_DEBUG</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;main() called\n&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> x&#123; <span class="built_in">getUserInput</span>() &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>使用日志记录器（Logger）<br>
现代常用的调试和错误记录方式，具体内容可以在网络上学习</li>
</ol>
<h3 id=""><a class="header-anchor" href="#">¶</a></h3>
<p>每当您看到使用尖括号（&lt;&gt;）的C<ins>语法（不包括预处理器）时，尖括号之间的东西很可能是类型。这通常是C</ins>处理需要参数化类型的代码的方式。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C和C++中引用</title>
    <url>/2023/02/04/1cfe99df0026/</url>
    <content><![CDATA[<h2 id="C的指针和C-中引用和函数参数类型"><a class="header-anchor" href="#C的指针和C-中引用和函数参数类型">¶</a>C的指针和C++中引用和函数参数类型</h2>
<span id="more"></span>
<p>如果你说的是函数的形参，那么</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> ptr)</span>;</span><br><span class="line"></span><br><span class="line">是传值调用，比如你这么调用</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> pValue = &amp;a;</span><br><span class="line">foo(pValue);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">这样的情况下，pValue的值是不能被函数foo改变的，也就是pValue肯定是指向a的</span><br><span class="line">但是如果你这么声明：</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>&amp; ptr)</span>;</span><br><span class="line">则是传递引用，那么如果你函数里面：</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>&amp; ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    ptr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">这样调用过之后，pValue就变成了<span class="literal">NULL</span>。而第一种情况pValue是不能被改变的。</span><br><span class="line">引用是C++带来的很重要一个特性，他在很多情况下避免了使用指针。</span><br><span class="line">而且，在C++里面，引用是不可以捏造的，比如C你可以很容易弄一个<span class="literal">NULL</span>的指针，而引用这不存在<span class="literal">NULL</span>引用。</span><br><span class="line">上面的foo函数如果要用C来实现，则必须用指针的指针：</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> pptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    ptr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用的时候要</span><br><span class="line">foo(&amp;pValue)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">这种技术很多用在比如定义一个安全删除指针的函数，所谓安全就是，</span><br><span class="line">只有当指针为零的时候才执行删除，删除之后，立刻把指针赋值为<span class="literal">NULL</span>。</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="title function_">safe_delete</span><span class="params">(T&amp; ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        delete ptr;</span><br><span class="line">        ptr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过下面代码可以更清楚理解两者区别</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span>* px = &amp;x;  <span class="comment">// px是指向x的指针</span></span><br><span class="line">    <span class="type">int</span>** ppx = &amp;px;  <span class="comment">// ppx是指向指针px的指针</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;x: &quot;</span> &lt;&lt; &amp;x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;px: &quot;</span> &lt;&lt; px &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*px: &quot;</span> &lt;&lt; *px &lt;&lt; std::endl;  <span class="comment">// 解引用指针px，获取x的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;**ppx: &quot;</span> &lt;&lt; **ppx &lt;&lt; std::endl;  <span class="comment">// 解引用指向指针px的指针，获取x的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; rx = x;  <span class="comment">// rx是x的引用</span></span><br><span class="line">    <span class="type">int</span>* prx = &amp;rx;  <span class="comment">// prx是指向引用rx的指针</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rx: &quot;</span> &lt;&lt; rx &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*prx: &quot;</span> &lt;&lt; *prx &lt;&lt; std::endl;  <span class="comment">// 解引用指针prx，获取rx的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;*prx: &quot;</span> &lt;&lt; &amp;*prx &lt;&lt; std::endl;  <span class="comment">// 获取指针prx的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在C++里面，能不用指针都应该尽量避免，STL里面就大量使用引用。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>IEEE浮点表示(IEEE 754)</title>
    <url>/2022/09/12/240736e386b5/</url>
    <content><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2>
<p>浮点数是我们在程序里常用的数据类型，它在内存中到底是怎么样的形式存在的呢？</p>
<p>现代计算机中，一般都以IEEE 754标准存储浮点数，IEEE标准用: V=(-1)^s x M x 2^E 来表示一个浮点数</p>
<span id="more"></span>
<ul>
<li>符号: s决定这个数是正数还是负数</li>
<li>尾数: M是一个二进制小数</li>
<li>阶码: E是对浮点数进行加权，权重是2的E次幂</li>
</ul>
<table>
    <tr>    <th>符号</th>   <th>阶码</th>       <th>尾数</th> </tr>
    <tr>
            <td>sign</td>   <td>exponent</td>   <td>fraction</td>
    </tr>
</table>
<p>对于不同长度的浮点数，阶码与小数位分配的数量不一样，如下：</p>
<table>
    <tr> <th>精度</th>   <th>数符</th>   <th>阶码</th>   <th>尾数</th> <th>总位数</th> <th>偏移值</th></tr>
    <tr>
        <th>单精度(C中的float)</th>  <td>1</td>   <td>8</td>   <td>23</td>   <td>32</td>   <td>127</td>
    </tr>
    <tr>
        <th>双精度(C中的double)</th>  <td>1</td>   <td>11</td>   <td>52</td>   <td>64</td>   <td>1023</td>
    </tr>
</table>
<p>对于32位的单精度浮点数，数符分配是1位，阶码分配了8位，尾数分配了是23位。</p>
<p>根据这个标准，我们来尝试把一个十进制的浮点数转换为IEEE 754标准表示。</p>
<h2 id="规格化的值"><a class="header-anchor" href="#规格化的值">¶</a>规格化的值</h2>
<p>最普遍的情况，当exp的位模式不全为0（数值0），也不全为1（单精度255，双精度2047）<br>
例如：178.125</p>
<ol>
<li>
<p>先把浮点数分别把整数部分和小数部分转换成2进制</p>
<ol>
<li>
<p>整数部分用除2取余的方法，求得：10110010</p>
</li>
<li>
<p>小数部分用<a href="#%E4%B9%982%E5%8F%96%E6%95%B4%E6%B3%95">乘2取整</a>的方法，求得：001</p>
</li>
<li>
<p>合起来即是：10110010.001</p>
</li>
<li>
<p>转换成二进制的浮点数，即把小数点移动到整数位只有1，即为：1.0110010001 * 2^111，111是二进制，由于左移了7位，所以是111</p>
</li>
</ol>
</li>
<li>
<p>把浮点数转换二进制后，这里基本已经可以得出对应3部分的值了</p>
<ol>
<li>
<p>数符：由于浮点数是正数，故为0.(负数为1)</p>
</li>
<li>
<p>阶码 : 阶码的计算公式：阶数 + 偏移量， 阶码是需要作移码运算，在转换出来的二进制数里，阶数是111(十进制为7)，对于单精度的浮点数，偏移值为01111111(127)[偏移量的计算是：2^(e-1)-1， e为阶码的位数，即为8，因此偏移值是127]，即：111+01111111 = 10000110</p>
</li>
<li>
<p>尾数：小数点后面的数，即0110010001</p>
</li>
<li>
<p>最终根据位置填到对位的位置上：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">数符</th>
<th style="text-align:center">阶码</th>
<th style="text-align:center">尾数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1 0 0 0 0 1 1 0</td>
<td style="text-align:center">0 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>阶码与尾数之间隐含小数点</p>
</blockquote>
</li>
</ol>
<p>可能有个疑问：小数点前面的1去哪里了？由于尾数部分是规格化表示的，最高位总是“1”<br>
我们将尾数定义为M=1+f，小数字段被描述为小数值f，其中0&lt;=f&lt;1，其二进制表示为：<br>
<img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/IEEE%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA.5ehdoqm3j6s.gif" alt="IEEE浮点表示"><br>
也就是二进制小数点在最高有效位的左边。<br>
我们也可以把M看成一个二进制表达式为下图的数字，也总能调整阶码使得尾数M的范围在1到2之间。<br>
<img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/IEEE%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA_2.2g2up3og3j9c.gif" alt="IEEE浮点表示_2"></p>
<p>既然第一位总是1，那就可以直接隐藏不需要显示出来，同时也能够获得一个额外的精度位。</p>
<h3 id="非规格化的值"><a class="header-anchor" href="#非规格化的值">¶</a>非规格化的值</h3>
<p>当阶码全为0时，所表示的数<em>非规格化</em>的形式。这种情况下，阶码的值是1-Bias，尾数M=f，也就是小数字段的值，不包含隐含开头的1。<br>
非规格化有两个用途：</p>
<ul>
<li>一是提供一种表示数值0的方法，因为使用规格化的数我们必须使M&gt;=1，无法表示0。</li>
<li>二是表示那些非常接近0的数。</li>
</ul>
<hr>
<h2 id="拓展"><a class="header-anchor" href="#拓展">¶</a>拓展</h2>
<h3 id="乘2取整法"><a class="header-anchor" href="#乘2取整法">¶</a>乘2取整法</h3>
<p>考虑一个十进制小数0.123，我们可以用“乘10取整”法得到它的每一位小数：第一位小数是0.123 *10=1.23，取整数1；第二位小数：0.23 *10=2.3，取整数2</p>
<p>上面的方法供你直观理解，下面我们从数学的角度分析其中的原理。</p>
<p>现在有一个十进制小数为0.625，要把它转换为二进制小数，我们需要找到它的每一位。记这个二进制小数点后第1位是$a_1$，第二位是$a_2$，……，那么这个小数的值就是$ a_1 \ast {\frac{1}{2}}^{-1}+a_2 \ast {\frac{1}{2}}^{-2}+a_3 \ast {\frac{1}{2}}^{-3}+… $ 。现在我们的目标是根据0.625找到对应的$ a_1，a_2，a_3$ ，…使得$ 0.625=a_1 \ast {\frac{1}{2}}^{-1}+a_2 \ast {\frac{1}{2}}^{-2}+a_3 \ast {\frac{1}{2}}^{-3}+… $</p>
<p>在等式两边同时乘以2，得到$1.25=a_1 \ast {\frac{1}{2}}^{0}+a_2 \ast {\frac{1}{2}}^{-1}+a_3 \ast {\frac{1}{2}}^{-2}+…$</p>
<p>我们发现，左边的整数部分1对应右边的$a_1$，也就是二进制小数的第一位，于是$a_1=1$，对于剩下的部分：</p>
<p>$0.25=a_2 \ast {\frac{1}{2}}^{-1}+a_3 \ast {\frac{1}{2}}^{-2}+…$</p>
<p>我们再次乘以2，得到$0.5=a_2 \ast {\frac{1}{2}}^{0}+a_3 \ast {\frac{1}{2}}^{-1}+… $于是$a_2=0$</p>
<p>再乘以2，得到$1=a_3 \ast {\frac{1}{2}}^{0}+…$， 于是$a_3=1$，到这里，所有的数都消耗完了，我们找到了0.625对应的二进制小数：0.101</p>
<p>参考文章:<a href="https://zhuanlan.zhihu.com/p/144697348">浮点数的二进制表示(IEEE 754标准)</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>IEEE，浮点数</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode配置C语言环境</title>
    <url>/2024/12/15/74efb82ee616/</url>
    <content><![CDATA[<p>VsCode只是一个纯文本<strong>编辑器</strong>，不是IDE(集成开发环境)，不含<strong>编译器</strong>和许多其它功能，所以编译器要自己装好</p>
<p>第一步：在vscode官网下载软件，链接：<a href="https://code.visualstudio.com/"></a><a href="https://code.visualstudio.com/">Visual Studio Code – Code Editing. Redefined</a></p>
<p>第二步：我们需要下载一个编译器，C语言使用gcc，链接：<a href="https://sourceforge.net/projects/mingw-w64/">MinGW-w64 – for 32 and 64 bit Windows download | SourceForge.net</a>，选最新版本中的 x86_64-posix-seh 即可，网站下载可能较慢，下面给出百度网盘链接</p>
<p>（百度网盘链接：链接: <a href="https://pan.baidu.com/s/17FYT_Y-s-I2yajFc2MICqw">https://pan.baidu.com/s/17FYT_Y-s-I2yajFc2MICqw</a> 提取码: ewis ）</p>
<p>第三步：将E:\mingw64\bin 添加到系统变量中（盘符根据自己编译器安装的位置）</p>
<p>以Win11为例：打开设置-&gt;系统-&gt;关于-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;点击Path-&gt;编辑 -&gt; 浏览 -&gt; 把对应文件加入即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E9%85%8D%E7%BD%AEC%E8%AF%AD%E8%A8%80_2.1kpkhe2uoc2o.jpg" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E9%85%8D%E7%BD%AEC%E8%AF%AD%E8%A8%80_3.1zghj049j51c.jpg" alt=""></p>
<p>第四步：</p>
<p>按Win+R，运行cmd（不要跳这一步），输入gcc，应该会提示 <em>no input files</em> 而不是“不是内部命令或外部命令”或者“无法将 “gcc” 项识别为 cmdlet、函数、脚本文件或可运行程序的名称”。如果是“不是内部命令或外部命令”，说明gcc在的文件夹没有在环境变量的Path中，要加进去才行。如果加了还是这样，重启（不要忘记重启）。如果重启了还不行，那就是你自己进行的操作有问题。</p>
<p>输gcc -v可以显示出gcc的版本。如果显示出来的版本与你刚下的<strong>不同/更老</strong>，说明Path里原本有老版本的编译器，可能是安装其它IDE时装上的。则需要去掉Path里原来的那一个gcc的路径。</p>
<p>这两项验证<strong>一定要符合</strong>，否则必须修改环境变量。小心<strong>别错删</strong>了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E9%85%8D%E7%BD%AEC%E8%AF%AD%E8%A8%80_4.2cndmw8ru0kk.jpg" alt=""></p>
<p>第五步：现在打开vscode，下载相关插件</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E9%85%8D%E7%BD%AEC%E8%AF%AD%E8%A8%80_5.14p5s9c8oocg.jpg" alt=""></p>
<p>第六步：我们需要写两个json文件，下面依次是launch.json和tasks.json（两个文件名也必须是 launch.json 和 tasks.json ） <strong><span class="has-inline-color" style="color:#ff0000">注意看代码注释，两个文件都有几处地方需要将路径改为自己编译器的路径</span></strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc.exe - 生成和调试活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\bin\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span><span class="comment">//这里意思生成的二进制代码会放入当前文件的bin文件夹中，我们需要自己新建一个bin文件夹</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:\\mingw64\\bin\\gcc.exe&quot;</span><span class="punctuation">,</span><span class="comment">//改成自己的文件路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="comment">/*&quot;$&#123;fileDirname&#125;\\*.c&quot;,</span></span><br><span class="line"><span class="comment">                &quot;-o&quot;,</span></span><br><span class="line"><span class="comment">                &quot;$&#123;fileDirname&#125;\\bin\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span></span><br><span class="line"><span class="comment">                &quot;-g&quot;//多文件编译*/</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\bin\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="comment">//这里意思生成的二进制代码会放入当前文件的bin文件夹中，我们需要自己新建一个bin文件夹</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;echo&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;reveal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span><span class="punctuation">,</span> <span class="comment">// 执行任务时是否跳转到终端面板，可以为always，silent，never。具体参见VSC的文档</span></span><br><span class="line">                <span class="attr">&quot;focus&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>     <span class="comment">// 设为true后可以使执行task时焦点聚集在终端，但对编译C/C++来说，设为true没有意义</span></span><br><span class="line">                <span class="attr">&quot;panel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shared&quot;</span>   <span class="comment">// 不同的文件的编译信息共享一个终端面板</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(多文件)gcc.exe - 生成和调试活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:\\mingw64\\bin\\gcc.exe&quot;</span><span class="punctuation">,</span><span class="comment">//改成自己的文件路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\*.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\bin\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span><span class="comment">//这里意思生成的二进制代码会放入当前文件的bin文件夹中，我们需要自己新建一个bin文件夹</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;echo&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;reveal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span><span class="punctuation">,</span> <span class="comment">// 执行任务时是否跳转到终端面板，可以为always，silent，never。具体参见VSC的文档</span></span><br><span class="line">                <span class="attr">&quot;focus&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>     <span class="comment">// 设为true后可以使执行task时焦点聚集在终端，但对编译C/C++来说，设为true没有意义</span></span><br><span class="line">                <span class="attr">&quot;panel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shared&quot;</span>   <span class="comment">// 不同的文件的编译信息共享一个终端面板</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此设置工作基本结束</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>编程环境配置</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>配置环境</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode配置Java环境</title>
    <url>/2022/09/07/1dee5f1e014f/</url>
    <content><![CDATA[<h2 id="安装Java"><a class="header-anchor" href="#安装Java">¶</a>安装Java</h2>
<p>安装最新版(最新版VsCode安装jdk1.8会弹窗警告，所以不如使用最新版)<br>
下载地址：<a href="https://www.oracle.com/java/technologies/downloads/#jdk18-windows">Java</a></p>
<span id="more"></span>
<blockquote>
<p>Tips: 如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。<br>
有关两者关系也可以查看<a href="https://docs.oracle.com/javase/8/docs/">官方文档</a></p>
</blockquote>
<p>选择对应系统的版本即可：</p>
<ul>
<li>
<p>Compressed Archive版本是单独的JDK包</p>
</li>
<li>
<p>Installer版本是Java安装包，包含了Java运行程序，<strong>第一次配置Java环境</strong>最好下载这个</p>
</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/VsCode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83_1.5qa2mqoltac0.jpg" alt="VsCode配置Java环境_1"></p>
<h2 id="配置Java环境变量"><a class="header-anchor" href="#配置Java环境变量">¶</a>配置Java环境变量</h2>
<h3 id="1-打开系统环境变量"><a class="header-anchor" href="#1-打开系统环境变量">¶</a>1. 打开系统环境变量</h3>
<ul>
<li>方法1：选中我的电脑 --&gt; 键盘按下 Alt + Enter --&gt; 高级系统设置 --&gt; 环境变量</li>
<li>方法2：键盘按下 win + r --&gt; 输入 sysdm.cpl --&gt; 高级 --&gt; 环境变量</li>
<li>方法3：win10系统下，工具栏有搜索图标，点击后直接搜索&quot;环境变量&quot;</li>
</ul>
<h3 id="2-设置环境变量"><a class="header-anchor" href="#2-设置环境变量">¶</a>2. 设置环境变量</h3>
<p>在 “系统变量” 中设置 3 项属性，JAVA_HOME、PATH、CLASSPATH(大小写无所谓),若已存在则点击&quot;编辑&quot;，不存在则点击&quot;新建&quot;。</p>
<p>变量设置参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量名：JAVA_HOME</span><br><span class="line">变量值：C:\Program Files (x86)\Java\jdk1.8.0_91        // 要根据自己的实际路径配置</span><br><span class="line">变量名：CLASSPATH</span><br><span class="line">变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;         //记得前面有个&quot;.&quot;</span><br><span class="line">变量名：Path</span><br><span class="line">变量值：%JAVA_HOME%\bin;        //如果安装了jre需要添加个%JAVA_HOME%\jre\bin; </span><br></pre></td></tr></table></figure>
<h3 id="3-测试是否配置成功"><a class="header-anchor" href="#3-测试是否配置成功">¶</a>3. 测试是否配置成功</h3>
<pre><code>1. &quot;Win+R&quot;，键入&quot;cmd&quot;；

2. 键入命令: java -version、java、javac 几个命令，出现以下信息，说明环境变量配置成功
</code></pre>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/VsCode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83_2.293km1aifvms.jpg" alt="VsCode配置Java环境_2"></p>
<h2 id="Vscode配置"><a class="header-anchor" href="#Vscode配置">¶</a>Vscode配置</h2>
<ol>
<li>下载对应Java插件<br>
这里使用Extension Pack for Java 里面包含6个可能会用的到插件(Java11以下版本的jdk会弹出警告)</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/VsCode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83_3.77spuvqtj1w0.jpg" alt="VsCode配置Java环境_3"></p>
<ol start="2">
<li>设置java路径<br>
打开vscode设置（Ctrl + ，） --&gt;  搜索设置输入 javahome --&gt;  点击 Java: Home下的在settings.json中编辑，如下：<br>
其中，第一行是JAVA_HOME的路径，记得把 &quot; \ &quot; 改成 &quot; \ \ &quot;</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/VsCode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83_4.3dmm1dj8fnq0.jpg" alt="VsCode配置Java环境_4"></p>
<h2 id="调试运行"><a class="header-anchor" href="#调试运行">¶</a>调试运行</h2>
<p>新建<code>hello.java</code>，输入代码，测试运行即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hello.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;I am Hello Class, which is a main class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章：<br>
<a href="https://www.cnblogs.com/bpf-1024/p/13375253.html">Visual Studio Code (vscode) 配置 Java 环境 </a></p>
<p><a href="https://www.runoob.com/java/java-environment-setup.html">Java 开发环境配置</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>编程环境配置</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>配置环境</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git上传文件至Github</title>
    <url>/2022/08/03/0b5e2db181ab/</url>
    <content><![CDATA[<p>最近经常要使用Github保存我学习过程中的代码，发现无法直接上传文件夹，遂在网上查了一下使用Git上传，所以写个博文记录一下</p>
<span id="more"></span>
<h2 id="Github端操作"><a class="header-anchor" href="#Github端操作">¶</a>Github端操作</h2>
<h3 id="1-复制仓库地址"><a class="header-anchor" href="#1-复制仓库地址">¶</a>1. 复制仓库地址</h3>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E4%BD%BF%E7%94%A8Git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%87%B3Github_1.3syztscmys80.jpg" alt="使用Git上传文件至Github_1"></p>
<h2 id="本地端操作"><a class="header-anchor" href="#本地端操作">¶</a>本地端操作</h2>
<h3 id="1-在本地新建一个空文件夹"><a class="header-anchor" href="#1-在本地新建一个空文件夹">¶</a>1. 在本地新建一个空文件夹</h3>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E4%BD%BF%E7%94%A8Git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%87%B3Github_2.5nufudqca7w0.jpg" alt="使用Git上传文件至Github_2"></p>
<center style="font-size:16px;color:#FFFFF">我这里已经clone完成</center>
<h3 id="2-在文件夹内呼出Git-Bash框"><a class="header-anchor" href="#2-在文件夹内呼出Git-Bash框">¶</a>2. 在文件夹内呼出Git Bash框</h3>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E4%BD%BF%E7%94%A8Git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%87%B3Github_3.5l2lii1fkd80.jpg" alt="使用Git上传文件至Github_3"></p>
<h3 id="3-Clone远程仓库"><a class="header-anchor" href="#3-Clone远程仓库">¶</a>3. Clone远程仓库</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> + 你的仓库地址</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hiyoung3937/study_code.git  //示例</span><br></pre></td></tr></table></figure>
<h3 id="4-直接将需要上传的文件拖入即可"><a class="header-anchor" href="#4-直接将需要上传的文件拖入即可">¶</a>4. 直接将需要上传的文件拖入即可</h3>
<h3 id="5-上传"><a class="header-anchor" href="#5-上传">¶</a>5. 上传</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  study_code.git   //根据自己的远程仓库名输入</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m “你的提交信息”</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="命令说明"><a class="header-anchor" href="#命令说明">¶</a>命令说明</h2>
<table>
<tr>
<th>clone + 仓库地址</th>           <td>克隆你的仓库至本地</td>
</tr>
<tr>
 <th>cd + 你的远程仓库名</th>       <td>进入到远程仓库内(根据自己的仓库名输入)</td>
<tr>
 <th>git init </th>                <td>初始化Git</td> 
</tr>
<tr>
 <th>git add .	</th>              <td>将工作区的文件添加到暂存区<br>（"."是当前目录下的所有文件，也可只输入文件夹名称）</td>
</tr>
<tr>
 <th>git commit -m  "你的提交信息"</th> 	<td>将暂存区的文件添加到本地仓库</td>
</tr>
<tr>
 <th>git push</th>                      <td>提交到远程仓库（可能需要你输入帐号和密码）</td>
</tr>
<tr>
<th>git pull <远程库名> <远程分支名>:<本地分支名></th>     <td>拉取远程仓库分支内容到本地分支<br>
                                                            git pull 命令等同于先做了git fetch ，再做了git merge</td>
</table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>实用工具教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>在虚拟机中设置静态Ip（centos为例）</title>
    <url>/2022/09/03/3256bd2afccc/</url>
    <content><![CDATA[<h3 id="一、虚拟机设置"><a class="header-anchor" href="#一、虚拟机设置">¶</a>一、虚拟机设置</h3>
<p>在菜单栏选择编辑→ 虚拟网络编辑器，打开虚拟网络编辑器对话框，选择Net网络连接方式，随意设置子网IP，点击NAT设置页面，查看子网掩码和网关，后面修改静态IP会用到。</p>
<p>在VMnet8模式下选择nat连接，并且取消DHCP服务。</p>
<span id="more"></span>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP_.1png.17pkik590cyo.webp" alt="设置静态IP_"><br>
点击NAT设置，记录下此时的网关</p>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP_2.7ekm3kk01u40.webp" alt="设置静态IP_2"></p>
<p>在系统的网络设置处，检查VMnet8的网络配置</p>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP_3.7jon5g0ujuc0.webp" alt="设置静态IP_3"></p>
<h3 id="二、Liunx主机设置"><a class="header-anchor" href="#二、Liunx主机设置">¶</a>二、Liunx主机设置</h3>
<ol>
<li>在root权限下输入命令 <code>cd /etc/sysconfig/network-scripts</code> 进入该文件夹，输入命令 <code>ls</code> 浏览该文件夹下的文件，找到<code>ifcfg-en***</code>文件，如下图所示：</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP_4.17zbfvv7ytuo.webp" alt="设置静态IP_4"></p>
<ol start="2">
<li><code>vim ifcfg-en***</code>打开文件</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP_5.1dtjdfu2j734.jpg" alt=""></p>
<ol>
<li>将BOOTPROTO=&quot;dhcp&quot;改为BOOTPROTO=“static”、ONBOOT=&quot;no&quot;改为ONBOOT=“yes”</li>
</ol>
<p>并在下方添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">IPADDR=*your ip*（静态IP地址）</span><br><span class="line"></span><br><span class="line">NETMASK=*your netmask*（子网掩码，一般为255.255.255.0）</span><br><span class="line"></span><br><span class="line">GATEWAY=*your gateway*（网关地址）</span><br><span class="line"></span><br><span class="line">DNS1=8.8.8.8（国内外公共DNS即可）</span><br><span class="line"></span><br><span class="line">DNS2=8.8.4.4</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>最后输入:wq退出即可</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络配置</tag>
      </tags>
  </entry>
  <entry>
    <title>家用台式电脑配件指南</title>
    <url>/2021/07/15/1b222fd4a028/</url>
    <content><![CDATA[<p><strong>家用台式电脑</strong></p>
<p>文档初稿编辑日期：2021年7月15日</p>
<span id="more"></span>
<h2 id="硬件"><a class="header-anchor" href="#硬件">¶</a>硬件</h2>
<h3 id="CPU（中央处理器）"><a class="header-anchor" href="#CPU（中央处理器）">¶</a>CPU（中央处理器）</h3>
<ul>
<li>
<p>品牌</p>
<ul>
<li>
<p>INTEL（英特尔）</p>
<ul>
<li>
<p>酷睿（core）（游戏发烧友专用）（频率高，对游戏有特别优化）</p>
<ul>
<li>Core</li>
<li>Core2</li>
<li>Core M</li>
<li>Core i3 #入 #门 #级</li>
<li>Core i5 #中 #端 #级</li>
<li>Core i7 #高 #端 #级</li>
<li>Core i9 #发 #烧 #级</li>
<li>已停产</li>
</ul>
</li>
<li>
<p>志强（Xeon）（针对企业级用户，特点：核心数多，适合多开）</p>
<ul>
<li>
<p>E3</p>
</li>
<li>
<p>E5</p>
</li>
<li>
<p>E7</p>
</li>
<li>
<p>服务器CPU</p>
<ul>
<li>
<p>后缀名称示意</p>
<ul>
<li>
<p>L（低功耗版</p>
</li>
<li>
<p>后面的第一位数字代表最多主持几路</p>
</li>
<li>
<p>第二位数字代表处理器封装接口形式</p>
<ul>
<li>2（LGA1155）</li>
<li>4（LGA1356）</li>
<li>6（LGA2011）</li>
<li>8（LGA1567）</li>
</ul>
</li>
<li>
<p>第三位和第四位指性能大小，越大越好</p>
</li>
<li>
<p>V？（修订的代数）</p>
</li>
<li>
<p>X（极致性能）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>赛扬（Celeron）</p>
</li>
<li>
<p>奔腾（Pentium）</p>
</li>
<li>
<p>不同等级</p>
<ul>
<li>
<p>后缀名称示意</p>
<ul>
<li>X（至尊版）</li>
<li>K（支持超频，更高性能</li>
<li>KF（支持超频，无核显）</li>
<li>F（无核显）</li>
<li>C（五代酷睿特殊产物）</li>
<li>S（65W节能版）</li>
<li>ES（工程样品）</li>
<li>QS（品质确认样品）</li>
<li>T（45W节能版）</li>
<li>无（不支持超频，有核显，标准版）</li>
</ul>
</li>
<li>
<p>后面的第一位数代表代数（同等级下越大越好）</p>
</li>
<li>
<p>第二到四位代表级别（同代数下越大越好）</p>
</li>
<li>
<p>建议</p>
<ul>
<li>截止到此版本文档编辑日期，不建议购买10代以前的英特尔CPU</li>
</ul>
</li>
<li>
<p>例如 i5-9400F</p>
<ul>
<li>就是英特尔第九代级别为400的无核显处理器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>AMD（超微半导体）</p>
<ul>
<li>
<p>锐龙（Ryzen）</p>
<ul>
<li>Ryzen 3 #入 #门 #级</li>
<li>Ryzen 5 #中 #端 #级</li>
<li>Ryzen 7 #进 #阶 #级</li>
<li>Ryzen 9 #高 #端 #级</li>
<li>线程撕裂者（Threadripper） #发 #烧 #级</li>
</ul>
</li>
<li>
<p>AMD FX</p>
</li>
<li>
<p>APU</p>
</li>
<li>
<p>速龙（Athlon）</p>
</li>
<li>
<p>闪龙（Sempron）</p>
</li>
<li>
<p>不同等级</p>
<ul>
<li>
<p>后缀名称示意</p>
<ul>
<li>K（支持超频）</li>
<li>E（95W低功耗）</li>
<li>G（集成Vega核显）</li>
<li>X（主持完整自动睿频）</li>
<li>XT（特挑版，更强的超频性能）</li>
<li>无（支持超频，无核心显卡，标准版）</li>
</ul>
</li>
<li>
<p>后面的第一位数代表代数（同等级下越大越好）</p>
</li>
<li>
<p>第二到四位代表级别（同代数下越大越好）</p>
</li>
<li>
<p>例如 r7 2700</p>
<ul>
<li>AMD的第二代性能级别为700的标准处理器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>核心数量</p>
<ul>
<li>
<p>游戏玩家</p>
<ul>
<li>建议不低于4核，不高于12核</li>
</ul>
</li>
<li>
<p>生产力用户</p>
<ul>
<li>预算允许的情况下核心数量建议6核起步（同世代有超线程技术更好）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>核心频率</p>
<ul>
<li>
<p>基频（主频）</p>
<ul>
<li>浏览网页等情况，CPU会保持在基准频率运行，为CPU最低频率</li>
</ul>
</li>
<li>
<p>睿频（动态加速频率）</p>
<ul>
<li>玩游戏等时刻 能够提升到的最高频率</li>
</ul>
</li>
</ul>
</li>
<li>
<p>超线程技术</p>
<ul>
<li>
<p>一个核心配有两个线程协同工作</p>
<ul>
<li>多线程技术对于剪辑，处理图形等工作有较大优势</li>
<li>对于游戏玩家不建议过多关注是否有超线程技术</li>
</ul>
</li>
</ul>
</li>
<li>
<p>缓存（扩展知识）</p>
<ul>
<li>
<p>一级缓存</p>
<ul>
<li>容量小，速度快</li>
</ul>
</li>
<li>
<p>二级缓存</p>
</li>
<li>
<p>三级缓存</p>
<ul>
<li>容量大，速度较慢</li>
</ul>
</li>
</ul>
</li>
<li>
<p>架构和制程工艺</p>
<ul>
<li>买新不买旧</li>
<li>越小越好</li>
</ul>
</li>
</ul>
<h3 id="GPU（图形处理器）"><a class="header-anchor" href="#GPU（图形处理器）">¶</a>GPU（图形处理器）</h3>
<ul>
<li>
<p>品牌</p>
<ul>
<li>
<p>英伟达（nVIDIA）</p>
<ul>
<li>
<p>前缀</p>
<ul>
<li>
<p>CUDA通算时代</p>
<ul>
<li>RTX（实时光线追踪支持）</li>
<li>GTX（高端）</li>
<li>GTS（简化版）</li>
<li>GT（低端）</li>
<li>GF（入门级）</li>
</ul>
</li>
<li>
<p>管线架构时代</p>
<ul>
<li>FX（产品前缀）</li>
</ul>
</li>
<li>
<p>图形加速时代</p>
<ul>
<li>GF（系列）</li>
<li>MX（产品前缀）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>后缀</p>
<ul>
<li>
<p>CUDA通算时代</p>
<ul>
<li>Ti（高速加强版）</li>
<li>SUPER（加强版）</li>
<li>S（加强版）</li>
<li>无（标准版）</li>
<li>Z（双芯加强版）</li>
</ul>
</li>
<li>
<p>统一渲染架构时代</p>
<ul>
<li>GTX（极致版）</li>
<li>GT（加强版）</li>
<li>G（普通版）</li>
<li>Ti（高速加强版）</li>
<li>SE/GS（简化版）</li>
</ul>
</li>
<li>
<p>管线架构时代</p>
<ul>
<li>ULTRA（超级版）</li>
<li>Ti（高速加强版）</li>
<li>GS（简化版）</li>
<li>LE/XT/ZT（低端版）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>INTEL核心显卡</p>
<ul>
<li>UHD</li>
<li>HDXXX</li>
<li>IRIS</li>
<li>HDXXXX</li>
<li>GMA-HD</li>
</ul>
</li>
<li>
<p>AMD核心显卡</p>
<ul>
<li>R7</li>
<li>R3</li>
<li>HD</li>
</ul>
</li>
<li>
<p>AMD（超微半导体）</p>
<ul>
<li>
<p>前缀</p>
<ul>
<li>
<p>4K超清时代</p>
<ul>
<li>R9（高端）</li>
<li>R7（中端）</li>
<li>R5/3（入门级）</li>
</ul>
</li>
<li>
<p>HD高清时代</p>
<ul>
<li>HD（支持高清解码功能）</li>
</ul>
</li>
<li>
<p>统一渲染架构时代</p>
<ul>
<li>X（默认）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>后缀</p>
<ul>
<li>
<p>4K超清时代</p>
<ul>
<li>X2（双芯显卡）</li>
<li>X（完整核心）</li>
<li>no- X（简化一次）</li>
</ul>
</li>
<li>
<p>HD高清时代</p>
<ul>
<li>90（超规格如双芯）</li>
<li>70（完整核心）</li>
<li>50（简化一次）</li>
<li>30（简化两次）</li>
</ul>
</li>
<li>
<p>统一渲染架构时代</p>
<ul>
<li>XTX（终极版）</li>
<li>XT（超级版）</li>
<li>LE（简化版）</li>
<li>PRO（专业通用版）</li>
<li>HM（内存共享版）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>显卡核心晶片及显存供应厂商</p>
</li>
</ul>
</li>
<li>
<p>代工品牌</p>
<ul>
<li>
<p>一线</p>
<ul>
<li>
<p>华硕（ASUS）</p>
<ul>
<li>PH</li>
<li>DUAL</li>
<li>TUF</li>
<li>猛禽A？G</li>
<li>猛禽O？G</li>
<li>骇客</li>
<li>等级从上向下由低到高，下同</li>
</ul>
</li>
<li>
<p>微星（MSI）</p>
<ul>
<li>AERO</li>
<li>万图师</li>
<li>装甲师</li>
<li>暗黑龙爵</li>
<li>魔龙X</li>
<li>魔龙Z</li>
<li>闪电</li>
</ul>
</li>
<li>
<p>技嘉（GIGABYTE）</p>
<ul>
<li>OC</li>
<li>风之力</li>
<li>GAMING OC</li>
<li>AORUS小雕</li>
<li>AORUS大雕</li>
<li>AORUS水雕</li>
</ul>
</li>
</ul>
</li>
<li>
<p>二线及以下</p>
<ul>
<li>
<p>影驰（GALAXY Technology）</p>
<ul>
<li>骁将</li>
<li>大将</li>
<li>GAMER</li>
<li>金属大师</li>
<li>星耀</li>
<li>名人堂</li>
<li>HOF 10TH</li>
</ul>
</li>
<li>
<p>七彩虹（COLORFUL）</p>
<ul>
<li>战斧</li>
<li>ULTRA</li>
<li>AD special</li>
<li>Advanced</li>
<li>Neptune</li>
<li>九段</li>
</ul>
</li>
<li>
<p>映众（lnnoVISION）</p>
<ul>
<li>黑金至尊</li>
<li>GAMING OC</li>
<li>冰龙</li>
<li>冰龙OC</li>
<li>冰龙黑金</li>
</ul>
</li>
<li>
<p>索泰（ZOTAC）</p>
<ul>
<li>毁灭者</li>
<li>X GAMING</li>
<li>霹雳</li>
<li>至尊PLUS OC</li>
<li>玩家力量PGF</li>
<li>PGF极光OC</li>
</ul>
</li>
<li>
<p>耕升（GAINWARD）</p>
<ul>
<li>追风</li>
<li>炫光</li>
<li>G魂</li>
<li>G魂极客</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>散热</p>
<ul>
<li>
<p>风冷</p>
<ul>
<li>
<p>铝制鳍片+散热风扇</p>
</li>
<li>
<p>热管+散热风扇</p>
<ul>
<li>6mm热管</li>
<li>8mm热管</li>
</ul>
</li>
</ul>
</li>
<li>
<p>水冷</p>
<ul>
<li>120冷排（1*120mm风扇）</li>
<li>240冷排（2*120mm风扇）</li>
<li>280冷排（2*140mm 风扇）</li>
<li>360冷排（3*120mm风扇）</li>
<li>480冷排（4*120mm风扇）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>额外需要注意机箱支持的显卡长度</p>
</li>
</ul>
<h3 id="主板"><a class="header-anchor" href="#主板">¶</a>主板</h3>
<ul>
<li>
<p>适配IU</p>
<ul>
<li>H（入门级，价格低，不支持超频）</li>
<li>B（中端级，高性价比，不支持超频）</li>
<li>Z（高端级，支持超频）</li>
<li>X（发烧级，价格极高，支持超频）</li>
</ul>
</li>
<li>
<p>适配AU</p>
<ul>
<li>A（入门级，不支持超频）</li>
<li>B（中端级，支持超频）</li>
<li>X（高端级，支持超频）</li>
</ul>
</li>
<li>
<p>供电数量</p>
<ul>
<li>子主题 1</li>
</ul>
</li>
<li>
<p>USB接口</p>
<ul>
<li>
<p>种类</p>
<ul>
<li>
<p>USB Type-A</p>
</li>
<li>
<p>USB Type-B</p>
</li>
<li>
<p>USB Type-C</p>
<ul>
<li>
<p>体积8·3mmx2·5mm</p>
<ul>
<li>
<p>支持正反插</p>
<ul>
<li>
<p>24个金属触点，兼容USB2·0，USB3·0，雷电3/4协议，最高100W供电</p>
<ul>
<li>最高40Gbps带宽</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>按大小划分</p>
<ul>
<li>Standard标准</li>
<li>Mini小型</li>
<li>Micro微型</li>
</ul>
</li>
</ul>
</li>
<li>
<p>接口协议</p>
<ul>
<li>
<p>USB 2·0（黑色）</p>
<ul>
<li>480Mbps带宽</li>
</ul>
</li>
<li>
<p>USB3·0（3·1 GEN1）（蓝色）</p>
<ul>
<li>5Gbps带宽</li>
</ul>
</li>
<li>
<p>USB 3·0（3·1 GEN2）（红色）</p>
<ul>
<li>10Gbps带宽</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>品牌</p>
<ul>
<li>
<p>一线</p>
<ul>
<li>
<p>华硕（ASUS）</p>
<ul>
<li>Maximus</li>
<li>STRIX</li>
<li>TUF</li>
<li>PRIME</li>
<li>PIXIU（电商专供）</li>
<li>等级从上向下由高到低，下同</li>
</ul>
</li>
<li>
<p>技嘉（GIGABYTE）</p>
<ul>
<li>
<p>AORUS系列</p>
<ul>
<li>旗舰大雕</li>
<li>超级雕</li>
<li>超凡雕</li>
<li>小雕PRO</li>
<li>小雕</li>
</ul>
</li>
<li>
<p>GAMING系列</p>
</li>
<li>
<p>超耐久系列</p>
<ul>
<li>
<p>D（全固态日系电容）</p>
</li>
<li>
<p>V（CPU供电简化用料）</p>
</li>
<li>
<p>U（超耐久）</p>
</li>
<li>
<p>H（CPU供电标准用料）</p>
</li>
<li>
<p>SLI（支持英伟达多卡技术）</p>
</li>
<li>
<p>S？/纯数字（技嘉的5个优化）</p>
<ul>
<li>safe</li>
<li>smart</li>
<li>speed</li>
<li>silent-Pipe</li>
<li>SLI</li>
</ul>
</li>
<li>
<p>尾缀</p>
<ul>
<li>H（HDMI</li>
<li>V（VGA）</li>
<li>P（PLUS增强版）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>微星（MSI）</p>
<ul>
<li>
<p>GAMING系列</p>
<ul>
<li>
<p>MPG系列</p>
<ul>
<li>GAMING PRO CARBON</li>
<li>GAMING EDGE</li>
<li>GAMING PRO</li>
<li>GAMING PLUS</li>
</ul>
</li>
<li>
<p>MEG系列</p>
<ul>
<li>暗影</li>
<li>战神</li>
<li>创世</li>
<li>超神</li>
</ul>
</li>
</ul>
</li>
<li>
<p>军火库系列</p>
<ul>
<li>
<p>战斧导弹（TOMAHAWK）</p>
</li>
<li>
<p>迫击炮（MORTAK）</p>
<ul>
<li>TITANIU为极地款</li>
</ul>
</li>
<li>
<p>火箭筒（BAZOOKA）</p>
<ul>
<li>带有PLUS属于增强款</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Pro系列</p>
<ul>
<li>PRO-V（支持VGA接口）</li>
<li>PRO-VD（支持VGA和DVI接口）</li>
<li>PRO- VH（支持VGA和HDMI接口）</li>
<li>PRO-VDH（支持VGA，DVI，和HDMI接口）</li>
<li>PRO-M2（支持M.2插槽）</li>
<li>I-PRO（ITX迷你版型）</li>
<li>PRO-VL（支持VGA接口和LPT并行接口）</li>
<li>A-PRO（入门主板）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>华擎（ASRock）</p>
<ul>
<li>AQUA</li>
<li>幻影电竞</li>
<li>CREATOR</li>
<li>太极</li>
<li>钢铁传奇</li>
<li>极限玩家</li>
<li>PRO</li>
<li>超频方程式</li>
<li>玩家至尊</li>
</ul>
</li>
<li>
<p>概要</p>
<ul>
<li>M（ATX）</li>
<li>I（ITX）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>二线及以下</p>
<ul>
<li>
<p>七彩虹（COLORFUL）</p>
<ul>
<li>IGAME</li>
<li>战旗系列</li>
<li>CVN系列</li>
<li>战斧系列</li>
<li>网驰系列</li>
<li>断剑系列</li>
</ul>
</li>
<li>
<p>映泰（BIOSTAR）</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>大小尺寸（单位：mm）</p>
<ul>
<li>WTX（356*425单位mm）</li>
<li>AT（350*305）</li>
<li>Baby- AT（330*216）</li>
<li>BTX（325*266）</li>
<li>Mini- ITX（170*170）</li>
<li>M-ATX（224*224）</li>
<li>ATX（305*244）</li>
<li>E-ATX（305*330）</li>
<li>LPX（330*229）</li>
<li>NLX（254*228）</li>
<li>DTX（244*203）</li>
<li>Flex ATX（229*191）</li>
<li>EPIC（165*115）</li>
<li>ESM（149*71）</li>
<li>Nano- ITX（120*120）</li>
<li>COM express（125*95）</li>
<li>ESM express（125*95）</li>
<li>ETX/XTX（114*95）</li>
<li>Pico-ITX（100*72）</li>
<li>PC/104（96*90）</li>
<li>mobile- ITX（75*45）</li>
<li>Ultra ATX（？*244）</li>
<li>额外注意是否兼容你的机箱‼️</li>
<li>最常见，最建议选择的</li>
</ul>
</li>
<li>
<p>音频接口</p>
<ul>
<li>中置/低音音频输出（桔黄色）接口</li>
<li>后置音频输出（黑色）接口（支持 4 ，6 或者 8 信道音频）</li>
<li>音频输入（浅蓝色）接口（连接至磁带播放器或其他音频来源）</li>
<li>耳机/音频输出（浅绿色）接口</li>
<li>麦克风（粉色）接口</li>
<li>音频输出（灰色）接口（支持 8 信道音频）</li>
</ul>
</li>
<li>
<p>主板CPU接口型号概括</p>
<ul>
<li>
<p>IU</p>
<ul>
<li>LGA771</li>
<li>LGA775</li>
<li>LGA1156</li>
<li>LGA1155</li>
<li>LGA1150</li>
<li>LGA1151（适用Intel8，9代CPU）</li>
<li>LGA1200（适用Intel10代CPU）</li>
</ul>
</li>
<li>
<p>AU</p>
<ul>
<li>AM2(940针）</li>
<li>AM2+（940针）</li>
<li>AM3（938针）</li>
<li>AM3+（941针）</li>
<li>AM4（1331针）</li>
</ul>
</li>
<li>
<p>根据CPU针脚数以及插槽类型选择合适主板</p>
</li>
</ul>
</li>
</ul>
<h3 id="内存"><a class="header-anchor" href="#内存">¶</a>内存</h3>
<ul>
<li>
<p>品牌</p>
<ul>
<li>
<p>金士顿（Kingston）</p>
<ul>
<li>普条</li>
<li>骇客神条</li>
<li>掠食者</li>
<li>等级从上向下由低到高，下同</li>
</ul>
</li>
<li>
<p>海盗船（USCORSAIR）</p>
<ul>
<li>普条</li>
<li>复仇者LPX</li>
<li>复仇者RGB</li>
<li>铂金统治者</li>
</ul>
</li>
<li>
<p>芝奇（G.SKILL ）</p>
<ul>
<li>普条</li>
<li>Aegis，Ripjaws，Sniper X</li>
<li>幻光戟，焰光戟</li>
<li>皇家戟</li>
</ul>
</li>
<li>
<p>威刚（ADATA）</p>
<ul>
<li>万紫千红</li>
<li>XPG-Z1</li>
<li>龙耀D60G</li>
<li>龙耀D80</li>
</ul>
</li>
<li>
<p>影驰（GALAXY Technology）</p>
<ul>
<li>普条</li>
<li>GAMER</li>
<li>名人堂</li>
<li>HOF EXTREME</li>
</ul>
</li>
<li>
<p>十铨（TEAM GROUP）</p>
<ul>
<li>普条</li>
<li>火神/冥神/TUF/DELTA</li>
<li>夜莺</li>
<li>王者之剑</li>
</ul>
</li>
<li>
<p>英睿达（CRUCIAL）</p>
</li>
<li>
<p>宇瞻（Apacer）</p>
</li>
<li>
<p>科赋（KLEVV）</p>
</li>
<li>
<p>光威（GLOWAY）</p>
</li>
<li>
<p>阿斯加特（ASGARD）</p>
</li>
<li>
<p>铭瑄（MAXSUN）</p>
</li>
<li>
<p>台电（TECLAST）</p>
</li>
<li>
<p>金泰克（TIGO）</p>
</li>
<li>
<p>七彩虹（COLORFUL）</p>
</li>
</ul>
</li>
<li>
<p>世代</p>
<ul>
<li>DDR</li>
<li>DDR2</li>
<li>DDR3</li>
<li>DDR4</li>
<li>DDR5</li>
<li>已停产</li>
</ul>
</li>
<li>
<p>容量</p>
<ul>
<li>
<p>4-8G（写文档，看电影）</p>
</li>
<li>
<p>8-16G（中度游戏，轻度视频剪辑）</p>
</li>
<li>
<p>不小于16G，32G更好（大型游戏，直播，多开渲染）</p>
</li>
<li>
<p>优先双通道</p>
<ul>
<li>例如你需要16G内存，那你最好购买两条品牌，世代，容量，频率完全相等的内存条</li>
<li>2<em>8G2666理论性能＞1</em>16G3200</li>
<li>主板有四根内存插槽时，你恰好有两根内存条，优先2，4插槽</li>
</ul>
</li>
</ul>
</li>
<li>
<p>频率</p>
<ul>
<li>英特尔家H，B系列主板，最高2666MHZ</li>
<li>AMD家B系列，建议3000MHZ</li>
<li>Z，X系列等，建议3200+MHZ</li>
</ul>
</li>
<li>
<p>颗粒</p>
<ul>
<li>
<p>生产厂商</p>
<ul>
<li>三星</li>
<li>镁光</li>
<li>海力士</li>
<li>紫光</li>
</ul>
</li>
<li>
<p>品质</p>
<ul>
<li>
<p>合格</p>
</li>
<li>
<p>不合格（不要碰）</p>
<ul>
<li>黑片</li>
<li>白片</li>
<li>打磨片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时序（扩展知识）</p>
<ul>
<li>
<p>越低越快</p>
<ul>
<li>
<p>CL-TRCD-TRP-TRAS</p>
<ul>
<li>CL是发送一个列地址到内存与数据开始响应之间的周期数，这个值通常和TRCD和TRP相同或低1-2，并且是最影响内存性能的时序参数</li>
<li>TRCD是打开一行内存并访问其中的列所需的最小时钟周期数</li>
<li>TRP是发出预充电命令与打开下一行之间所需的最小时钟周期数，通常和TRCD值一样</li>
<li>TRAS是行活动命令与发出预充电命令之间所需的最小时钟周期数，它必须大雨TRCD和TRP的和</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="硬盘"><a class="header-anchor" href="#硬盘">¶</a>硬盘</h3>
<ul>
<li>
<p>机械硬盘</p>
<ul>
<li>
<p>品牌</p>
<ul>
<li>
<p>希捷（SEAGATE）</p>
<ul>
<li>酷鱼（普通PC用户）</li>
<li>酷玩（游戏用户）</li>
<li>酷鹰（监控用户）</li>
<li>酷狼（NAS网络存储）</li>
<li>ES系列（企业级，高性能硬盘）</li>
</ul>
</li>
<li>
<p>西部数据（WD）</p>
<ul>
<li>蓝盘（标准版适合家庭使用）</li>
<li>黑盘（多用于企业，服务器以及工作站，和大型游戏玩家）</li>
<li>绿盘（节能型硬盘）</li>
<li>红盘（监控盘）</li>
<li>紫蓝（优化的监控盘）</li>
<li>金盘（主要针对企业用户）</li>
</ul>
</li>
<li>
<p>东芝（TOSHIBA）</p>
</li>
</ul>
</li>
<li>
<p>容量</p>
<ul>
<li>实际容量＝？T*930（G）</li>
<li>日常办公1T足矣</li>
<li>打游戏的话真心建议选择大容量企业盘</li>
<li>1T容量以下的一律不要买</li>
</ul>
</li>
<li>
<p>转速</p>
<ul>
<li>5400，5900，7200（性能价格最均衡），10500</li>
</ul>
</li>
<li>
<p>缓存</p>
<ul>
<li>32M，64M，128M，256M</li>
<li>非企业级硬盘，缓存大于64M的一律不要买</li>
</ul>
</li>
<li>
<p>尺寸</p>
<ul>
<li>3.5英寸移动硬盘</li>
</ul>
</li>
</ul>
</li>
<li>
<p>固态硬盘</p>
<ul>
<li>
<p>协议</p>
<ul>
<li>IDE</li>
<li>AHCI</li>
<li>NVMe</li>
<li>SCSI（服务器）</li>
</ul>
</li>
<li>
<p>总线（扩展知识）</p>
<ul>
<li>
<p>SATA</p>
<ul>
<li>
<p>3·0</p>
<ul>
<li>理论带宽6Gbps</li>
<li>编码8:10</li>
<li>换算传输速度600MB/s</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PCIe</p>
<ul>
<li>
<p>3·0</p>
<ul>
<li>
<p>编码128:130</p>
<ul>
<li>
<p>传输速率</p>
<ul>
<li>x1：984·6MB/s</li>
<li>x4：3·938GB/s</li>
<li>x8：7·877GB/s</li>
<li>x16：15·754GB/S</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>4·0</p>
<ul>
<li>
<p>编码128:130</p>
<ul>
<li>
<p>传输速率</p>
<ul>
<li>x1:1·969GB/s</li>
<li>x4:7·877GB/s</li>
<li>x8:15·754GB/s</li>
<li>x16：31·508GB/s</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SAS（服务器）</p>
<ul>
<li>
<p>3·0</p>
<ul>
<li>理论带宽12Gbps</li>
<li>编码8:10</li>
<li>换算传输速度1·2GB/s</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>接口</p>
<ul>
<li>
<p>SATA</p>
<ul>
<li>
<p>SATA总线</p>
<ul>
<li>AHCI协议</li>
</ul>
</li>
</ul>
</li>
<li>
<p>mSATA</p>
<ul>
<li>
<p>SATA总线</p>
<ul>
<li>AHCI协议</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SATA Express</p>
<ul>
<li>
<p>PCIe总线</p>
<ul>
<li>AHCI协议</li>
<li>NVMe协议</li>
</ul>
</li>
</ul>
</li>
<li>
<p>M．2（NGFF）（优先选择）</p>
<ul>
<li>
<p>M·Key（豁口在右）</p>
</li>
<li>
<p>B·Key（豁口在左）</p>
</li>
<li>
<p>概要</p>
<ul>
<li>
<p>SATA总线</p>
<ul>
<li>AHCI协议</li>
</ul>
</li>
<li>
<p>PCIe总线</p>
<ul>
<li>AHCI协议</li>
</ul>
</li>
<li>
<p>PICe总线</p>
<ul>
<li>NVMe协议</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PCIe</p>
<ul>
<li>NVMe</li>
<li>SCSI</li>
</ul>
</li>
<li>
<p>U·2（服务器）</p>
<ul>
<li>
<p>SATA总线</p>
<ul>
<li>AHCI协议</li>
</ul>
</li>
<li>
<p>PCIe总线</p>
<ul>
<li>NVMe协议</li>
</ul>
</li>
<li>
<p>SAS总线</p>
<ul>
<li>SCSI协议</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SAS（服务器）</p>
<ul>
<li>
<p>SATA总线</p>
<ul>
<li>AHCI协议</li>
</ul>
</li>
<li>
<p>SAS总线</p>
<ul>
<li>SCSI协议</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>容量</p>
<ul>
<li>120G，240等，1T，2T等</li>
</ul>
</li>
<li>
<p>品牌：</p>
<ul>
<li>
<p>一线</p>
<ul>
<li>三星（SAMSUN G）</li>
<li>闪迪（SANDISK）</li>
<li>凯侠（KIOXIA）</li>
<li>金士顿（KINGSTON）</li>
<li>英特尔（INTEL）</li>
</ul>
</li>
<li>
<p>二线及以下</p>
<ul>
<li>浦科特（PLESTOR）</li>
<li>英睿达（CRUCIAL）</li>
<li>威刚（ADATA）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>推荐</p>
<ul>
<li>1、600元内推荐金士顿A2000（速度远超其他三款，大文件持续写入比其他三款强，寿命也比另三款久，建议加装散热片）</li>
<li>2、600-800元西数sn730（性能更强，oem盘售后保障弱）</li>
<li>3、铠侠rc10（各项及格）</li>
<li>4、三星pm981a（性能更强，oem盘售后保障弱）</li>
<li>5、西数sn550（唯一优点温度低，此外不推荐）</li>
<li>6、800-900元推荐铠侠rd20（优势是大文件持续写入速度，双面颗粒较厚不建议轻薄笔记本选择）</li>
<li>7、三星pm9a1（各项最强，oem盘售后保障弱）</li>
<li>8、三星980（笔记本轻度使用可以考虑，温度低，缓内4k强，适合当系统盘）</li>
<li>9、900元以上三星970evo plus（万金油无脑选）</li>
<li>10、pny cs3040（推荐当仓库盘，2TB 1000元出头）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="电源"><a class="header-anchor" href="#电源">¶</a>电源</h3>
<ul>
<li>
<p>品牌</p>
<ul>
<li>
<p>第一梯队</p>
<ul>
<li>海盗船（CORSAIR）</li>
<li>海韵（SEASONIC）</li>
<li>EVGA</li>
<li>振华（SUPER FLOWER）</li>
<li>全汉（FSP）</li>
<li>台达（DELTA）</li>
<li>酷冷至尊（COOLER MASTER）</li>
<li>银欣（SILVER STONE）</li>
<li>华硕（ASUS）</li>
</ul>
</li>
<li>
<p>第二梯队</p>
<ul>
<li>长城（GREAT WALL）</li>
<li>航嘉（HUNTKEY）</li>
<li>安钛克（ANTEC）</li>
<li>迎广（IN WIN）</li>
<li>tt（THERMALTAKE）</li>
<li>追风者（PHANTEKS）</li>
<li>九州风神（DEEP COOL）</li>
<li>艾湃电竞（APEX GAMING）</li>
<li>鑫谷（SEGOTEP）</li>
<li>先马（SAMA）</li>
</ul>
</li>
<li>
<p>第三梯队</p>
<ul>
<li>金河田（GOLDEN FIELD）</li>
<li>爱国者（AIGO）</li>
<li>大水牛（BUBALUS）</li>
<li>首席玩家（1st PALYER）</li>
<li>游戏悍将</li>
<li>骨伽（GOUGAR）</li>
<li>安耐美（ENERMAX）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>额定功率</p>
<ul>
<li>
<p>CPU+GPU最大功耗+100W=电源合适功率</p>
</li>
<li>
<p>主要看+12V功率作为电源输出最大功率</p>
</li>
<li>
<p>电源上面标注的不同电压的使用说明（扩展知识）</p>
<ul>
<li>+12V：CPU，GPU，机械硬盘，主板，RGB等等（最主要）</li>
<li>-12V：给串口或者PCI接口设备做电平判断使用，很少用到</li>
<li>+5V：机械硬盘，固态硬盘，主板，RGB，USB等等</li>
<li>+5SB：也叫做+5待机，主要是给主板上的主要芯片提供待机电流，便于快速唤醒和开机使用</li>
<li>+3·3V：固态硬盘，内存，主板等等</li>
</ul>
</li>
</ul>
</li>
<li>
<p>80PLUS认证（不能作为判断电源好坏的唯一标准）</p>
<ul>
<li>
<p>假设你的电源额定功率为750W，电源转化率为85%，那么他在满功率输出时，输入给电源的功率为882W（即x（输入功率）=电源额定功率/转化率（%）</p>
<ul>
<li>白金牌（89%）</li>
<li>金牌（87%）</li>
<li>银牌（85%）</li>
<li>铜牌（82%）</li>
<li>白牌（80%）</li>
<li>无（＜80%）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>简单的选择方法</p>
<ul>
<li>顶级电源：一元左右或以上才1W的电源</li>
<li>优秀电源：0·8元左右1W的电源</li>
<li>不错电源:0·6元左右1W的电源</li>
<li>勉强能用：0·4元左右1W的电源</li>
<li>BOOM：0.4元以下1W的电源（不要选）</li>
</ul>
</li>
<li>
<p>方案（扩展知识）</p>
<ul>
<li>
<p>市电入户</p>
<ul>
<li>
<p>一二级EMI滤波</p>
<ul>
<li>
<p>整流桥</p>
<ul>
<li>
<p>主动式PFC</p>
</li>
<li>
<p>被动式PFC</p>
</li>
<li>
<p>概要</p>
<ul>
<li>
<p>LLC全桥</p>
</li>
<li>
<p>LLC半桥</p>
</li>
<li>
<p>双管正激</p>
</li>
<li>
<p>单管正激</p>
</li>
<li>
<p>概要</p>
<ul>
<li>
<p>DC-DC</p>
</li>
<li>
<p>单磁路放大</p>
</li>
<li>
<p>概要</p>
<ul>
<li>为你的电脑供电</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>电容（扩展知识）</p>
<ul>
<li>日系富士通电容</li>
<li>红宝石电容</li>
<li>三洋电容</li>
<li>台系风宾电容</li>
</ul>
</li>
<li>
<p>模组</p>
<ul>
<li>非模组（最便宜，线材不可拆卸，不美观，整理麻烦）</li>
<li>半模组（稍贵，少数必要线材固定，多余线头可拆卸）</li>
<li>全模组（最贵，所有线缆均可拆卸，最为美观）</li>
</ul>
</li>
<li>
<p>尺寸</p>
<ul>
<li>SFX（125mm x 100mm x 63.5mm）</li>
<li>SFX- L（125mm x 130mm x 63.5mm）</li>
<li>ATX（150mm x 140mm x 86mm)</li>
<li>1U尺寸（150mm x 81mm x 40.5mm）</li>
<li>最常见也最建议购买的</li>
</ul>
</li>
<li>
<p>总结</p>
<ul>
<li>不要购买山寨电源，千万不要在这个配件上面缩水，否则…</li>
</ul>
</li>
</ul>
<h3 id="散热器"><a class="header-anchor" href="#散热器">¶</a>散热器</h3>
<ul>
<li>
<p>风冷</p>
<ul>
<li>
<p>组成</p>
<ul>
<li>
<p>热管</p>
<ul>
<li>
<p>数量</p>
<ul>
<li>家用办公选2根热管或无热管都可以</li>
<li>玩游戏不超频4热管够用</li>
<li>超频游戏可选6根及以上数量热管，一定要是铜底焊接底座</li>
</ul>
</li>
<li>
<p>直径</p>
<ul>
<li>6mm</li>
<li>8mm</li>
</ul>
</li>
<li>
<p>工艺</p>
<ul>
<li>
<p>镀镍</p>
<ul>
<li>热管呈亮银色，有防腐防锈作用</li>
</ul>
</li>
<li>
<p>无镀镍</p>
<ul>
<li>热管呈黄铜色</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>底座</p>
<ul>
<li>
<p>热管直触</p>
<ul>
<li>价格便宜，精度较差，底部铜管太薄</li>
</ul>
</li>
<li>
<p>铜底焊接</p>
<ul>
<li>底座平整，精度高，耐用，多用于高端散热器</li>
</ul>
</li>
<li>
<p>均热板</p>
<ul>
<li>少见，导热效率更高，高端笔记本上多用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>鳍片</p>
<ul>
<li>
<p>数量</p>
<ul>
<li>
<p>单塔</p>
<ul>
<li>
<p>单风扇</p>
</li>
<li>
<p>双风扇（价格在百元上下）</p>
<ul>
<li>散热能效可以和大部分120mm甚至入门的240水冷打个五五开</li>
</ul>
</li>
</ul>
</li>
<li>
<p>双塔</p>
<ul>
<li>
<p>单风扇</p>
</li>
<li>
<p>双风扇（价格在两百元上下）</p>
<ul>
<li>完爆120mm水冷，能和240水冷甚至入门360水冷五五开</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>与热管接触工艺</p>
<ul>
<li>
<p>回流焊</p>
<ul>
<li>
<p>内部热管与鳍片焊接</p>
<ul>
<li>成本高，牢固耐用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>穿片</p>
<ul>
<li>
<p>穿FIN，鳍片包围着热管</p>
<ul>
<li>便宜，对做工要求高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>风扇</p>
<ul>
<li>
<p>风量</p>
</li>
<li>
<p>噪音值</p>
</li>
<li>
<p>数量</p>
<ul>
<li>单风扇</li>
<li>双风扇</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>优劣势</p>
<ul>
<li>
<p>优势</p>
<ul>
<li>便宜好用</li>
<li>安全</li>
</ul>
</li>
<li>
<p>劣势</p>
<ul>
<li>依赖机箱通风</li>
<li>体积大</li>
</ul>
</li>
</ul>
</li>
<li>
<p>额外需要注意支持的平台和机箱限高，可能会和某些内存条和显卡发生冲突</p>
</li>
</ul>
</li>
<li>
<p>一体式水冷</p>
<ul>
<li>
<p>组成</p>
<ul>
<li>
<p>一体式冷头</p>
<ul>
<li>内部包含有泵机</li>
</ul>
</li>
<li>
<p>水管</p>
</li>
<li>
<p>冷排（尺寸直接决定散热能力）</p>
<ul>
<li>
<p>120mm</p>
<ul>
<li>稍微正常一点的120mm水冷价格在300-400元左右（一般情况下不建议选择，购买同价格风冷可以获得更好的散热效能）</li>
</ul>
</li>
<li>
<p>240mm</p>
<ul>
<li>
<p>价格基本上在400-600元</p>
<ul>
<li>日常中度游戏选择它足够，适用于压制标准性能CPU，例如中端（i5-9600K）这类CPU超频使用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>360mm</p>
<ul>
<li>
<p>价格基本上在800-1000元</p>
<ul>
<li>超频游戏，直播多开，生产力，适用压制高性能CPU（例如i9-9900K）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>风扇</p>
</li>
</ul>
</li>
<li>
<p>优劣势</p>
<ul>
<li>
<p>优势</p>
<ul>
<li>美观</li>
<li>搬动不易损坏</li>
<li>不会存在与内存和显卡的兼容问题</li>
</ul>
</li>
<li>
<p>劣势</p>
<ul>
<li>价格昂贵</li>
<li>有漏液风险（几率很小，并且品牌方一般会提供漏液包赔的服务）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>分体式水冷</p>
<ul>
<li>
<p>你可以自行选择水泵，冷头，冷排和水管</p>
<ul>
<li>
<p>硬管</p>
<ul>
<li>分体式硬管水冷</li>
</ul>
</li>
<li>
<p>软管</p>
<ul>
<li>分体式软管水冷</li>
</ul>
</li>
<li>
<p>工作原理和一体式水冷完全一致</p>
</li>
</ul>
</li>
<li>
<p>成品好看，客制化高，可玩性高，漏液风险大</p>
</li>
<li>
<p>非常美观，并且散热能力远超一体式水冷</p>
</li>
<li>
<p>一整套下来至少2000-3000元</p>
</li>
</ul>
</li>
<li>
<p>被动散热器</p>
<ul>
<li>少见</li>
</ul>
</li>
<li>
<p>挤铝下压式散热器</p>
<ul>
<li>适合压制功耗较低的CPU</li>
</ul>
</li>
</ul>
<h3 id="机箱风扇"><a class="header-anchor" href="#机箱风扇">¶</a>机箱风扇</h3>
<ul>
<li>
<p>转速控制种类</p>
<ul>
<li>DC（通过控制供给给风扇的电压来调整转速）</li>
<li>PWM（调整占空比来控制转速）</li>
</ul>
</li>
<li>
<p>常见的几种风扇</p>
<ul>
<li>
<p>定速扇（采用大4PIN供电）</p>
<ul>
<li>无法控制转速但兼容性最佳</li>
<li>价格低但不推荐</li>
</ul>
</li>
<li>
<p>非定速扇</p>
<ul>
<li>
<p>小3PIN接口风扇</p>
<ul>
<li>只能使用DC调整电压来控制转速</li>
<li>可以接到小4PIN接口使用（只能用DC调速）</li>
<li>新装机不推荐</li>
</ul>
</li>
<li>
<p>小4PIN风扇（可以使用PWM调速）</p>
<ul>
<li>相较于小3PIN 多了一根PWM调速线</li>
<li>可以接到小3PIN接口上使用（此时无PWM功能）</li>
</ul>
</li>
<li>
<p>私有接口风扇</p>
<ul>
<li>只能接在厂商指定的集线器上使用</li>
<li>方便走线但价格偏高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>RGB扇</p>
<ul>
<li>
<p>灯光与风扇共同一根线的</p>
<ul>
<li>但灯光不可控制且关不掉</li>
</ul>
</li>
<li>
<p>12V 4PIN</p>
<ul>
<li>一次只能显示一种颜色但是能通过主板统一控制</li>
</ul>
</li>
<li>
<p>5V 3PIN（最好）</p>
<ul>
<li>
<p>也叫ARGB</p>
<ul>
<li>可以同时显示多种颜色可同步</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>关于机箱风扇的参数</p>
<ul>
<li>
<p>风量（CFM）</p>
<ul>
<li>超过70CFM属于大风量</li>
<li>此类风扇建议放在机箱顶部和尾部</li>
</ul>
</li>
<li>
<p>风压（mm H2O）</p>
<ul>
<li>超过2mmH2O属于大风压</li>
<li>建议放在机箱前部</li>
</ul>
</li>
<li>
<p>轴承类型</p>
<ul>
<li>
<p>含油轴承</p>
<ul>
<li>低</li>
</ul>
</li>
<li>
<p>液压轴承</p>
<ul>
<li>中</li>
</ul>
</li>
<li>
<p>FDB轴承</p>
<ul>
<li>中</li>
</ul>
</li>
<li>
<p>来福轴承</p>
<ul>
<li>中</li>
</ul>
</li>
<li>
<p>SSO轴承</p>
<ul>
<li>很高</li>
</ul>
</li>
<li>
<p>双滚珠轴承</p>
<ul>
<li>高</li>
</ul>
</li>
<li>
<p>磁浮轴承</p>
<ul>
<li>很高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="外设"><a class="header-anchor" href="#外设">¶</a>外设</h2>
<h3 id="显示器"><a class="header-anchor" href="#显示器">¶</a>显示器</h3>
<ul>
<li>
<p>色域（显示器能显示颜色丰富度的概念）</p>
<ul>
<li>
<p>你需要了解色域马蹄图</p>
</li>
<li>
<p>常见的色彩空间</p>
<ul>
<li>
<p>sRGB</p>
<ul>
<li>100%sRGB色域的显示器在当下可以给你最好体验</li>
</ul>
</li>
<li>
<p>NTSC</p>
</li>
<li>
<p>Adobe RGB</p>
</li>
<li>
<p>DCI-P3</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>色准（用△E表示）</p>
<ul>
<li>
<p>越小代表色准越高</p>
<ul>
<li>
<p>平均△ E值</p>
</li>
<li>
<p>最高△ E值</p>
</li>
<li>
<p>常见数值及其意义</p>
<ul>
<li>
<p>≤ 1·5</p>
<ul>
<li>
<p>色准极好</p>
<ul>
<li>
<p>S级</p>
<ul>
<li>物理意义上几乎不存在色偏</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>1·5-3</p>
<ul>
<li>
<p>非常优秀</p>
<ul>
<li>
<p>A级</p>
<ul>
<li>肉眼极难看出色偏</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>3-5</p>
<ul>
<li>
<p>优秀</p>
<ul>
<li>
<p>B级</p>
<ul>
<li>日常使用几乎不会有影响</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>5-8</p>
<ul>
<li>
<p>普通</p>
<ul>
<li>
<p>C级</p>
<ul>
<li>色彩敏感的人可以看出偏色</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>＞8</p>
<ul>
<li>
<p>很差</p>
<ul>
<li>
<p>D级</p>
<ul>
<li>大部分人都能看出些微的偏色</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>色深</p>
<ul>
<li>
<p>表达为2 ^？（bit）</p>
<ul>
<li>
<p>6bit指2 ^6</p>
<ul>
<li>
<p>有64个色彩过渡的阶梯</p>
<ul>
<li>
<p>大约能显示26·2万色</p>
<ul>
<li>不建议购买</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8bit指2 ^8，有256个色彩过渡的阶梯</p>
<ul>
<li>大约能显示1680万色</li>
</ul>
</li>
<li>
<p>10bit指2 ^10，有1024个色彩过渡的阶梯</p>
<ul>
<li>大约能显示10·7亿色</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据</p>
<ul>
<li>
<p>6bit</p>
<ul>
<li>
<p>平滑色彩过渡会出现断层</p>
<ul>
<li>不推荐</li>
</ul>
</li>
</ul>
</li>
<li>
<p>6抖8</p>
<ul>
<li>
<p>细看会有静态噪点</p>
<ul>
<li>还凑合</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8bit</p>
<ul>
<li>
<p>够用不贵，性价比高</p>
<ul>
<li>推荐</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8抖10</p>
<ul>
<li>
<p>几乎看不到静态噪点</p>
<ul>
<li>高色深需求推荐</li>
</ul>
</li>
</ul>
</li>
<li>
<p>10bit</p>
<ul>
<li>
<p>价格较贵</p>
<ul>
<li>土豪推荐</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用N卡的小伙伴们一定记得要在驱动面板-显示-更改分辨率里面，将‘’输出动态范围‘’调整到最大</p>
</li>
</ul>
</li>
<li>
<p>类型</p>
<ul>
<li>
<p>原生（效果最好）</p>
</li>
<li>
<p>FRC像素点抖动技术</p>
<ul>
<li>利用人眼视觉暂留效应在两种颜色之间切换达到的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>分辨率</p>
<ul>
<li>
<p>常见分辨率</p>
<ul>
<li>1080P（1920x1080）</li>
<li>1440P或2K（2560x1440）</li>
<li>2160P或4K（3840x2160）</li>
<li>4320P或8K（7680x4320）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>像素密度（ppi）</p>
</li>
<li>
<p>刷新率</p>
<ul>
<li>
<p>常见刷新率</p>
<ul>
<li>
<p>60Hz</p>
<ul>
<li>办公够用，最常见，价格便宜</li>
</ul>
</li>
<li>
<p>75Hz</p>
</li>
<li>
<p>120Hz</p>
</li>
<li>
<p>144Hz</p>
<ul>
<li>普通用户首选</li>
</ul>
</li>
<li>
<p>165Hz</p>
</li>
<li>
<p>240Hz</p>
</li>
<li>
<p>360Hz</p>
<ul>
<li>非极致FPS用户最好不要选</li>
</ul>
</li>
</ul>
</li>
<li>
<p>特殊</p>
<ul>
<li>
<p>英伟达：G- SYNC技术</p>
<ul>
<li>根据显卡输出帧数实时调整显示器刷新率，无撕裂感但价格较贵</li>
</ul>
</li>
<li>
<p>AMD：Free Sync技术</p>
<ul>
<li>和英伟达类似，能够解决画面撕裂以及卡顿问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>尺寸</p>
<ul>
<li>
<p>尺寸（英寸）</p>
<ul>
<li>
<p>建议</p>
<ul>
<li>24英寸选1080P</li>
<li>27英寸选2K</li>
<li>34英寸选4K</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>长宽比</p>
<ul>
<li>16:9（最普遍，最均衡）</li>
<li>21:9（游戏体验更佳，办公体验更好，浏览网页可能会出现大面积白边）</li>
</ul>
</li>
<li>
<p>面板类型</p>
<ul>
<li>
<p>TN</p>
<ul>
<li>仅适用于极限FPS玩家</li>
</ul>
</li>
<li>
<p>VA</p>
<ul>
<li>价格便宜但拖影严重，建议先体验后购买</li>
</ul>
</li>
<li>
<p>IPS</p>
<ul>
<li>性能均衡，适用于绝大多数情况，价格高于TN和VA</li>
</ul>
</li>
<li>
<p>OLED</p>
<ul>
<li>拥有超高对比度，可以显示极致的黑色，和极亮的白色，但因为发光材料属于有机物，长时间高亮度显示同一画面会烧屏，不可逆，价格略贵于IPS</li>
</ul>
</li>
</ul>
</li>
<li>
<p>屏幕类型</p>
<ul>
<li>
<p>直屏</p>
<ul>
<li>最常见</li>
</ul>
</li>
<li>
<p>曲屏</p>
<ul>
<li>打游戏会更有沉浸感，建议买前先体验</li>
</ul>
</li>
</ul>
</li>
<li>
<p>响应时间</p>
<ul>
<li>
<p>黑白响应时间（逐渐被淘汰）</p>
</li>
<li>
<p>灰阶响应时间（GTG）</p>
<ul>
<li>
<p>ULMB</p>
<ul>
<li>
<p>在像素点切换过程中插入黑场降低拖影（MPRT）会导致屏幕显示偏暗</p>
<ul>
<li>华硕叫做ELMB</li>
<li>卓威叫Dync+</li>
</ul>
</li>
</ul>
</li>
<li>
<p>OD（OverDrive）</p>
<ul>
<li>
<p>提高电压来加快液晶分子偏转速度减小响应时间</p>
<ul>
<li>具有此功能的显示器建议开标准档位</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>亮度（HDR)</p>
<ul>
<li>
<p>SDR（标准动态范围）</p>
</li>
<li>
<p>HDR（高动态范围）</p>
<ul>
<li>HDR400（最好别碰这个）</li>
<li>HDR500</li>
<li>HDR600</li>
<li>HDR1000</li>
<li>HDR1400</li>
<li>HDR400 True Black</li>
<li>HDR500 True Black</li>
</ul>
</li>
<li>
<p>XDR（极致动态范围）</p>
</li>
</ul>
</li>
<li>
<p>传输线材（扩展知识）</p>
<ul>
<li>
<p>VGA</p>
<ul>
<li>
<p>传输模拟信号</p>
<ul>
<li>画面传输质量不高，不能传输声音信号，不支持热插拔，不建议选择</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DVI</p>
<ul>
<li>
<p>DVI-I单通道</p>
<ul>
<li>
<p>可传输数字及模拟信号</p>
<ul>
<li>1920x1200（60Hz）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DVI-I双通道</p>
<ul>
<li>
<p>可传输数字信号及模拟信号</p>
<ul>
<li>1920x1200（120Hz）</li>
<li>2560x1600（60Hz）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DVI-D单通道</p>
<ul>
<li>
<p>仅传输数字信号</p>
<ul>
<li>1920x1200（60Hz）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DVI-D双通道</p>
<ul>
<li>
<p>仅传输数字信号</p>
<ul>
<li>1920x1080（120Hz）</li>
<li>2560x1600（60Hz）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DVI-A</p>
<ul>
<li>仅传输模拟信号</li>
</ul>
</li>
</ul>
</li>
<li>
<p>HDMI</p>
<ul>
<li>
<p>传输数字信号</p>
<ul>
<li>
<p>HDMI 2·0</p>
<ul>
<li>带宽：18Gbit/s</li>
<li>1080P 144Hz（未压缩）</li>
<li>2K 100Hz（未压缩）</li>
<li>4K 50Hz（未压缩）</li>
<li>4K 60Hz（压缩）</li>
</ul>
</li>
<li>
<p>HDMI 2·1</p>
<ul>
<li>带宽：48Gbit/s</li>
<li>1080P 240Hz（未压缩）</li>
<li>2K 240Hz（未压缩）</li>
<li>4K 144Hz（未压缩）</li>
<li>5K 60Hz（未压缩）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DP</p>
<ul>
<li>
<p>传输数字信号</p>
<ul>
<li>
<p>DP 1·2</p>
<ul>
<li>带宽：21·6Gbit/s</li>
<li>1080P 200+Hz（未压缩）</li>
<li>2K 144Hz（未压缩）</li>
<li>4K 60Hz（未压缩）</li>
</ul>
</li>
<li>
<p>DP 1·4</p>
<ul>
<li>带宽：32·4Gbit/s</li>
<li>1080P 240Hz（未压缩）</li>
<li>2K 240Hz（未压缩）</li>
<li>4K 120Hz（未压缩）</li>
<li>5K 60Hz（未压缩）</li>
</ul>
</li>
<li>
<p>DP 2·0</p>
<ul>
<li>带宽：80Gbit/s</li>
<li>8K 120Hz</li>
<li>16K 60Hz</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>长度</p>
<ul>
<li>
<p>3M以内没必要买贵的</p>
</li>
<li>
<p>5-8M要用料更好的线材</p>
</li>
<li>
<p>AWG</p>
<ul>
<li>30AWG（管道里可以塞进30根线，下同）</li>
<li>28AWG</li>
<li>26AWG</li>
<li>24AWG</li>
<li>越低越好</li>
</ul>
</li>
<li>
<p>用多少卖多少，最好不要有预留的量</p>
</li>
</ul>
</li>
<li>
<p>电视/投影选择它</p>
</li>
<li>
<p>电脑优先选它</p>
</li>
</ul>
</li>
</ul>
<h3 id="键盘"><a class="header-anchor" href="#键盘">¶</a>键盘</h3>
<ul>
<li>
<p>轴体</p>
<ul>
<li>
<p>机械轴</p>
<ul>
<li>
<p>类型</p>
<ul>
<li>
<p>青轴</p>
<ul>
<li>
<p>触发力量60克左右</p>
<ul>
<li>
<p>段落轴</p>
<ul>
<li>适用文字工作者，打游戏也可以但极不适合公共场合使用，小心被削</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>黑轴</p>
<ul>
<li>
<p>触发力量80克左右</p>
<ul>
<li>
<p>非段落轴</p>
<ul>
<li>适合手重的游戏玩家或文字工作者，不适合手劲儿轻的朋友</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>茶轴</p>
<ul>
<li>
<p>触发力量40-60克</p>
<ul>
<li>
<p>段落轴</p>
<ul>
<li>适合RTS类游戏，万能轴，声音和清脆程度不如青轴，个人认为不适合类DOTA游戏</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>红轴</p>
<ul>
<li>
<p>触发力量35-60克</p>
<ul>
<li>
<p>非段落轴</p>
<ul>
<li>
<p>和黑轴类似</p>
<ul>
<li>性能综合，声音较小，适合长时间码字的文字工作者手劲儿轻的朋友，不适合RTS类游戏</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>其它方面</p>
<ul>
<li>寿命在2000万到6000万次左右</li>
<li>价格较贵，通常为平均4-10元一个轴</li>
<li>手感比薄膜键盘更好</li>
</ul>
</li>
</ul>
</li>
<li>
<p>薄膜键盘</p>
</li>
</ul>
</li>
<li>
<p>键帽</p>
<ul>
<li>
<p>键帽材质</p>
<ul>
<li>
<p>ABS</p>
<ul>
<li>优点：手感好</li>
<li>缺点：不耐用，沾指纹，易打油</li>
</ul>
</li>
<li>
<p>PBT</p>
<ul>
<li>优点：磨砂质感，耐用，不易沾指纹</li>
<li>缺点：干涩，不易加工</li>
</ul>
</li>
</ul>
</li>
<li>
<p>键帽字符工艺</p>
<ul>
<li>
<p>二色成型</p>
<ul>
<li>耐磨损</li>
<li>可做透光</li>
</ul>
</li>
<li>
<p>热升华</p>
<ul>
<li>耐磨损</li>
<li>个性化</li>
</ul>
</li>
<li>
<p>喷墨镭雕</p>
<ul>
<li>透光好</li>
<li>便宜，不耐磨</li>
</ul>
</li>
<li>
<p>镭雕</p>
<ul>
<li>便宜，字体易发黑</li>
</ul>
</li>
<li>
<p>丝印</p>
<ul>
<li>便宜，不耐磨</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>按键数量（键盘尺寸）</p>
<ul>
<li>
<p>100%尺寸（104或108键或再增加功能键的）</p>
<ul>
<li>台式机搭配最建议</li>
</ul>
</li>
<li>
<p>85%尺寸（96键或者92键，这种是去掉了光标键区）</p>
</li>
<li>
<p>80%尺寸（87键，这种是去掉了小键盘区）</p>
</li>
<li>
<p>75%尺寸（82键或者76键，这种是将几个光标键整合进了主键区）</p>
</li>
<li>
<p>60%尺寸（61键，就剩下主键盘了）</p>
</li>
</ul>
</li>
</ul>
<h3 id="鼠标"><a class="header-anchor" href="#鼠标">¶</a>鼠标</h3>
<ul>
<li>
<p>大小</p>
<ul>
<li>手长＜18·5cm最好选择115-120mm鼠标</li>
<li>手长＞18·5cm最好选择 120-127mm鼠标</li>
</ul>
</li>
<li>
<p>类型</p>
<ul>
<li>
<p>捏握（只有手指头接触鼠标，手掌不接触鼠标）</p>
<ul>
<li>适合左右对称的鼠标</li>
</ul>
</li>
<li>
<p>抓握（手指和手掌部分接触鼠标，但不全部接触）</p>
<ul>
<li>适合左右对称的鼠标</li>
</ul>
</li>
<li>
<p>趴握（整个手放松的趴在鼠标上，手指和手掌与鼠标完全接触）</p>
<ul>
<li>建议选择右手工程学鼠标</li>
</ul>
</li>
</ul>
</li>
<li>
<p>材质</p>
<ul>
<li>
<p>镜面</p>
<ul>
<li>外观：好（因人而异）</li>
<li>手感：一般</li>
<li>容易清洁</li>
<li>容易沾染手汗</li>
</ul>
</li>
<li>
<p>类肤</p>
<ul>
<li>外观：较好（因人而异）</li>
<li>手感：极好</li>
<li>类肤涂层容易磨损</li>
<li>容易沾染手汗和指纹</li>
</ul>
</li>
<li>
<p>塑料磨砂</p>
<ul>
<li>外观：一般（因人而异）</li>
<li>手感：一般</li>
<li>防手汗能力较好</li>
<li>用起来比较干爽</li>
</ul>
</li>
</ul>
</li>
<li>
<p>鼠标重量（前后部分重量要平均）</p>
<ul>
<li>＞120g属于“习武之人”</li>
<li>110g属于长时间使用的上限</li>
<li>80-100g是鼠标最佳重量</li>
</ul>
</li>
<li>
<p>硬件</p>
<ul>
<li>
<p>DPI</p>
<ul>
<li>你的鼠标移动一英寸（2·54cm），电脑上鼠标会移动多少个像素点，越高越灵敏，常在400-3000之间</li>
</ul>
</li>
<li>
<p>IPS</p>
<ul>
<li>假设有400IPS，那么你以400英寸每秒（10·16m/s）移动鼠标的话，鼠标会因为移动太快反应不过来。日常使用60IPS完全够</li>
</ul>
</li>
<li>
<p>回报率</p>
<ul>
<li>
<p>鼠标每秒与电脑沟通次数（500Hz足矣）</p>
<ul>
<li>1000Hz就是1毫秒可以与电脑沟通一次，虽然会更精准的还原手部动作，但同时也会加重CPU负担</li>
</ul>
</li>
</ul>
</li>
<li>
<p>传感器（引擎）</p>
<ul>
<li>
<p>顶级</p>
<ul>
<li>PMW3360/PMW3366/PMW3389/PAW3390/PAW3391/True Move3/Hero/owl-eye</li>
</ul>
</li>
<li>
<p>够用</p>
<ul>
<li>Mercury/PWM3310/PWM3330/PMW3336/PMW3339/True Move1</li>
</ul>
</li>
</ul>
</li>
<li>
<p>板载内存</p>
<ul>
<li>板载内存可以将自定义鼠标参数保存，更换电脑也不用再次修改</li>
</ul>
</li>
</ul>
</li>
<li>
<p>品牌</p>
<ul>
<li>
<p>罗技（Logitech）</p>
<ul>
<li>无线技术优异，性能高，功耗低，无线鼠标行业无人能敌</li>
</ul>
</li>
<li>
<p>雷蛇（RAZER）</p>
<ul>
<li>性能强，手感好，模具经典，线材软</li>
</ul>
</li>
<li>
<p>赛睿（stellseries）</p>
<ul>
<li>性能一般，手感好，EC系列被多数CSGO职业玩家使用，仅适合FPS游戏</li>
</ul>
</li>
<li>
<p>卓威</p>
</li>
<li>
<p>冰豹</p>
</li>
<li>
<p>ROG（玩家国度）</p>
</li>
<li>
<p>海盗船（CORSAIR）</p>
</li>
<li>
<p>鼠标三大厂</p>
</li>
</ul>
</li>
</ul>
<h3 id="机箱"><a class="header-anchor" href="#机箱">¶</a>机箱</h3>
<ul>
<li>
<p>按大小分类</p>
<ul>
<li>
<p>全塔机箱</p>
<ul>
<li>体积特别大，内部空间宽松</li>
<li>一般比较贵</li>
<li>兼容消费级几乎所有配件</li>
</ul>
</li>
<li>
<p>中塔机箱</p>
<ul>
<li>市场上主流机箱</li>
<li>一般可以兼容主流消费及配件</li>
<li>大小一般适中</li>
</ul>
</li>
<li>
<p>mini机箱（非特殊需求否则不建议选择）</p>
<ul>
<li>比较小</li>
<li>一般只能兼容体积较小的配件</li>
<li>大多数itx机箱（mini机箱）只能兼容itx配件和sfx电源</li>
</ul>
</li>
</ul>
</li>
<li>
<p>兼容性</p>
<ul>
<li>
<p>请在购买前在详情页查看机箱支持的各个部件大小（非常重要‼️）</p>
<ul>
<li>主板类型</li>
<li>电源支持</li>
<li>散热器高度/水冷尺寸支持（不要与机箱风扇兼容性搞混）</li>
<li>显卡长度支持</li>
<li>硬盘位</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用料方面</p>
<ul>
<li>
<p>板材厚度</p>
<ul>
<li>0.7mm左右既为合理</li>
<li>0.8mm厚度一般用在比较贵的机箱上</li>
<li>板材太薄容易震动和发出异响（百元左右价位的侧透机箱还是不要考虑了）</li>
</ul>
</li>
<li>
<p>侧透用料</p>
<ul>
<li>
<p>亚克力侧透</p>
<ul>
<li>成本较低</li>
<li>没有爆炸的风险</li>
<li>透明度远低于钢化玻璃</li>
</ul>
</li>
<li>
<p>钢化玻璃侧透</p>
<ul>
<li>容易爆炸，不建议选择</li>
</ul>
</li>
<li>
<p>钢化玻璃保护</p>
<ul>
<li>尽量选择它，爆炸风险低</li>
</ul>
</li>
</ul>
</li>
<li>
<p>接口扩展性</p>
<ul>
<li>
<p>2个USB 3.0接口还得是有的，Type- C接口按需选择</p>
</li>
<li>
<p>开机键位置</p>
<ul>
<li>
<p>前顶部设计</p>
<ul>
<li>放桌子底下时容易开机，但在桌子上就不太方便</li>
</ul>
</li>
<li>
<p>右顶部设计</p>
<ul>
<li>方便理线，在桌子底下时方便开机</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>散热风道</p>
<ul>
<li>前方和下方进冷风，上方和后方出热风最为合理（也就是风扇logo面通常为进风，后面风扇的logo应该朝内，顶部风扇logo应该朝下）</li>
<li>CPU塔式散热器风扇应该朝向右侧的内存</li>
<li>需要注意机箱支持的风扇尺寸及数量</li>
<li>itx机箱散热性能会差点</li>
</ul>
</li>
<li>
<p>走线设计</p>
<ul>
<li>有美化面板的机箱对理线更友好</li>
</ul>
</li>
<li>
<p>显卡竖装设计</p>
</li>
</ul>
</li>
</ul>
<h2 id="图片版"><a class="header-anchor" href="#图片版">¶</a>图片版</h2>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E5%AE%B6%E7%94%A8%E5%8F%B0%E5%BC%8F%E7%94%B5%E8%84%91.1szirbtytruo.jpg" alt="家用台式电脑"></p>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<ul>
<li>
<p>Hz指一秒钟之内图像刷新次数</p>
</li>
<li>
<p>P代表逐行扫描，i代表隔行扫描，也就是纵向有多少个像素点</p>
</li>
<li>
<p>93%DCI-P3意味着它可以显示出DCI-P3色彩空间中93的色彩，上同</p>
</li>
<li>
<p>猫头鹰风扇比较奇葩，要除以1.7</p>
</li>
<li>
<p>100%sRGB大约等于79·6%DCI-P3色域</p>
</li>
<li>
<p>顶级风冷（例如利民IBE，价格599元）在风道良好的情况下其散热能力完全不输360mm一体水冷</p>
</li>
<li>
<p>如果你希望机箱内整洁漂亮一点或玩玩RGB这种，最好选择一体式水冷而不是风冷</p>
</li>
<li>
<p>同价格情况下，风冷比水冷略强一点</p>
</li>
<li>
<p>了解更多显卡性能及排行，请点击<a href="http://tieba.baidu.com/p/6133450546?&amp;share=9105&amp;fr=sharewise&amp;unique=8D486AD716562FFDD25B53CE8CA3E3C9&amp;st=1634817550&amp;client_type=1&amp;client_version=12.11.1&amp;sfc=copy&amp;share_from=post">链接</a></p>
</li>
<li>
<p>厂家标注的x ms响应时间已经不具备任何参考价值</p>
</li>
<li>
<p>电压过高会出现伪影和鬼影，再此条件下的测试也不具备参考价值</p>
</li>
<li>
<p>视各个硬件具体情况您在购买时请先与客服人员询问</p>
</li>
<li>
<p>编辑者：国航Fly</p>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>硬件DIY</category>
      </categories>
      <tags>
        <tag>PC</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统前后需要完成的事情</title>
    <url>/2024/07/15/86baf1ab0f95/</url>
    <content><![CDATA[<h2 id="重装系统之前备份"><a class="header-anchor" href="#重装系统之前备份">¶</a>重装系统之前备份</h2>
<p>在重装系统之前需要备份的重要文件</p>
<span id="more"></span>
<ol>
<li>
<p>备份浏览器插件（以chrome为例）<br>
插件安装本地地址：C:\Users\主机名\AppData\Local\Google\Chrome\User Data\Default\Extensions<br>
这里会有一堆文件夹，其文件夹名对应的是插件的ID<br>
点开Chrome-拓展程序-打包拓展程序-选择拓展程序根目录<br>
这里需要打包的是点开上文文件夹打包里面的版本号文件夹<br>
然后就会生成crx文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%89%8D%E5%90%8E%E9%9C%80%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E4%BA%8B%E6%83%851.2vftry58mri0.png" alt="重装系统前后需要完成的事情1"><br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%89%8D%E5%90%8E%E9%9C%80%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E4%BA%8B%E6%83%852.4c6pe9397jq0.webp" alt="重装系统前后需要完成的事情2"></p>
</li>
<li>
<p>备份桌面文件、C盘文档文件夹、图片文件夹、视频文件夹</p>
</li>
<li>
<p>截图备份：桌面图标位置、快速访问文件夹、开始菜单快捷方式</p>
</li>
<li>
<p>保存油猴脚本中的脚本（打包导出到本地）</p>
</li>
<li>
<p>参考<a href="https://blog.hiyoung.xyz/2022/10/08/5c79848f3e3d/">装机软件</a>恢复常用软件</p>
</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>PC</category>
        <category>重装系统</category>
      </categories>
      <tags>
        <tag>重装系统</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2022/11/06/c5a69b4469b3/</url>
    <content><![CDATA[<h2 id="简介-v2"><a class="header-anchor" href="#简介-v2">¶</a>简介</h2>
<ol>
<li>定义<br>
正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为&quot;元字符&quot;）组成的文字模式。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配</li>
</ol>
<span id="more"></span>
<ol start="2">
<li>为什么使用正则</li>
</ol>
<ul>
<li>
<p>测试字符串内的模式<br>
例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证</p>
</li>
<li>
<p>替换文本<br>
可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它</p>
</li>
<li>
<p>基于模式匹配从字符串中提取子字符串<br>
可以查找文档内或输入域内特定的文本</p>
</li>
</ul>
<h2 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h2>
<h3 id="普通字符"><a class="header-anchor" href="#普通字符">¶</a>普通字符</h3>
<p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号</p>
<table>
<tr>
    <th>字符</th>   <th>描述</th>
</tr>
<tr>
    <td><strong>[ABC]</strong></td>  
    <td>匹配 [...] 中的所有字符，例如 [aeiou] 匹配字符串 "google runoob taobao" 中所有的 e o u a 字母</td>
</tr>
<tr>
    <td><strong>[^ABC]</strong></td> 
    <td>匹配除 [...] 中的所有字符</td>
</tr>
<tr>
    <td><strong>[A-Z]/[a-z]</strong></td>  
    <td>[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母</td>
</tr>
<tr>
    <td><strong>.</strong></td>  
    <td>匹配除换行符(\n、\r)外的所有单个字符, 相当于[^\n\r] </td>
</tr>
<tr>
    <td><strong>[\s] [\S]</strong></td>  
    <td>\s是匹配所有空白符,包含换行  \S匹配非空白符,不包括换行  [\s\S]是匹配所有</td>
</tr>
<tr>
    <td><strong>\w</strong></td>  
    <td>匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</td>
</tr>
</table>
<h3 id="非打印字符"><a class="header-anchor" href="#非打印字符">¶</a>非打印字符</h3>
<table>
<tr>
    <th width="10%">字符</th>   <th width="90%">描述</th>
</tr>
<tr>
    <td><strong>\f</strong></td>
    <td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
    <td><strong>\n</strong></td>
    <td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
    <td><strong>\r</strong></td>
    <td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
    <td><strong>\s</strong></td>
    <td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
    <td><strong>\S</strong></td>
    <td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
    <td><strong>\t</strong></td>
    <td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
    <td><strong>\v</strong></td>
    <td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</table>
<h3 id="特殊字符"><a class="header-anchor" href="#特殊字符">¶</a>特殊字符</h3>
<p>若要匹配这些特殊字符，必须首先使字符&quot;转义&quot;，即，将反斜杠字符\ 放在它们前面。</p>
<table><table>
    <tbody><tr>
        <th width="20%">特别字符</th>
        <th width="80%">描述</th>
    </tr>
    <tr>
        <td><strong>$</strong></td>
        <td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。</td>
    </tr>
    <tr>
        <td><strong>( )</strong></td>
        <td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。</td>
    </tr>
    <tr>
        <td><strong>*</strong></td>
        <td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。</td>
    </tr>
    <tr>
        <td><strong>+</strong></td>
        <td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。</td>
    </tr>
    <tr>
        <td><strong>.</strong></td>
        <td>匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。</td>
    </tr>
    <tr>
        <td><strong>[</strong></td>
        <td>标记一个中括号表达式的开始。要匹配 [，请使用 \[。</td>
    </tr>
    <tr>
        <td><strong>?</strong></td>
        <td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</td>
    </tr>
    <tr>
        <td><strong>\</strong></td>
        <td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。</td>
    </tr>
    <tr>
        <td><strong>^</strong></td>
        <td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。</td>
    </tr>
    <tr>
        <td><strong>{</strong></td>
        <td>标记限定符表达式的开始。要匹配 {，请使用 \{。</td>
    </tr>
    <tr>
        <td><strong>|</strong></td>
        <td>指明两项之间的一个选择。要匹配 |，请使用 \|。</td>
    </tr>
    </tbody></table>
<h3 id="限定符"><a class="header-anchor" href="#限定符">¶</a>限定符</h3>
<p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p>
<table>
<tbody><tr>
    <th width="20%">字符</th>
    <th width="80%">描述</th>
    </tr>
<tr>
    <td><strong>*</strong></td>
    <td>匹配前面的子表达式零次或多次。例如，<strong >zo*</strong> 能匹配 <strong>"z"</strong> 以及 <strong>"zoo"</strong>。<strong >*</strong> 等价于 <strong >{0,}</strong>。</td>
</tr>
<tr>
    <td><strong>+</strong></td>
    <td>匹配前面的子表达式一次或多次。例如，<strong >zo+</strong> 能匹配 <strong>"zo"</strong> 以及 "<strong>zoo"</strong>，但不能匹配 <strong>"z"</strong>。<strong >+</strong> 等价于 <strong >{1,}</strong>。</td>
</tr>
<tr>
    <td><strong>?</strong></td>
    <td><p>匹配前面的子表达式零次或一次。例如，<strong >do(es)?</strong>  可以匹配 <strong>"do"</strong> 、 <strong>"does"</strong>、 <strong>"doxy"</strong> 中的 <strong>"do"</strong> 。<strong >?</strong> 等价于 <strong >{0,1}</strong>。</p>
</td>
</tr>
<tr>
    <td><strong>{n}</strong></td>
    <td>n 是一个非负整数。匹配确定的 <strong>n</strong> 次。例如，<strong >o{2}</strong> 不能匹配 <strong>"Bob"</strong> 中的 <strong>o</strong>，但是能匹配 <strong>"food"</strong> 中的两个 <strong>o</strong>。</td>
</tr>
<tr>
    <td> <strong>{n,}</strong> </td>
    <td>n 是一个非负整数。至少匹配n 次。例如，<strong >o{2,}</strong> 不能匹配 <strong>"Bob"</strong> 中的 <strong>o</strong>，但能匹配 <strong>"foooood"</strong> 中的所有 <strong>o</strong>。<strong >o{1,}</strong> 等价于 <strong >o+</strong>。<strong >o{0,}</strong> 则等价于 <strong >o*</strong>。</td>
</tr>
<tr>
    <td><strong>{n,m}</strong></td>
    <td>m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，<strong >o{1,3}</strong> 将匹配 <strong>"fooooood"</strong> 中的前三个 <strong>o</strong>。<strong >o{0,1}</strong> 等价于 <strong >o?</strong>。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<hr>
<ol>
<li>Example：</li>
</ol>
<p>以下正则表达式匹配一个正整数，<code>[1-9]</code>设置第一个数字不是 0，<code>[0-9]*</code> 表示任意多个数字：</p>
<p><code>[1-9][0-9]*</code></p>
<ol start="2">
<li>
<p><strong>* 和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配</strong></p>
<p>贪婪:下面的表达式匹配从开始小于符号 (&lt;) 到关闭 h1 标记的大于符号 (&gt;) 之间的所有内容。<br>
<code>&lt;.*&gt;</code><br>
非贪婪:如果只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配 &lt; h1 &gt;<br>
<code>&lt;.*?&gt;</code></p>
</li>
</ol>
<p>通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从&quot;贪婪&quot;表达式转换为&quot;非贪婪&quot;表达式或者最小匹配。</p>
<hr>
<h3 id="定位符"><a class="header-anchor" href="#定位符">¶</a>定位符</h3>
<table>
<tbody><tr>
	<th width="20%">字符</th>
	<th width="80%">描述</th>
</tr>
<tr>
	<td><strong>^</strong></td>
    <td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
	<td><strong>$</strong></td>
    <td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
	<td><strong>\b</strong></td>
    <td>匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
	<td><strong>\B</strong></td>
    <td>非单词边界匹配。</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 <strong>^*</strong> 之类的表达式。</p>
<p>若要匹配一行文本开始处的文本，在正则表达式的开始使用 <strong>^</strong> 字符。不要将 <strong>^</strong> 的这种用法与中括号表达式内的用法混淆([^ABC]表示除[…]中的所有字符)</p>
<p>若要匹配一行文本的结束处的文本，则在正则表达式的结束处使用 <strong>$</strong> 字符。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>系统学习Linux笔记</title>
    <url>/2022/08/01/84a03702e5a9/</url>
    <content><![CDATA[<p><strong>笔记中命令在无特殊说明情况下以CentOS 7为准</strong></p>
<p>（参考视频：<a rel="noreferrer noopener" href="https://www.bilibili.com/video/BV1WY4y1H7d3?p=1" target="\_blank">https://www.bilibili.com/video/BV1WY4y1H7d3?p=1</a>）</p>
<span id="more"></span>
<h2 id="一-基础篇">一、基础篇</h2>
<h3 id="1-1-linux文件系统目录结构">1.1 Linux文件系统目录结构</h3>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Linux%E7%AC%94%E8%AE%B0_1.12hb12rw6m28.jpg" alt="系统学习Linux笔记_1"><br>
<a href="https://www.runoob.com/linux/linux-system-contents.html" data-type="URL" data-id="https://www.runoob.com/linux/linux-system-contents.html">来源：菜鸟教程</a></figcaption></figure></p>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Linux%E7%AC%94%E8%AE%B0_2.6iyv14qs1kc0.jpg" alt="系统学习Linux笔记_2"></p>
<figcaption>图中小箭头表示该文件实际位置在别处</figcaption>
<ul><li><strong>/bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</li><li><strong>/boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><strong>/dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li><strong>/home</strong>：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</li><li><strong>/lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</li><li><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li><strong>/media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</li><li><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</li><li><strong>/opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：echo 1 &gt; /proc/sys/net/ipv4/icmp\_echo\_ignore\_all</li><li><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><strong>/sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</li><li><strong>/selinux</strong>：<br>&nbsp;这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</li><li><strong>/srv</strong>：<br>&nbsp;该目录存放一些服务启动之后需要提取的数据。</li><li><strong>/sys</strong>：这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统&nbsp;sysfs&nbsp;。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</li><li><strong>/tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</li><li><strong>/usr</strong>：<br>&nbsp;usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</li><li><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</li><li><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</li><li><strong>/var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</li></ul>
<h3 id="1-2-文件基本属性">1.2 文件基本属性</h3>
<h4 id="1-2-1-基本属性">1.2.1 基本属性</h4>
<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<ul><li>当为&nbsp;<strong>d</strong>&nbsp;则是目录</li><li>当为&nbsp;<strong>-</strong>&nbsp;则是文件；</li><li>若是&nbsp;<strong>l</strong>&nbsp;则表示为链接文档(link file)；</li><li>若是&nbsp;<strong>b</strong>&nbsp;则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是&nbsp;<strong>c</strong>&nbsp;则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul>
<p>接下来的字符中，以三个为一组，且均为&nbsp;<strong>rwx</strong>&nbsp;的三个参数的组合。其中，&nbsp;<strong>r</strong>&nbsp;代表可读(read)、&nbsp;<strong>w</strong>&nbsp;代表可写(write)、&nbsp;<strong>x</strong>&nbsp;代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号&nbsp;<strong>-</strong>&nbsp;。</p>
<figure class="wp-block-image size-large"><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/系统学习Linux笔记_3.1sdygu2698gw.jpg" alt=""/></figure>
<p>每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。</p>
<figure class="wp-block-image size-large"><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/系统学习Linux笔记_4.510d3vw6p640.jpg" alt="363003\_1227493859FdXT"/></figure>
<p>从左至右用&nbsp;<strong>0-9</strong>&nbsp;这些数字来表示。</p>
<p>第&nbsp;<strong>0</strong>&nbsp;位确定文件类型，第&nbsp;<strong>1-3</strong>&nbsp;位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中，第&nbsp;<strong>1、4、7</strong>&nbsp;位表示读权限，如果用&nbsp;<strong>r</strong>&nbsp;字符表示，则有读权限，如果用&nbsp;<strong>-</strong>&nbsp;字符表示，则没有读权限；</p>
<p>第&nbsp;<strong>2、5、8</strong>&nbsp;位表示写权限，如果用&nbsp;<strong>w</strong>&nbsp;字符表示，则有写权限，如果用&nbsp;<strong>-</strong>&nbsp;字符表示没有写权限；第&nbsp;<strong>3、6、9</strong>&nbsp;位表示可执行权限，如果用&nbsp;<strong>x</strong>&nbsp;字符表示，则有执行权限，如果用&nbsp;<strong>-</strong>&nbsp;字符表示，则没有执行权限。</p>
<h4 id="1-2-2-linux文件属主和属组">1.2.2 Linux文件属主和属组</h4>
<h4 id="1-chgrp-更改文件属组">1、chgrp：更改文件属组</h4>
<p>语法：</p>
<pre class="wp-block-preformatted" >chgrp [-R] 属组名 文件名</pre>
<p>参数选项</p>
<ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul>
<h4 id="2-chown-更改文件属主-也可以同时更改文件属组">2、chown：更改文件属主，也可以同时更改文件属组</h4>
<p>语法：</p>
<pre class="wp-block-preformatted">chown [–R] 属主名 文件名

chown [-R] 属主名：属组名 文件名</pre>
<p>进入 /root 目录（~）将install.log的拥有者改为bin这个账号：</p>
<pre class="wp-block-code"><code>&#91;root@www ~] cd ~

&#91;root@www ~]# chown bin install.log

&#91;root@www ~]# ls -l

- rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log</code></pre>
<p>将install.log的拥有者与群组改回为root：</p>
<pre class="wp-block-code"><code>&#91;root@www ~]# chown root:root install.log

&#91;root@www ~]# ls -l

- rw-r--r--  1 root root 68495 Jun 25 08:53 install.log</code></pre>
<h4 id="3-chmod-更改文件9个属性">3、chmod：更改文件9个属性</h4>
<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux 文件的基本权限就有九个，分别是&nbsp;<strong>owner/group/others(拥有者/组/其他)</strong>&nbsp;三种身份各有自己的&nbsp;<strong>read/write/execute</strong>&nbsp;权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为：&nbsp;<strong>-rwxrwxrwx</strong>&nbsp;， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul><li>r:4</li><li>w:2</li><li>x:1</li></ul>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：&nbsp;<strong>-rwxrwx---</strong>&nbsp;分数则是：</p>
<ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= --- = 0+0+0 = 0</li></ul>
<p>所以等一下我们设定权限的变更时，该文件的权限数字就是&nbsp;<strong>770</strong>。变更权限的指令 chmod 的语法是这样的：</p>
<pre class="wp-block-preformatted"> chmod [-R] xyz 文件或目录</pre>
<p>选项与参数：</p>
<ul><li><strong>xyz</strong>&nbsp;: 就是刚刚提到的数字类型的权限属性，为&nbsp;<strong>rwx</strong>&nbsp;属性数值的相加。</li><li><strong>-R</strong>&nbsp;: 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更</li></ul>
<p>举例来说，如果要将&nbsp;<strong>.bashrc</strong>&nbsp;这个文件所有的权限都设定启用，那么命令如下：</p>
<pre class="wp-block-code"><code>&#91;root@www ~]# ls -al .bashrc

- rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc

&#91;root@www ~]# chmod 777 .bashrc

&#91;root@www ~]# ls -al .bashrc

- rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</code></pre>
<p>那如果要将权限变成&nbsp;<em>-rwxr-xr--</em>&nbsp;呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。</p>
<h4 id="4-符号类型改变文件权限">4、符号类型改变文件权限</h4>
<p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p>
<ul><li>user：用户</li><li>group：组</li><li>others：其他</li></ul>
<p>那么我们就可以使用&nbsp;<strong>u, g, o</strong>&nbsp;来代表三种身份的权限。</p>
<p>此外，&nbsp;<strong>a</strong>&nbsp;则代表&nbsp;<strong>all</strong>，即全部的身份。读写的权限可以写成&nbsp;<strong>r, w, x</strong>，也就是可以使用下表的方式来看：</p>
<figure class="wp-block-table"><table><tbody><tr><td>chmod</td><td>u<br>g<br>o<br>a</td><td>+(加入)<br>-(除去)<br>=(设定)</td><td>r<br>w<br>x</td><td>文件或目录</td></tr></tbody></table></figure>
<p>如果我们需要将文件权限设置为&nbsp;<strong>-rwxr-xr--</strong>&nbsp;，可以使用&nbsp;<strong>chmod u=rwx,g=rx,o=r 文件名</strong>&nbsp;来设定:</p>
<pre class="wp-block-code"><code>#  touch test1    // 创建 test1 文件

\# ls -al test1    // 查看 test1 默认权限

- rw-r--r-- 1 root root 0 Nov 15 10:32 test1

\# chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限

\# ls -al test1

- rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</code></pre>
<p>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p>
<pre class="wp-block-code"><code>#  chmod  a-x test1

\# ls -al test1

- rw-r--r-- 1 root root 0 Nov 15 10:32 test1</code></pre>
<h3 id="1-3-vim文本编辑">1.3 vim文本编辑</h3>
<h4 id="1-3-1-vim的三种模式">1.3.1 vim的三种模式</h4>
<p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式</strong>、<strong>编辑模式</strong>和<strong>一般模式</strong></p>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Linux%E7%AC%94%E8%AE%B0_5.fwdyadc7qdc.jpg" alt="系统学习Linux笔记_5"></p>
<h4 id="1-3-2-vim快捷命令">1.3.2 vim快捷命令</h4>
<p>参考外部网站：<a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p>
<h3 id="1-4-网络配置">1.4 网络配置</h3>
<h4 id="1-4-1-vmware的三种网络连接模式">1.4.1  VMware的三种网络连接模式</h4>
<p>桥接模式：虚拟机直接连接外部网络（对外部网络可见），主机起到网桥的作用，虚拟机的地位和主机相同，从路由器分配独立的IP地址。</p>
<p>NAT模式：主机和虚拟机构建一个专用网络，使用NAT对虚拟机进行IP转换（虚拟机对外部网络不可见）。此时虚拟机单独组成一个局域网，此时主机和虚拟机并不在一个网段，无法进行通信，所以又虚拟一个网卡（VMnet8）来连接至虚拟机所在的局域网。</p>
<p>仅主机模式：这种模式仅仅只让虚拟机与主机通信，不连接至Internet</p>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Linux%E7%AC%94%E8%AE%B0_6.51mtatfmudg0.jpg" alt="系统学习Linux笔记_6"></p>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Linux%E7%AC%94%E8%AE%B0_7.1rszg1kh8600.jpg" alt="系统学习Linux笔记_7"></p>
<h4 id="1-4-2-配置静态ip">1.4.2 配置静态IP</h4>
<p>参考博客文章：<a href="https://yexca.xyz/index.php/2022/04/22/%e5%9c%a8%e8%99%9a%e6%8b%9f%e6%9c%ba%e4%b8%ad%e8%ae%be%e7%bd%ae%e9%9d%99%e6%80%81ip%ef%bc%88centos%e4%b8%ba%e4%be%8b%ef%bc%89/">在虚拟机中设置静态IP（centos为例）</a></p>
<h4 id="1-4-3-配置主机名">1.4.3 配置主机名</h4>
<pre class="wp-block-code"><code>hostname #查看当前主机名

vim /etc/hostname  #修改主机名

#修改后重启即可显示新主机名

#方法二

hostnamectl set-hostname ...

#实时生效</code></pre>
<pre class="wp-block-code"><code>#修改hosts文件

vim /etc/hosts</code></pre>
<h3 id="1-5-系统管理">1.5 系统管理</h3>
<h4 id="1-5-1-service-服务管理">1.5.1 service 服务管理</h4>
<p>一个正在执行的程序或命令，称为“进程”</p>
<p>启动后一直存在、常驻内存的进程，一般称为“服务”</p>
<pre class="wp-block-code"><code>systemctl start|stop|restart|status servicename #基本语法

/usr/lib/systemd/system/    #服务所在目录</code></pre>
<!--以上为word press导出-->
<h4 id="1-5-2-系统的运行级别"><a class="header-anchor" href="#1-5-2-系统的运行级别">¶</a>1.5.2 系统的运行级别</h4>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Linux_8.4koxejpo5300.jpg" alt="系统学习Linux_8"></p>
<h5 id="1-CentOS-7的运行级别简化为："><a class="header-anchor" href="#1-CentOS-7的运行级别简化为：">¶</a>1. CentOS 7的运行级别简化为：</h5>
<p>multi-user.target == 原运行级别3(多用户有网,无GUI)<br>
garphical.target  == 原运行级别5(多用户有网,有GUI)</p>
<h5 id="2-查看当前默认运行级别"><a class="header-anchor" href="#2-查看当前默认运行级别">¶</a>2. 查看当前默认运行级别</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl get-default</span><br></pre></td></tr></table></figure>
<h5 id="3-切换运行级别"><a class="header-anchor" href="#3-切换运行级别">¶</a>3. 切换运行级别</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 3 //switch runlevel 3</span><br><span class="line">init 5 //switch runlevel 5</span><br></pre></td></tr></table></figure>
<h4 id="1-5-3-配置服务开机自启"><a class="header-anchor" href="#1-5-3-配置服务开机自启">¶</a>1.5.3 配置服务开机自启</h4>
<h5 id="1-CentOS-7之前"><a class="header-anchor" href="#1-CentOS-7之前">¶</a>1. CentOS 7之前</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig --list //Centos 7之前查看自启服务(SysV)</span><br><span class="line"></span><br><span class="line">chkconfig network off/on //关闭network开机自启</span><br><span class="line"></span><br><span class="line">chkconfig --level 3 network off/on //针对某一运行级别设置开机自启</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Linux_9.7bral6n1ulg0.jpg" alt="系统学习Linux_9"></p>
<h5 id="2-CentOS-7之后"><a class="header-anchor" href="#2-CentOS-7之后">¶</a>2. CentOS 7之后</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl list-unit-files //查看开机自启服务</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">disable</span>/enable NetworkManager(SerciseName) </span><br><span class="line">//对于CentO S 7及以上使用systemctl控制开机自启(这里以NetworkManager为例)</span><br></pre></td></tr></table></figure>
<h5 id="3-练习-设置防火墙"><a class="header-anchor" href="#3-练习-设置防火墙">¶</a>3.练习_设置防火墙</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld.service //CentOS 7之前防火墙为iptables</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service //turn off firewalld Auto-start</span><br></pre></td></tr></table></figure>
<h4 id="1-5-4-关机重启"><a class="header-anchor" href="#1-5-4-关机重启">¶</a>1.5.4 关机重启</h4>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Linux_10.3yaooufylio.jpg" alt="系统学习Linux_10"></p>
<table>
<tr>
<td>选项</td>   <td>功能</td>
</tr>
<tr>
<td>-H</td>     <td>相当于--halt,停机</td>
</tr>
<tr>
<td>-r</te>     <td>shurdown -r == reboot 重启</td>
</tr>
</table>
<table>
<tr>
<td>参数</td>   <td>功能</td>
</tr>
<tr>
<td>now</td>     <td>立刻执行</td>
</tr>
<tr>
<td>时间</te>     <td>多少时间后执行(单位是分钟)</td>
</tr>
</table>
<h2 id="二、实操篇"><a class="header-anchor" href="#二、实操篇">¶</a>二、实操篇</h2>
<h4 id="2-1-帮助命令"><a class="header-anchor" href="#2-1-帮助命令">¶</a>2.1 帮助命令</h4>
<h5 id="1-基本语法"><a class="header-anchor" href="#1-基本语法">¶</a>1. 基本语法</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man [命令或配置文件]  //获取帮助信息（全）</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Linux%E7%AC%94%E8%AE%B0_11.6lkzrpquars0.jpg" alt="系统学习Linux笔记_11"></p>
 <center style="color:#FF69B4;font-size:16px;text-decoration">使用例：man ls</center>
<h5 id="2-内置命令和外部命令"><a class="header-anchor" href="#2-内置命令和外部命令">¶</a>2. 内置命令和外部命令</h5>
<ul>
<li>
<p>Linux中命令分为内置命令（cd、exit等)，外部命令（ls）。直接使用man查询内置命令会显示Bash（内置命令内嵌在Bash中），查询内置命令时可以使用 <code> man -f [命令]</code></p>
</li>
<li>
<p>便捷查询：</p>
<ul>
<li>内置命令: <code>help [命令]</code>(help只能查询内置命令)</li>
<li>外置命令: <code> [命令] --help</code></li>
</ul>
</li>
</ul>
<h5 id="3-常用快捷键"><a class="header-anchor" href="#3-常用快捷键">¶</a>3. 常用快捷键</h5>
<table>
<tr>
<th>快捷键</th>     <th>功能</th>
</tr>
<tr>
<td>ctrl+c</td>     <td>停止进程</td>
</tr>
<tr>
<td>ctrl+l</td>     <td>清屏，等同于clear</td>
</tr>
<tr>
<td>↑，↓</td>     <td>查询执行过的命令</td>
</tr>
<tr>
<td>tab</td>     <td>补全命令或文件名</td>
</tr>
</table>
<h4 id="2-2-常用基本命令——文件目录类"><a class="header-anchor" href="#2-2-常用基本命令——文件目录类">¶</a>2.2 常用基本命令——文件目录类</h4>
<p><strong>1. pwd: 显示当前工作目录的绝对路径</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[hiyoung@VM-4-10-centos ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/hiyoung</span><br></pre></td></tr></table></figure>
<p><strong>2. cd: 切换路径</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用绝对路径切换</span></span><br><span class="line">[hiyoung@VM-4-10-centos network-scripts]$ <span class="built_in">cd</span> /home/hiyoung/</span><br><span class="line">[hiyoung@VM-4-10-centos ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/hiyoung</span><br><span class="line"><span class="comment">#使用相对路径切换</span></span><br><span class="line">[root@VM-4-10-centos home] <span class="built_in">cd</span> hiyoung/</span><br><span class="line">[root@VM-4-10-centos hiyoung] <span class="built_in">cd</span> ../www/</span><br><span class="line">[root@VM-4-10-centos www] <span class="built_in">pwd</span></span><br><span class="line">/home/www</span><br><span class="line"><span class="comment">#cd -: 切换到上一次浏览的目录</span></span><br><span class="line">[root@VM-4-10-centos www] <span class="built_in">cd</span> -</span><br><span class="line">/home/hiyoung</span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2023/07/01/a0d1c5d2d98e/</url>
    <content><![CDATA[<p>记录一下平常会用到的一些Hexo指令，在指定文件夹下Git Bash here输入命令即可</p>
<span id="more"></span>
<h2 id="基本命令"><a class="header-anchor" href="#基本命令">¶</a>基本命令</h2>
<h3 id="init"><a class="header-anchor" href="#init">¶</a>init</h3>
<p>建立一个新的网站。如果没有设定folder 的话，Hexo 会在目前的资料夹建立网站</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init [folder] </span><br></pre></td></tr></table></figure>
<h3 id="New"><a class="header-anchor" href="#New">¶</a>New</h3>
<p>建立一篇新的文章。如果没有设定layout的话，则会使用_config.yml中的default_layout设定代替</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] <span class="string">&quot;title&quot;</span> </span><br></pre></td></tr></table></figure>
<h3 id="Generate"><a class="header-anchor" href="#Generate">¶</a>Generate</h3>
<p>产生静态档案</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate </span><br></pre></td></tr></table></figure>
<p>生成静态档案即部署网站</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d -g </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-d,–deploy</td>
<td style="text-align:center">产生完成即部署网站</td>
</tr>
<tr>
<td style="text-align:center">-w,–watch</td>
<td style="text-align:center">监看档案变更</td>
</tr>
</tbody>
</table>
<h3 id="Server"><a class="header-anchor" href="#Server">¶</a>Server</h3>
<p>启动本地预览，默认地址是http://localhost:4000/</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-p,–port</td>
<td style="text-align:center">自选端口</td>
</tr>
<tr>
<td style="text-align:center">-s,–static</td>
<td style="text-align:center">只使用静态档案</td>
</tr>
<tr>
<td style="text-align:center">-l,–log</td>
<td style="text-align:center">启动记录器，或覆盖记录格式</td>
</tr>
</tbody>
</table>
<h3 id="Clean"><a class="header-anchor" href="#Clean">¶</a>Clean</h3>
<p>清除缓存数据( db.json) 和已产生的静态档案( public)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<h3 id="Version"><a class="header-anchor" href="#Version">¶</a>Version</h3>
<p>显示版本资讯。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>
<h3 id="Debug"><a class="header-anchor" href="#Debug">¶</a>Debug</h3>
<p>在终端中显示除错讯息并储存记录档到debug.log</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo --debug</span><br></pre></td></tr></table></figure>
<h3 id="Plugins"><a class="header-anchor" href="#Plugins">¶</a>Plugins</h3>
<p>查看所有你安装的hexo插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">ls</span> -dept 0 </span><br></pre></td></tr></table></figure>
<h3 id="修改文章默认layout"><a class="header-anchor" href="#修改文章默认layout">¶</a>修改文章默认layout</h3>
<p>在下列文件中可以修改新建文章的layout（文章开头的Front-matter内容）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scaffolds\post.md</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端</category>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown实用技巧</title>
    <url>/2023/06/30/047bc455e7dc/</url>
    <content><![CDATA[<p>记录一下可能会用到非Markdown基础语法包含的实用技巧<br>
官方的速查表&lt;Markdown 语法速查表&gt;(<a href="https://markdown.com.cn/cheat-sheet.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">https://markdown.com.cn/cheat-sheet.html#基本语法</a>)</p>
<span id="more"></span>
<h2 id="Markdown实现页内跳转"><a class="header-anchor" href="#Markdown实现页内跳转">¶</a>Markdown实现页内跳转</h2>
<p><span id="jump"><strong>跳转到的地方</strong></span></p>
<p>比较通用的一个方法是使用html标签实现</p>
<ol>
<li>定义一个锚(id)：<code>&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;</code></li>
<li>使用markdown语法：<code>[点击跳转](#jump)</code></li>
</ol>
<p><a href="#jump">点击跳转</a></p>
<h2 id="Markdown中的表格"><a class="header-anchor" href="#Markdown中的表格">¶</a>Markdown中的表格</h2>
<p>处理使用markdown原生格式的表格使用html的表格更方便</p>
<ol>
<li>
<p>markdown原生格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----:  | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>html实现</p>
</li>
</ol>
<ul>
<li>tr：tr 是 table row 的缩写，表示表格的一行。</li>
<li>td：td 是 table data 的缩写，表示表格的数据单元格。</li>
<li>th：th 是 table header的缩写，表示表格的表头单元格</li>
<li>align：设置内容左、右对齐或居中</li>
<li>colspan：用于合并单元格</li>
</ul>
<table>
    <tr>
        <td align="center">$A_1$</td>
        <td align="center">$A_2$</td>
        <td align="center">...</td>
        <td align="center">$A_n$</td>
        <td align="center">判断测试字段</td>
        <td align="center">后继地址字段</td>
    </tr>
    <tr>
        <td colspan="4" align="center">操作控制</td>
        <td colspan="2" align="center">顺序控制</td>>
    </tr>
</table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>$A_1$<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>$A_2$<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>$A_n$<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>判断测试字段<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>后继地址字段<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>操作控制<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>顺序控制<span class="tag">&lt;/<span class="name">td</span>&gt;</span>&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端</category>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>next主题的一些设置</title>
    <url>/2022/11/20/eac15b136357/</url>
    <content><![CDATA[<h2 id="Hexo默认-主题的config优先级高于Hexo的config"><a class="header-anchor" href="#Hexo默认-主题的config优先级高于Hexo的config">¶</a>Hexo默认 主题的config优先级高于Hexo的config</h2>
<p>基于Hexo 6.2 和hexo-theme-next-8.12.1 不同版本设置可能不一样</p>
<span id="more"></span> 
<h3 id="以下为next主题config设置："><a class="header-anchor" href="#以下为next主题config设置：">¶</a>以下为next主题config设置：</h3>
<h4 id="一-网站图标设置"><a class="header-anchor" href="#一-网站图标设置">¶</a>一.网站图标设置</h4>
<ol>
<li>侧边栏链接图标设置：此版本使用的是 <a href="https://fontawesome.com/icons">https://fontawesome.com/icons</a> 图标库</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE1.3kzrx9umrz60.jpg" alt="next主题设置1"></p>
<ol start="2">
<li>在social下可以添加链接和图标   e.g Bilibili: 链接地址 || 图标库名称<br>
tips:有些是<strong>fa</strong> fa-XXXX 有些是<strong>fab</strong> fa-XXXX</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE2.541nq9bzafs0.jpg" alt="next主题设置2"></p>
<ol start="3">
<li>网站站点的图标在本地Hexo\public\images中，在主题favicon中设置</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE3.63l02jbegvc0.jpg" alt="next主题设置3"></p>
<h4 id="生成文章默认生成属性"><a class="header-anchor" href="#生成文章默认生成属性">¶</a>生成文章默认生成属性</h4>
<p>categories有点类似tags，写在文章属性之中，所以需要在文章生成时添加categories属性。<br>
编辑<code>hexo/scaffolds/post.md</code>，在最下面添加一行categories</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="添加小功能"><a class="header-anchor" href="#添加小功能">¶</a>添加小功能</h3>
<h4 id="添加本站运行时间"><a class="header-anchor" href="#添加本站运行时间">¶</a>添加本站运行时间</h4>
<p>修改Hexo/themes/next/layout/_partials/footer.njk(footer.swig)文件，在末尾加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/br&gt;  //换行</span><br><span class="line">&lt;!-- 网站运行时间的设置 --&gt;</span><br><span class="line">&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><br><span class="line">&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date();</span><br><span class="line">    function createtime() &#123;</span><br><span class="line">        var grt= new Date(&quot;04/21/2019 15:54:40&quot;);//此处修改你的建站时间或者网站上线时间</span><br><span class="line">        now.setTime(now.getTime()+250);</span><br><span class="line">        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);</span><br><span class="line">        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);</span><br><span class="line">        if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);</span><br><span class="line">        mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125;</span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);</span><br><span class="line">        snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125;</span><br><span class="line">        document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;;</span><br><span class="line">        document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">setInterval(&quot;createtime()&quot;,250);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考资料：<br>
<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a><br>
<a href="https://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme">Next主题文档说明</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端</category>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>在个人服务器上部署Hexo</title>
    <url>/2022/07/01/38f7a1f95417/</url>
    <content><![CDATA[<h2 id="服务器部署Hexo"><a class="header-anchor" href="#服务器部署Hexo">¶</a>服务器部署Hexo</h2>
<p>本地：</p>
<ol>
<li>win11	Git-2.36.1-64-bit	aapanel_chinese-6.8.21	Node.js v16.15.1</li>
<li>Hexo 6.2 	hexo-theme-next-8.12.1<br>
服务器：</li>
<li>腾讯云 2H2G 30G ssd centos 7.3	git version 1.8.3.1</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端</category>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo错误记录</title>
    <url>/2022/06/24/571f7c314ead/</url>
    <content><![CDATA[<h2 id="搭建中遇到的问题"><a class="header-anchor" href="#搭建中遇到的问题">¶</a>搭建中遇到的问题</h2>
<p>两次连接都遇到免密登录失败的问题。<br>
首先按照教程操作</p>
<p>在本地Git设置个人信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;user.name&quot;</span><br><span class="line">git config --global user.email &quot;user@gmail.com&quot;</span><br></pre></td></tr></table></figure>
<p>生成密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你刚刚设置的邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>本地SSH keys: 路径： C:\Users\（你的用户名）.ssh</p>
<p>找到id_rsa.pub文件，用记事本打开，复制其内容。</p>
<p>！！注意：这里复制到服务器上后要看后面的邮箱的 <code>“”</code> 有没有去掉和前面是不是<code>ssh-rsa</code> (两次都是这里出错)！！</p>
<p>然后就是按照教程设置权限等</p>
<h3 id="2024-7-18记录"><a class="header-anchor" href="#2024-7-18记录">¶</a>2024/7/18记录</h3>
<p>遇到了测试<code>ssh -T git@github.com</code>时<code>Connection closed by 20.205.243.166 port 22</code><br>
并且在部署hexo是也出现了<code>hexo Connection closed by 20.205.243.166 port 22</code></p>
<p>解决方法：<br>
先测试一下<code>ssh -T -p 443 git@ssh.github.com</code>是否能连通<br>
如果可以<br>
这时候在hexo的配置文件中把<code>deploy:</code>下的<code>rpeo</code>从<code>git@...改为https:// </code><br>
然后重新部署（可能需要本地开代理）即可</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端</category>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>萌百黑幕CSS代码</title>
    <url>/2022/08/22/d4860506f8cc/</url>
    <content><![CDATA[<h2 id="萌百黑幕CSS代码"><a class="header-anchor" href="#萌百黑幕CSS代码">¶</a>萌百黑幕CSS代码</h2>
<p>代码来自互联网，仅copy下来以方便自己使用<span class="heimu" title="你知道的太多了">，没错就是抄袭(bushi)</span></p>
<p>在HTML中在<code>&lt;head&gt;</code>的<code>&lt;style&gt;</code>中直接引入即可；<br>
在MD中直接添加<code>&lt;style&gt;</code>即可</p>
<span id="more"></span>
<p>使用例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;heimu&quot;</span> <span class="attr">title</span>=<span class="string">&quot;黑幕小弹框里的字&quot;</span>&gt;</span>你需要隐藏的文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>具体代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="comment">/*黑幕实现*/</span></span><br><span class="line"><span class="selector-class">.heimu</span>, <span class="selector-class">.heimu</span> <span class="selector-tag">a</span>, <span class="selector-tag">a</span> <span class="selector-class">.heimu</span>, <span class="selector-class">.heimu</span> <span class="selector-tag">a</span><span class="selector-class">.new</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#252525</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#252525</span>;</span><br><span class="line">  <span class="attribute">text-shadow</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heimu</span><span class="selector-pseudo">:hover</span>, <span class="selector-class">.heimu</span><span class="selector-pseudo">:active</span>,</span><br><span class="line"><span class="selector-class">.heimu</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.heimu</span>, <span class="selector-class">.heimu</span><span class="selector-pseudo">:active</span> <span class="selector-class">.heimu</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">color</span>: white <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heimu</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">a</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.heimu</span>,</span><br><span class="line"><span class="selector-class">.heimu</span><span class="selector-pseudo">:active</span> <span class="selector-tag">a</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> <span class="selector-class">.heimu</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">color</span>: lightblue <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heimu</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.new</span>, <span class="selector-class">.heimu</span> <span class="selector-class">.new</span><span class="selector-pseudo">:hover</span>, <span class="selector-class">.new</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.heimu</span>,</span><br><span class="line"><span class="selector-class">.heimu</span><span class="selector-pseudo">:active</span> <span class="selector-class">.new</span>, <span class="selector-class">.heimu</span> <span class="selector-class">.new</span><span class="selector-pseudo">:active</span>, <span class="selector-class">.new</span><span class="selector-pseudo">:active</span> <span class="selector-class">.heimu</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#BA0000</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="在Hexo中自定义CSS"><a class="header-anchor" href="#在Hexo中自定义CSS">¶</a>在Hexo中自定义CSS</h2>
<p>首先，在主题的样式文件的source文件夹下找到css文件夹，打开main.styl（next主题下）或者index.styl（butterfly主题下）文件，在最后添加：<br>
路径是：Hexo\themes\butterfly\source\css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//My Layer</span><br><span class="line">//--------------------------------------------------</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;_my/mycss&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="新建自定义样式"><a class="header-anchor" href="#新建自定义样式">¶</a>新建自定义样式</h3>
<p>找到样式文件夹css 新建_my文件夹，在其中新建mycss.styl文件，之后就可以按照stylus的格式自定义样式了。</p>
<p>路径是：\Hexo\themes\next\source\css\ _my</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Aria2+AriaNG配置使用</title>
    <url>/2022/09/01/906d191f9a59/</url>
    <content><![CDATA[<p>Aria2是Linux下的一个下载工具,这里介绍Windows下的安装与配置,官方Aria2没有GUI界面所以配合AriaNG直接在Web界面进行操作.</p>
<p>AriaNg 是一个让 aria2 更容易使用的现代 Web 前端. AriaNg 使用纯 html &amp; javascript 开发, 所以其不需要任何编译器或运行环境.</p>
<span id="more"></span>
<h2 id="下载Aria2-AriaNG最新安装包"><a class="header-anchor" href="#下载Aria2-AriaNG最新安装包">¶</a>下载Aria2+AriaNG最新安装包</h2>
<p>首先先在官网下载安装包</p>
<ul>
<li><strong><a href="https://github.com/aria2/aria2/releases/">Aria2的Github地址</a></strong>
<ul>
<li><strong><a href="https://aria2.github.io/">Aria2官方文档</a></strong></li>
</ul>
</li>
<li><strong><a href="https://github.com/mayswind/AriaNg/releases">AriaNG的Github地址</a></strong>
<ul>
<li><strong><a href="http://ariang.mayswind.net/zh_Hans/">AriaNG官方文档</a></strong></li>
</ul>
</li>
</ul>
<p>Aria2选择对应的操作系统下载压缩包即可,AriaNG解压后放在Aria2文件夹即可</p>
<p>AriaNg 现在提供三种版本, 标准版、单文件版和 AriaNg Native.</p>
<blockquote>
<p>标准版适合在 Web 服务器中部署, 提供资源缓存和按需加载的功能.</p>
</blockquote>
<blockquote>
<p>单文件版适合本地使用, 您下载后只要在浏览器中打开唯一的 html 文件即可.</p>
</blockquote>
<blockquote>
<p>AriaNg Native 同样适合本地使用, 并且不需要使用浏览器.</p>
</blockquote>
<h2 id="添加配置文件"><a class="header-anchor" href="#添加配置文件">¶</a>添加配置文件</h2>
<p>将文件解压至该目录下后，你需要再新创 4 个空文件(可以先建一个空 txt 文件然后修改后缀名)：</p>
<ul>
<li><strong>Aria2.log （日志文件）</strong></li>
<li><strong>aria2.session （用于记录下载历史，以便断点续传）</strong></li>
<li><strong>aria2.conf （配置文件）</strong></li>
<li><strong>HideRun.vbs （隐藏 cmd 窗口运行用到的）</strong></li>
</ul>
<h3 id="修改配置文件"><a class="header-anchor" href="#修改配置文件">¶</a>修改配置文件</h3>
<ol>
<li>打开刚才创建的 aria2.conf 空文件，将以下内容填入（用记事本打开即可）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## &#x27;#&#x27;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span><br><span class="line">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span><br><span class="line"></span><br><span class="line">## 文件保存相关 ##</span><br><span class="line"></span><br><span class="line"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span><br><span class="line">dir=E:\Aria2Download</span><br><span class="line"># 日志文件的保存路径</span><br><span class="line">log=D:\aria2-1.36.0-win-64bit-build1\Aria2.log</span><br><span class="line"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span><br><span class="line">#disk-cache=32M</span><br><span class="line"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span><br><span class="line"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span><br><span class="line"># falloc和trunc则需要文件系统和内核支持</span><br><span class="line"># NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span><br><span class="line">#file-allocation=none</span><br><span class="line"># 断点续传</span><br><span class="line">continue=true</span><br><span class="line"></span><br><span class="line">## 下载连接相关 ##</span><br><span class="line"></span><br><span class="line"># 最大同时下载任务数, 运行时可修改, 默认:5</span><br><span class="line">#max-concurrent-downloads=5</span><br><span class="line"># 同一服务器连接数, 添加时可指定, 默认:1</span><br><span class="line">max-connection-per-server=5</span><br><span class="line"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span><br><span class="line"># 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span><br><span class="line">min-split-size=10M</span><br><span class="line"># 单个任务最大线程数, 添加时可指定, 默认:5</span><br><span class="line">#split=5</span><br><span class="line"># 整体下载速度限制, 运行时可修改, 默认:0</span><br><span class="line">#max-overall-download-limit=0</span><br><span class="line"># 单个任务下载速度限制, 默认:0</span><br><span class="line">#max-download-limit=0</span><br><span class="line"># 整体上传速度限制, 运行时可修改, 默认:0</span><br><span class="line">#max-overall-upload-limit=0</span><br><span class="line"># 单个任务上传速度限制, 默认:0</span><br><span class="line">#max-upload-limit=0</span><br><span class="line"># 禁用IPv6, 默认:false</span><br><span class="line">#disable-ipv6=true</span><br><span class="line"># 连接超时时间, 默认:60</span><br><span class="line">#timeout=60</span><br><span class="line"># 最大重试次数, 设置为0表示不限制重试次数, 默认:5</span><br><span class="line">#max-tries=5</span><br><span class="line"># 设置重试等待的秒数, 默认:0</span><br><span class="line">#retry-wait=0</span><br><span class="line"></span><br><span class="line">## 进度保存相关 ##</span><br><span class="line"></span><br><span class="line"># 从会话文件中读取下载任务</span><br><span class="line">input-file=D:\aria2-1.36.0-win-64bit-build1\aria2.session</span><br><span class="line"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件</span><br><span class="line">save-session=D:\aria2-1.36.0-win-64bit-build1\aria2.session</span><br><span class="line"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span><br><span class="line">#save-session-interval=60</span><br><span class="line"></span><br><span class="line">## RPC相关设置 ##</span><br><span class="line"></span><br><span class="line"># 启用RPC, 默认:false</span><br><span class="line">enable-rpc=true</span><br><span class="line"># 允许所有来源, 默认:false</span><br><span class="line">rpc-allow-origin-all=true</span><br><span class="line"># 允许非外部访问, 默认:false</span><br><span class="line">rpc-listen-all=true</span><br><span class="line"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span><br><span class="line">#event-poll=select</span><br><span class="line"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span><br><span class="line">#rpc-listen-port=6800</span><br><span class="line"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span><br><span class="line">#rpc-secret=&lt;TOKEN&gt;</span><br><span class="line"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="line">#rpc-user=&lt;USER&gt;</span><br><span class="line"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="line">#rpc-passwd=&lt;PASSWD&gt;</span><br><span class="line"># 是否启用 RPC 服务的 SSL/TLS 加密,</span><br><span class="line"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span><br><span class="line">#rpc-secure=true</span><br><span class="line"># 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,</span><br><span class="line"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span><br><span class="line">#rpc-certificate=/path/to/certificate.pem</span><br><span class="line"># 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件</span><br><span class="line">#rpc-private-key=/path/to/certificate.key</span><br><span class="line"></span><br><span class="line">## BT/PT下载相关 ##</span><br><span class="line"></span><br><span class="line"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span><br><span class="line">#follow-torrent=true</span><br><span class="line"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span><br><span class="line">listen-port=51413</span><br><span class="line"># 单个种子最大连接数, 默认:55</span><br><span class="line">#bt-max-peers=55</span><br><span class="line"># 打开DHT功能, PT需要禁用, 默认:true</span><br><span class="line">enable-dht=false</span><br><span class="line"># 打开IPv6 DHT功能, PT需要禁用</span><br><span class="line">#enable-dht6=false</span><br><span class="line"># DHT网络监听端口, 默认:6881-6999</span><br><span class="line">#dht-listen-port=6881-6999</span><br><span class="line"># 本地节点查找, PT需要禁用, 默认:false</span><br><span class="line">#bt-enable-lpd=false</span><br><span class="line"># 种子交换, PT需要禁用, 默认:true</span><br><span class="line">enable-peer-exchange=false</span><br><span class="line"># 每个种子限速, 对少种的PT很有用, 默认:50K</span><br><span class="line">#bt-request-peer-speed-limit=50K</span><br><span class="line"># 客户端伪装, PT需要</span><br><span class="line">peer-id-prefix=-TR2770-</span><br><span class="line">user-agent=Transmission/2.77</span><br><span class="line"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span><br><span class="line">seed-ratio=0.7</span><br><span class="line"># 强制保存会话, 即使任务已经完成, 默认:false</span><br><span class="line"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span><br><span class="line">#force-save=false</span><br><span class="line"># BT校验相关, 默认:true</span><br><span class="line">#bt-hash-check-seed=true</span><br><span class="line"># 继续之前的BT任务时, 无需再次校验, 默认:false</span><br><span class="line">bt-seed-unverified=true</span><br><span class="line"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span><br><span class="line">bt-save-metadata=true</span><br></pre></td></tr></table></figure>
<p><strong>注意:你需要将下面四行的内容修改为你自己的对应文件位置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span><br><span class="line">dir=E:\Aria2Download</span><br><span class="line"># 日志文件的保存路径</span><br><span class="line">log=D:\aria2-1.36.0-win-64bit-build1\Aria2.log</span><br><span class="line"># 从会话文件中读取下载任务</span><br><span class="line">input-file=D:\aria2-1.36.0-win-64bit-build1\aria2.session</span><br><span class="line"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件</span><br><span class="line">save-session=D:\aria2-1.36.0-win-64bit-build1\aria2.session</span><br></pre></td></tr></table></figure>
<p>最后两行的内容是保存下载历史的，如果有时 Aria2 不能启动的话，清空里面的内容就可以了。</p>
<ol start="2">
<li>修改 HideRun.vbs 文件</li>
</ol>
<p>打开HideRun.vbs文件,向其中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CreateObject(&quot;WScript.Shell&quot;).Run &quot;aria2c.exe --conf-path=aria2.conf&quot;,0</span><br></pre></td></tr></table></figure>
<p>接下来点击运行 HideRun.vbs 文件，（注意一定是 HideRun.vbs 文件而不是那个可执行文件！！），如果没有报错的话可以直接跳过下面这段：<br>
注意一下，这里也可以在文件前添加具体的文件目录前缀，但是前缀的文件目录中一定不要有空格<br>
例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CreateObject(&quot;WScript.Shell&quot;).Run &quot;C:\Users\he ne\Downloads\aria2c.exe --conf-path=aria2.conf&quot;,0</span><br></pre></td></tr></table></figure>
<p>但是由于 he ne 这一文件夹里面包含空格，就导致了系统不识别，类似的常见错位位置还多见于：D:Program Files (x86)，这里也是存在空格的，解决方式就是将这一前缀去除即可（但需要该 vbs 文件位于该 aria2 文件夹下）</p>
<ol start="3">
<li>打开index.html</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/Aria2+AriaNG%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8_1.1ohxweqn3ayo.jpg" alt="Aria2+AriaNG配置使用_1"></p>
<p>打开里面的 index.html 文件，如果显示 “已连接”，则表明搭建成功</p>
<ol start="4">
<li>添加开机自启</li>
</ol>
<p>创建 HideRun.vbs 文件的快捷方式，放入 windows 的开机自启目录即可：</p>
<p>在资源管理器窗口中输入：<code>shell:startup</code></p>
<p>这里便会打开自启目录文件夹，然后将该快捷方式拖入即可</p>
<hr>
<p>参考文章:<br>
<a href="https://www.higgs.xyz/archives/7/">Aria2+AriaNG 配置指南（Win10 篇）</a><br>
<a href="http://ariang.mayswind.net/zh_Hans/">AriaNG文档</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>实用工具教程</category>
      </categories>
      <tags>
        <tag>Aria2</tag>
        <tag>AriaNG</tag>
      </tags>
  </entry>
  <entry>
    <title>PS脚本自动处理图片</title>
    <url>/2022/08/18/5be9517606f2/</url>
    <content><![CDATA[<h2 id="使用PS自动化脚本批量处理图片"><a class="header-anchor" href="#使用PS自动化脚本批量处理图片">¶</a>使用PS自动化脚本批量处理图片</h2>
<ol>
<li>点击菜单栏的 窗口-&gt;动作（快捷键alt+F9)</li>
<li>再选项卡底部点击新建文件夹（新建组），取名为修改图片大小（可以自己重命名）</li>
<li>再点击旁边的创建新动作，我们可以看到底部原点变为红色</li>
</ol>
<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/hiyoung3937/img_hiyoung/master/bolg/blog_%E4%BD%BF%E7%94%A8PS%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87_1.5x0zewo4yzc0.jpg" alt="blog_使用PS自动化脚本批量处理图片_1"></p>
<ol start="4">
<li><strong>点击文件、打开</strong>，打开我们要处理的其中一张图片，修改图片大小，再点击确定，<strong>然后另存为，取个名字，存储</strong>。（不要使用导出，否则无法录入动作导致陷入死循环）</li>
<li><strong>点击文件、自动、批处理</strong></li>
<li>设置
<ol>
<li>播放处选择组和动作</li>
<li>源 选择需要修改的图片文件地址</li>
<li>目标 选择修改后的图片保存地址</li>
<li>勾选 <strong>“覆盖动作中的’打开’命令”</strong> 和 <strong>“覆盖动作中的‘存储为’命令”</strong></li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hiyoung3937/img_hiyoung/master/bolg/blog_%E4%BD%BF%E7%94%A8PS%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87_2.2bh4ygmfs3i8.jpg" alt="blog_使用PS自动化脚本批量处理图片_2"></p>
<hr>
<p>内容部分参考自互联网</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>实用工具教程</category>
      </categories>
      <tags>
        <tag>实用小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>v2ray一键脚本</title>
    <url>/2022/06/27/1051c5c82c9c/</url>
    <content><![CDATA[<h2 id="自己使用过的一些科学上网脚本"><a class="header-anchor" href="#自己使用过的一些科学上网脚本">¶</a>自己使用过的一些科学上网脚本</h2>
<span id="more"></span>
<h3 id="一：ss2022"><a class="header-anchor" href="#一：ss2022">¶</a>一：<a href="https://github.com/loyess/2022">ss2022</a></h3>
<h3 id="一键脚本："><a class="header-anchor" href="#一键脚本：">¶</a>一键脚本：</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -OL https://github.com/loyess/2022/raw/main/2022script.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x 2022script.sh</span><br><span class="line">./2022script.sh</span><br></pre></td></tr></table></figure>
<h4 id="卸载："><a class="header-anchor" href="#卸载：">¶</a>卸载：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./2022script.sh --remove</span><br></pre></td></tr></table></figure>
<h4 id="管理面板："><a class="header-anchor" href="#管理面板：">¶</a>管理面板：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./2022script.sh -h</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Writing <a href="ss://links">ss://links</a> information into: /root/rustss2022/url_scheme.conf //节点信息</p>
</blockquote>
<blockquote>
<p>Writing service information into: /etc/systemd/system/ss-rust.service</p>
</blockquote>
<h3 id="二：v2ray-agent脚本"><a class="header-anchor" href="#二：v2ray-agent脚本">¶</a>二：<a href="https://github.com/mack-a/v2ray-agent">v2ray-agent脚本</a></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -P /root -N --no-check-certificate &quot;https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh&quot; &amp;&amp; chmod 700 /root/install.sh &amp;&amp; /root/install.sh</span><br></pre></td></tr></table></figure>
<h3 id="管理面板：vasma"><a class="header-anchor" href="#管理面板：vasma">¶</a>管理面板：<strong>vasma</strong></h3>
<h3 id="三：233boy脚本-现已不建议使用"><a class="header-anchor" href="#三：233boy脚本-现已不建议使用">¶</a>三：233boy脚本(现已不建议使用)</h3>
<h4 id="1-安装-V2Ray"><a class="header-anchor" href="#1-安装-V2Ray">¶</a>1.安装 V2Ray</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure>
<p>如果提示 curl: command not found ，那是因为你的 VPS 没装 Curl<br>
ubuntu/debian :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update -y &amp;&amp; apt-get install curl -y</span><br></pre></td></tr></table></figure>
<p>centos 系统安装 Curl 方法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update -y &amp;&amp; yum install curl -y</span><br></pre></td></tr></table></figure>
<p>安装好 curl 之后就能安装脚本了</p>
<h4 id="2-开启谷歌BBR加速"><a class="header-anchor" href="#2-开启谷歌BBR加速">¶</a>2.开启谷歌BBR加速</h4>
<p>本文的系统要求为 Debian 9或更高版本的 Debian Linux</p>
<p>命令1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/bannedbook/fanqiang/master/v2ss/server-cfg/sysctl.conf -O -&gt; /etc/sysctl.con</span><br></pre></td></tr></table></figure>
<p>注：如果提示 wget: command not found 的错误，这是因为你的系统wget没有安装，所以需要安先装 wget:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install -y wget</span><br></pre></td></tr></table></figure>
<p>命令2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<h4 id="3-快速管理-V2Ray"><a class="header-anchor" href="#3-快速管理-V2Ray">¶</a>3.快速管理 V2Ray</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2ray info 查看 V2Ray 配置信息</span><br><span class="line">v2ray config 修改 V2Ray 配置</span><br><span class="line">v2ray link 生成 V2Ray 配置文件链接</span><br><span class="line">v2ray infolink 生成 V2Ray 配置信息链接</span><br><span class="line">v2ray qr 生成 V2Ray 配置二维码链接</span><br><span class="line">v2ray ss 修改 Shadowsocks 配置</span><br><span class="line">v2ray ssinfo 查看 Shadowsocks 配置信息</span><br><span class="line">v2ray ssqr 生成 Shadowsocks 配置二维码链接</span><br><span class="line">v2ray status 查看 V2Ray 运行状态</span><br><span class="line">v2ray start 启动 V2Ray</span><br><span class="line">v2ray stop 停止 V2Ray</span><br><span class="line">v2ray restart 重启 V2Ray</span><br><span class="line">v2ray log 查看 V2Ray 运行日志</span><br><span class="line">v2ray update 更新 V2Ray</span><br><span class="line">v2ray update.sh 更新 V2Ray 管理脚本</span><br><span class="line">v2ray uninstall 卸载 V2Ray</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>实用工具教程</category>
      </categories>
      <tags>
        <tag>一键脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>装机软件下载网址</title>
    <url>/2022/10/08/5c79848f3e3d/</url>
    <content><![CDATA[<p><strong>装机软件下载网址</strong></p>
<p>个人常用软件列表，重装系统下软件真的麻烦…</p>
<span id="more"></span>
<h3 id="应用类："><a class="header-anchor" href="#应用类：">¶</a>应用类：</h3>
<p>TIM：<a href="https://tim.qq.com/download.html">https://tim.qq.com/download.html</a></p>
<p>火绒：<a href="https://www.huorong.cn/" data-type="URL" data-id="https://www.huorong.cn/">https://www.huorong.cn/</a></p>
<p>网易云音乐：<a href="https://music.163.com/#/download" data-type="URL" data-id="https://music.163.com/#/download">https://music.163.com/#/download</a></p>
<p>WeChat：<a href="https://weixin.qq.com/">https://weixin.qq.com/</a></p>
<p>Steam：<a href="https://store.steampowered.com/about/">https://store.steampowered.com/about/</a></p>
<p>Epic：<a href="https://store.epicgames.com/zh-CN/?lang=zh-CN">https://store.epicgames.com/zh-CN/?lang=zh-CN</a></p>
<p>百度网盘：<a href="https://pan.baidu.com/download" data-type="URL" data-id="https://pan.baidu.com/download">https://pan.baidu.com/download</a></p>
<p>Audacity：<a href="https://www.audacityteam.org/download/" data-type="URL" data-id="https://www.audacityteam.org/download/">https://www.audacityteam.org/download/</a></p>
<p>Mkvtoolnix：<a href="https://mkvtoolnix.download/downloads.html#windows" data-type="URL" data-id="https://mkvtoolnix.download/downloads.html#windows">https://mkvtoolnix.download/downloads.html#windows</a></p>
<p>qBittorrent：<a href="https://sourceforge.net/projects/qbittorrent/">https://sourceforge.net/projects/qbittorrent/</a></p>
<p>qBittorrent-Enhanced-Edition:<a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">https://github.com/c0re100/qBittorrent-Enhanced-Edition</a></p>
<p>7-zip：<a href="https://www.7-zip.org/" data-type="URL" data-id="https://www.7-zip.org/">https://www.7-zip.org/</a></p>
<p>Koodo reader：<a href="https://github.com/troyeguo/koodo-reader" data-type="URL" data-id="https://github.com/troyeguo/koodo-reader">https://github.com/troyeguo/koodo-reader</a></p>
<p>Potplayer：<a href="https://potplayer.daum.net/" data-type="URL" data-id="https://potplayer.daum.net/">https://potplayer.daum.net/</a></p>
<p>Telegram：<a href="https://desktop.telegram.org/" data-type="URL" data-id="https://desktop.telegram.org/">https://desktop.telegram.org/</a></p>
<p>Chrome：<a href="https://www.google.com/chrome/?brand=YTUH&amp;gclid=Cj0KCQjwhLKUBhDiARIsAMaTLnELeV-Tlk66WpFiGwL1QfR56qoWNEJtuIKELE6tP5njrRa25UCGRpoaAoqMEALw_wcB&amp;gclsrc=aw.ds">Google Chrome</a></p>
<p>MarkText：<a href="https://github.com/marktext/marktext">https://github.com/marktext/marktext(markdown编辑器)</a></p>
<p>NeeView：<a href="https://bitbucket.org/neelabo/neeview/downloads/">https://bitbucket.org/neelabo/neeview/downloads/(漫画、图片浏览器)</a></p>
<p>Audacity：<a href="https://github.com/audacity/audacity/releases">https://www.audacityteam.org/(音频剪辑软件)</a></p>
<p>DaVinCi：<a href="https://www.blackmagicdesign.com/products/davinciresolve">https://www.blackmagicdesign.com/products/davinciresolve(视频剪辑)</a></p>
<p>blivechat：<a href="https://github.com/xfgryujk/blivechat">https://github.com/xfgryujk/blivechat(B站直播弹幕工具)</a></p>
<p>everything：<a href="https://www.voidtools.com/">https://www.voidtools.com/(查找文件)</a></p>
<p>exhentai-manga-manager：<a href="https://github.com/SchneeHertz/exhentai-manga-manager">https://github.com/SchneeHertz/exhentai-manga-manager(E站漫画管理)</a></p>
<p>SumatraPDF：<a href="https://github.com/sumatrapdfreader/sumatrapdf">https://github.com/sumatrapdfreader/sumatrapdf</a></p>
<p>Office Tool Plus：<a href="https://otp.landian.vip/en-us/">https://otp.landian.vip/en-us/(office办公套件破解)</a></p>
<p>PowerToys:<a href="https://github.com/microsoft/PowerToys/tree/">https://github.com/microsoft/PowerToys/tree/(微软官方工具集)</a></p>
<p>honeyview:<a href="https://en.bandisoft.com/honeyview/">https://en.bandisoft.com/honeyview/（看图软件）</a></p>
<h3 id="工具类："><a class="header-anchor" href="#工具类：">¶</a>工具类：</h3>
<p>Vscode：<a href="https://code.visualstudio.com/Download" data-type="URL" data-id="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p>
<p>IntelliJ IDEA：<a href="https://www.jetbrains.com/zh-cn/idea/download/">https://www.jetbrains.com/zh-cn/idea/download/</a></p>
<p>Xshell：<a href="https://www.xshell.com/zh/xshell-download/" data-type="URL" data-id="https://www.xshell.com/zh/xshell-download/">https://www.xshell.com/zh/xshell-download/</a></p>
<p>tabby：<a href="https://github.com/Eugeny/tabby">https://github.com/Eugeny/tabby</a></p>
<p>Xftp：<a href="https://www.xshell.com/zh/xftp-download/" data-type="URL" data-id="https://www.xshell.com/zh/xftp-download/">https://www.xshell.com/zh/xftp-download/</a></p>
<p>Wireshark：<a href="https://www.wireshark.org/#download" data-type="URL" data-id="https://www.wireshark.org/#download">https://www.wireshark.org/#download</a></p>
<p>Python：<a href="https://www.python.org/downloads/" data-type="URL" data-id="https://www.python.org/downloads/">https://www.python.org/downloads/</a></p>
<p>Live2D：<a href="https://www.live2d.com/zh-CHS/" data-type="URL" data-id="https://www.live2d.com/zh-CHS/">https://www.live2d.com/zh-CHS/</a></p>
<p>Vmware：<a href="https://www.vmware.com/products/workstation-player.html">https://www.vmware.com/products/workstation-player.html</a></p>
<p>waifu2x-caffe：<a href="https://github.com/lltcggie/waifu2x-caffe">https://github.com/lltcggie/waifu2x-caffe(二次元画面优化)</a></p>
<p>Ultimate Vocal Remover：<a href="https://github.com/Anjok07/ultimatevocalremovergui">https://github.com/Anjok07/ultimatevocalremovergui(分离人声和伴奏)</a></p>
<p>aria2：<a href="https://github.com/aria2/aria2/releases/">https://github.com/aria2/aria2/releases/</a></p>
<p>nodejs：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<p>Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<p>renpy：<a href="https://www.renpy.org/">https://www.renpy.org/(galgame制作软件)</a></p>
<p>calibre：<a href="https://calibre-ebook.com/download">https://calibre-ebook.com/download(电子书制作)</a></p>
<p>blender：<a href="https://www.blender.org/">https://www.blender.org/</a></p>
<p>geek:<a href="https://geekuninstaller.com/download">https://geekuninstaller.com/download</a></p>
<h3 id="驱动类："><a class="header-anchor" href="#驱动类：">¶</a>驱动类：</h3>
<p>Epson打印机驱动：<a href="https://www.epson.com.cn/services/guidedrive.html">https://www.epson.com.cn/services/guidedrive.html</a></p>
<p>显卡、CPU等驱动：<a href="https://tool.pc.wiki/">https://tool.pc.wiki/</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>PC</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>装机软件</tag>
      </tags>
  </entry>
  <entry>
    <title>QuantumultX 使用记录</title>
    <url>/2023/11/11/ebb5d4dc5598/</url>
    <content><![CDATA[<h2 id="记录一下QuantumultX的使用教程和一些规则"><a class="header-anchor" href="#记录一下QuantumultX的使用教程和一些规则">¶</a>记录一下QuantumultX的使用教程和一些规则</h2>
<span id="more"></span>
<h2 id="如何添加JS脚本"><a class="header-anchor" href="#如何添加JS脚本">¶</a>如何添加JS脚本</h2>
<p>点击规则资源-&gt;右上角第三个-&gt;在资源路径里填上要订阅的脚本链接即可</p>
<p>添加完成后可以在最下面的配置文件的[rewrite-remote]标签下修改参数</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/QuantumultX-1.5d23jmborug0.webp" alt="QuantumultX-1"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>实用工具教程</category>
      </categories>
      <tags>
        <tag>QuantumultX</tag>
      </tags>
  </entry>
  <entry>
    <title>博客视频外链引用</title>
    <url>/2022/08/11/607cac6fe835/</url>
    <content><![CDATA[<p>现在主流流媒体网站都支持外链嵌入代码，但是B站<span class="heimu" title="你知道的太多了">(什么时候倒闭?)</span>现在(2022/8/11)自带的外链引用默认为360P，且不能调节清晰度，非常的恶心，与Youtube相比高下立判，下面重点介绍一下B站的引用外链的参数和方法:</p>
<span id="more"></span>
<p><strong><a href="#key">Bilibili外链引用参数key</a></strong><br>
<strong><a href="#%E8%A7%86%E9%A2%91%E6%BC%94%E7%A4%BA">具体视频演示</a></strong></p>
<h2 id="Bilibili外链引用"><a class="header-anchor" href="#Bilibili外链引用">¶</a>Bilibili外链引用</h2>
<p><strong>原版引用链接：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=80433022&amp;bvid=BV1GJ411x7h7&amp;cid=137649199&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>修改后引用链接：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=80433022&amp;bvid=BV1GJ411x7h7&amp;cid=137649199&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="key"> 哔哩哔哩外链key说明：</h3>
<table>
<tr>
<th bgcolor = "#FFC0CB">key</th> <th bgcolor = "#FFC0CB">说明</th>
</tr>
<tr>
<td>aid</td> <td>之前 B 站使用的 AV 号</td>
</tr>
<tr>
<td>bvid</td> <td>目前的 BV 号</td>
</tr>
<tr>
<td>page</td> <td>第几个视频, 起始下标为 1 (默认值也是为 1)就是 B 站视频, 选集里的, 第几个视频</td>
</tr>
<tr>
<td>as_wide</td> <td>是否宽屏 【1: 宽屏, 0: 小屏】</td>
</tr>
<tr>
<td>high_quality</td> <td>是否高清 【1: 高清(最高1080p) / 0: 最低视频质量(默认)】</td>
</tr>
<tr>
<td>danmaku</td> <td>是否开启弹幕 【1: 开启(默认), 0: 关闭】</td>
</tr>
<tr>
<td>vd_source=XXX&t=XXX</td>    <td>可加精准空降地址</td>
</tr>
</table>
<h2 id="YouTube外链引用"><a class="header-anchor" href="#YouTube外链引用">¶</a>YouTube外链引用</h2>
<p>使用默认的YouTube外链即可,更高级功能可自己去<a href="https://developers.google.com/youtube/iframe_api_reference">官方教程</a>学习</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">width</span>=<span class="string">&quot;560&quot;</span> <span class="attr">height</span>=<span class="string">&quot;315&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://www.youtube.com/embed/OgcCOwj7wNY&quot;</span> <span class="attr">title</span>=<span class="string">&quot;YouTube video player&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allow</span>=<span class="string">&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="视频演示"><a class="header-anchor" href="#视频演示">¶</a>视频演示</h2>
<h3 id="Youtube"><a class="header-anchor" href="#Youtube">¶</a>Youtube</h3>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ucbx9we6EHk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3 id="Bilibili-修改前"><a class="header-anchor" href="#Bilibili-修改前">¶</a>Bilibili(修改前)</h3>
<iframe src="//player.bilibili.com/player.html?aid=499408391&bvid=BV16K411N7qj&cid=230404689&page=1&as_wide=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<h3 id="Bilibili-修改后"><a class="header-anchor" href="#Bilibili-修改后">¶</a>Bilibili(修改后)</h3>
<iframe src="//player.bilibili.com/player.html?aid=499408391&bvid=BV16K411N7qj&cid=230404689&page=1&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<hr>
<p>参考资料: <a href="https://bestzuo.cn/posts/blog-bilbli.html">Sanarous博客</a>和<a href="https://developers.google.com/youtube/iframe_api_reference">谷歌外链API教程</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端</category>
        <category>网站建设</category>
      </categories>
  </entry>
  <entry>
    <title>01背包-目标和</title>
    <url>/2024/12/06/f910e508c34f/</url>
    <content><![CDATA[<h2 id="题面"><a class="header-anchor" href="#题面">¶</a>题面</h2>
<p><a href="https://leetcode.cn/problems/target-sum/">力扣题目链接-目标和</a></p>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p><strong>示例：</strong></p>
<p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>
输出：5</p>
<p><strong>解释</strong>：</p>
<p>-1+1+1+1+1 = 3<br>
+1-1+1+1+1 = 3<br>
+1+1-1+1+1 = 3<br>
+1+1+1-1+1 = 3<br>
+1+1+1+1-1 = 3<br>
一共有5种方法让最终目标和为3。</p>
<p><strong>提示</strong>：</p>
<ul>
<li>数组非空，且长度不会超过 20 。</li>
<li>初始的数组的和不会超过 1000 。</li>
<li>保证返回的最终结果能被 32 位整数存下。</li>
</ul>
<h2 id="解析"><a class="header-anchor" href="#解析">¶</a>解析</h2>
<p>记加负号的元素之和为neg，加正号的元素之和为pos</p>
<p>例如：<br>
给出的数组是 [1，1，1，1，1]<br>
目标的结果是 3<br>
其中的一种组合方法为 +1+1+1 -1 --&gt; pos = 3, neg = 1</p>
<p>$target = pos - ( neg )------①$<br>
这里的关键在于把neg的负号提出来，所以:<br>
$pos + neg = sum(sum是所有元素之和)------②$<br>
②式变换：<br>
$pos = sum - neg------③$<br>
把③带入①式:<br>
$target = (sum - neg) - (neg)------④$<br>
最后：<br>
$neg = \frac{sum - target}{2}$</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法</category>
        <category>动态规划01背包</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>信奥竞赛技巧</title>
    <url>/2024/10/28/9112d7b96d10/</url>
    <content><![CDATA[<h2 id="简介-v3"><a class="header-anchor" href="#简介-v3">¶</a>简介</h2>
<span id="more"></span>
<h2 id="STL容器"><a class="header-anchor" href="#STL容器">¶</a>STL容器</h2>
<p>见 站内：cpp STL详解</p>
<h2 id="算法"><a class="header-anchor" href="#算法">¶</a>算法</h2>
<h2 id="技巧"><a class="header-anchor" href="#技巧">¶</a>技巧</h2>
<h3 id="输入输出加速代码"><a class="header-anchor" href="#输入输出加速代码">¶</a>输入输出加速代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); <span class="comment">//输入输出加速</span></span><br></pre></td></tr></table></figure>
<p>作用</p>
<ul>
<li>取消同步：<br>
默认情况下，C++ 的标准输入输出流（cin 和 cout）与 C 的标准输入输出流（stdin 和 stdout）是同步的。这意味着每次使用 cin 和 cout 时，都会确保两者的状态一致，这样会导致性能损失。<br>
调用 ios::sync_with_stdio(false); 可以取消这种同步，使得 C++ 的输入输出流更快，因为不再需要每次都保持同步。</li>
<li>提高性能：<br>
在处理大量输入输出时，取消同步后，使用 cin 和 cout 的性能会显著提高。这在竞争性编程或需要快速处理大量数据的场合中非常有用。</li>
</ul>
<h3 id="字符串读取空白、回车问题"><a class="header-anchor" href="#字符串读取空白、回车问题">¶</a>字符串读取空白、回车问题</h3>
<ol>
<li>方法1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用下面代码可以让字符串s忽略掉换行、空白</span></span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin &gt;&gt; ws, s);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>方法2</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用下面代码可以让字符串s不读取掉换行</span></span><br><span class="line"><span class="comment">//使用cin.get()吃掉换行</span></span><br><span class="line">string s;</span><br><span class="line">cin.<span class="built_in">get</span>();  <span class="comment">//读取换行</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure>
<h3 id="cin-getline-与getline-的区别"><a class="header-anchor" href="#cin-getline-与getline-的区别">¶</a><a href="https://www.geeksforgeeks.org/getline-string-c/">cin.getline()与getline()的区别</a></h3>
<p>cin.getline要使用字符数组做参数，getline要使用字符串做参数</p>
<p><code>cin.getline(字符数组,读取的长度);</code></p>
<p><code>getline(cin,字符串名)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">   string s;</span><br><span class="line">cin.<span class="built_in">getline</span>(name,<span class="number">20</span>); <span class="comment">//OK </span></span><br><span class="line">   <span class="built_in">getline</span>(cin,name);    <span class="comment">//ERROR</span></span><br><span class="line"></span><br><span class="line">   cin.<span class="built_in">getline</span>(s,<span class="number">20</span>);    <span class="comment">//ERROR</span></span><br><span class="line">   <span class="built_in">getline</span>(cin,s);       <span class="comment">//OK</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>信奥竞赛</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL&amp;语法辨析</title>
    <url>/2024/10/28/73901e16de05/</url>
    <content><![CDATA[<h2 id="set容器"><a class="header-anchor" href="#set容器">¶</a>set容器</h2>
<p><a href="https://www.cnblogs.com/linuxAndMcu/p/10261014.html#_label2">https://www.cnblogs.com/linuxAndMcu/p/10261014.html#_label2</a></p>
<h2 id="字符串和字符数组"><a class="header-anchor" href="#字符串和字符数组">¶</a>字符串和字符数组</h2>
<h3 id="cin-getline-与getline-的区别-v2"><a class="header-anchor" href="#cin-getline-与getline-的区别-v2">¶</a><a href="https://www.geeksforgeeks.org/getline-string-c/">cin.getline()与getline()的区别</a></h3>
<p>cin.getline要使用字符数组做参数，getline要使用字符串做参数</p>
<p><code>cin.getline(字符数组,读取的长度);</code></p>
<p><code>getline(cin,字符串名)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">   string s;</span><br><span class="line">cin.<span class="built_in">getline</span>(name,<span class="number">20</span>); <span class="comment">//OK </span></span><br><span class="line">   <span class="built_in">getline</span>(cin,name);    <span class="comment">//ERROR</span></span><br><span class="line"></span><br><span class="line">   cin.<span class="built_in">getline</span>(s,<span class="number">20</span>);    <span class="comment">//ERROR</span></span><br><span class="line">   <span class="built_in">getline</span>(cin,s);       <span class="comment">//OK</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="sort排序"><a class="header-anchor" href="#sort排序">¶</a>sort排序</h2>
<p>sort主要是使用了快排并融合了堆排序等方法</p>
<h3 id="基本用法（一维数组）"><a class="header-anchor" href="#基本用法（一维数组）">¶</a>基本用法（一维数组）</h3>
<ol>
<li>默认对传入的数据进行从小到大排序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>可以使用cmp函数改变排序规则<br>
使用cmp函数改为从大到小排序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组排序"><a class="header-anchor" href="#二维数组排序">¶</a>二维数组排序</h3>
<p>sort()函数，默认的是对二维数组按照第一列的大小对每行的数组进行排序。<br>
所以可以加上cmp函数用按照任意列对数组进行排序。</p>
<p>下列代码是对数组的第二列按照从大到小排序(第一列应该是a[0] &gt; b[0])</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习笔记</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法</title>
    <url>/2024/12/02/5821c98090f1/</url>
    <content><![CDATA[<h3 id="动态规划"><a class="header-anchor" href="#动态规划">¶</a>动态规划</h3>
<h3 id="总方法论-动态规划五部曲"><a class="header-anchor" href="#总方法论-动态规划五部曲">¶</a>总方法论 - 动态规划五部曲</h3>
<ol>
<li>确定DP数组（DP table）以及下标的含义
<ul>
<li>动态规划的核心在于理解和明确DP数组所表示的含义</li>
<li>在进行动态规划递推公式推导的时候要紧紧围绕着DP数组的含义</li>
</ul>
</li>
<li>推导递推公式
<ul>
<li>推导递推公式的关键在于找到当前状态可以由哪些状态转移而来</li>
<li>要搞清楚可以从哪些状态转移来就要紧紧围绕着DP数组的含义</li>
</ul>
</li>
<li>dp数组如何初始化
<ul>
<li>在确定递推公式之后在进行初始化</li>
</ul>
</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组
<ul>
<li>如果动规结果不正确，最好的方式是打印出来DP数组的值，分析与预期结果哪里不正确</li>
</ul>
</li>
</ol>
<h3 id="动态规划：01背包理论基础"><a class="header-anchor" href="#动态规划：01背包理论基础">¶</a>动态规划：01背包理论基础</h3>
<h4 id="01背包问题基本题目（二维数组解法）"><a class="header-anchor" href="#01背包问题基本题目（二维数组解法）">¶</a>01背包问题基本题目（二维数组解法）</h4>
<hr>
<p><strong>题目描述</strong><br>
有个背包可承受重量N，现有T件物品，每件物品重量为Wi,价值为Vi ,每件物品只有一个,这个背包可以装载物品的最大价值是多少?<br>
<strong>输入格式</strong><br>
第一行，两个整数，分别表示N和T，用空格隔开（N≤1000，T≤100）<br>
接下来T行，每行两个整数，分别表示T件物品的重量Wi和价值Vi（1≤Wi,Vi≤100）<br>
<strong>输出格式</strong><br>
一行，表示这个背包可以装载物品的最大价值<br>
<strong>输入输出样例</strong><br>
<strong>输入样例1：</strong><br>
100 5<br>
77 92<br>
22 22<br>
29 87<br>
50 46<br>
99 90<br>
<strong>输出样例1：</strong><br>
133</p>
<hr>
<p>模拟过程(画图)可以参考：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E6%80%9D%E8%B7%AF">背包理论基础01背包-1</a></p>
<h5 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h5>
<ol>
<li>
<p><strong>状态转移过程</strong><br>
dp[i][j]的转移可以由它的上方（dp[i-1][j]）和左上方转移（dp[i-1][j-weights[i]] + values[i]）而来<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E7%AE%97%E6%B3%95-01%E8%83%8C%E5%8C%85-1.38smsyo10se.webp" alt="算法-01背包-1"></p>
</li>
<li>
<p><strong><code>dp[0][j]</code> 和 <code>dp[i][0]</code> 的初始化</strong></p>
<ul>
<li><code>dp[i][0]</code> <strong>初始化为0</strong>，因为在背包载重为0时总价值肯定全为0</li>
<li><code>dp[0][j]</code> 第一行表示装第一个物品后背包的价值（对应<code>dp[0][i] = values[0]</code>）<br>
如果背包的载重装不了第一个物品则价值还是为零（对应<code>i = weights[0]</code>，也就是从背包载重能满足第一个物品开始</li>
</ul>
</li>
<li>
<p><strong>DP数组的其他值该如何初始化？</strong></p>
<ul>
<li>都可以，0、-1、-100都没有关系，因为DP数组的其他值都是由之前的状态转移而来的</li>
</ul>
</li>
<li>
<p><strong>遍历顺序，填充DP数组</strong></p>
<ul>
<li>那么问题来了，先遍历 物品还是先遍历背包重量呢？</li>
<li>其实都可以！！ 但是先遍历物品更好理解。
<ul>
<li>物品的遍历从第二个开始</li>
<li>背包重量的遍历从0开始</li>
<li>如果背包重量小于当前物品的重量，那么就继承<code>dp[i - 1][j]</code>的值<br>
<code>if(j &lt; weights[i])  dp[i][j] = dp[i-1][j];</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="题解"><a class="header-anchor" href="#题解">¶</a>题解</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,t;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp[i][j] 的含义是表示从下标为[0-i]的物品里任意取放进容量为j的背包</span></span><br><span class="line"><span class="comment">，价值总和最大是多少</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span><span class="number">+10</span>][<span class="number">1000</span><span class="number">+10</span>];</span><br><span class="line"><span class="type">int</span> weights[<span class="number">100</span><span class="number">+10</span>];</span><br><span class="line"><span class="type">int</span> values[<span class="number">100</span><span class="number">+10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; t;i++)&#123;</span><br><span class="line">        cin&gt;&gt;weights[i]&gt;&gt;values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化DP数组</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 背包承重为0，第一列全初始化为0（对应的dp[][0] = 0）</span></span><br><span class="line"><span class="comment">    2. 第一行表示装第一个物品后背包的价值（对应dp[0][i] = values[0]）</span></span><br><span class="line"><span class="comment">        如果背包的载重装不了第一个物品则价值还是为零（对应i = weights[0]，</span></span><br><span class="line"><span class="comment">        也就是从背包载重能满足第一个物品开始</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = weights[<span class="number">0</span>]; j &lt;= n; j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = values[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 递推公式：dp[i][j] = max(dp[i-1][j],dp[i-1][j-weights[i]] + values[i]);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp[i][j] 可以由两个状态得到：</span></span><br><span class="line"><span class="comment">1. 放物品i  ----&gt; dp[i-1][j]</span></span><br><span class="line"><span class="comment">2.不放物品i ----&gt; dp[i-1][j-weights[i]] + values[i]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在两者中取其大</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先遍历物品再遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; t; i++)&#123;   <span class="comment">// 遍历物品(从第二个物品开始遍历)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;  <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="comment">// 如果装不下这个物品,那么就继承dp[i - 1][j]的值</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; weights[i])  dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-weights[i]] + values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[t<span class="number">-1</span>][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="01背包问题（一维数组解法）"><a class="header-anchor" href="#01背包问题（一维数组解法）">¶</a>01背包问题（一维数组解法）</h4>
<h5 id="注意点"><a class="header-anchor" href="#注意点">¶</a>注意点</h5>
<ol>
<li><strong>为什么可以不对第一行进行初始化</strong><br>
因为在后续的滚动过程中就相当于完成了这个初始化过程</li>
<li><strong>dp[i] 的含义容量为i的背包，所背的物品价值可以最大为dp[i]</strong></li>
<li><strong>为什么在使用滚动数组的时要倒序遍历背包容量</strong><br>
因为如果使用正序遍历，在计算dp[i]时会用到dp[i-1]，而这时dp[i-1]已经被修改了，<br>
倒序遍历是为了保证物品i只被放入一次，如果一旦正序遍历了，那么物品0就会被重复加入多次！</li>
<li><strong>使用滚动数组二重循环能否调换顺序</strong><br>
不可以！<br>
因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</li>
</ol>
<h5 id="题解-v2"><a class="header-anchor" href="#题解-v2">¶</a>题解</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,t;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp[i] 的含义容量为i的背包，所背的物品价值可以最大为dp[i]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000</span><span class="number">+10</span>];</span><br><span class="line"><span class="type">int</span> weights[<span class="number">100</span><span class="number">+10</span>];</span><br><span class="line"><span class="type">int</span> values[<span class="number">100</span><span class="number">+10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; t;i++)&#123;</span><br><span class="line">        cin&gt;&gt;weights[i]&gt;&gt;values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用一维数组时可以不对第一行进行特殊的初始化</span></span><br><span class="line">    <span class="comment">//因为在后续的滚动过程中就相当于完成了这个初始化过程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int j = weights[0]; j &lt;= n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//     dp[j] = values[0];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 先遍历物品再遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)&#123;   <span class="comment">// 遍历物品(从第1个物品开始遍历)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= weights[i]; j--)&#123;  <span class="comment">// 倒序遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j],dp[j-weights[i]] + values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度算法</title>
    <url>/2024/12/14/5b1482e0ddf6/</url>
    <content><![CDATA[<h3 id="高精度问题"><a class="header-anchor" href="#高精度问题">¶</a>高精度问题</h3>
<p>高精度主要是解决处理大整数时的问题，这里的整数范围要超过longlong。<br>
高精度问题的核心就是使用字符串去模拟加法、减法、乘法、除法运算</p>
<h3 id="高精度加法"><a class="header-anchor" href="#高精度加法">¶</a>高精度加法</h3>
<h4 id="基本"><a class="header-anchor" href="#基本">¶</a>基本</h4>
<p>使用三个数组<code>a[],b[],c[]</code>存储<br>
<strong>模拟加法竖式</strong>：累加  进位  留位</p>
<ul>
<li>
<p>累加： <code>c[i] += a[i] + b[i]</code>  ——&gt;必须要累加之前的进位，使用 <strong>+=</strong> //累加进位和对应位置的数字</p>
</li>
<li>
<p>进位：<code>c[i+1] = c[i] / 10;</code></p>
</li>
<li>
<p>留位：<code>c[i] %= 10;</code></p>
</li>
</ul>
<p><strong>Q1：假设正整数A的长度为n,正整数B的长度为m，那么A+B的长度最大为多少？最小为多少？</strong></p>
<ul>
<li><strong>A1：</strong> 长度最大：<code>max(n,m)+1</code>   长度最小：<code>max(n,m)</code></li>
</ul>
<h4 id="算法步骤"><a class="header-anchor" href="#算法步骤">¶</a>算法步骤</h4>
<ol>
<li>高精度数的读取与存储：使用字符串方式读取，然后将每一个字符转为整数，<strong>逆向存储</strong>到一个整型数组中</li>
<li>模拟加法操作：通过数组下标模拟两个加数中每一个为上数的加法（累加、进位、留位）</li>
<li>去除前导0，逆向重组（因为之前是逆向加，再反过来）</li>
</ol>
<h4 id="高精度加法函数"><a class="header-anchor" href="#高精度加法函数">¶</a>高精度加法函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a,b数组用于存储A,B两个加数，c数组用于存储相加之和</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">200</span><span class="number">+10</span>],b[<span class="number">200</span><span class="number">+10</span>],c[<span class="number">200</span><span class="number">+10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Add</span><span class="params">(string as,string bs)</span></span>&#123;</span><br><span class="line">    <span class="comment">//清空a,b,c数组</span></span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求出as bs字符串的长度</span></span><br><span class="line">    <span class="type">int</span> alen = as.<span class="built_in">size</span>(),blen = bs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> clen = <span class="built_in">max</span>(alen,blen) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串转为整型数组，并且逆向存储</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=alen; i++)</span><br><span class="line">        a[i] = as[alen - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=blen; i++)</span><br><span class="line">        b[i] = bs[blen - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟加法计算：累加 进位 留位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=clen; i++)&#123;</span><br><span class="line">        c[i] += a[i] + b[i];    <span class="comment">//一定要使用&#x27;+=&#x27;累加进位</span></span><br><span class="line">        c[i<span class="number">+1</span>] = c[i]/<span class="number">10</span>;   <span class="comment">//进位</span></span><br><span class="line">        c[i] = c[i]%<span class="number">10</span>;     <span class="comment">//留位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="comment">//clen&gt;1：如果只有一位数字0要保留，所以只到第二位</span></span><br><span class="line">    <span class="keyword">while</span>(c[clen] == <span class="number">0</span> &amp;&amp; clen&gt;<span class="number">1</span>)</span><br><span class="line">        clen--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逆向重组</span></span><br><span class="line">    string cs = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=clen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        cs += c[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="高精度减法"><a class="header-anchor" href="#高精度减法">¶</a>高精度减法</h3>
<h4 id="基本-v2"><a class="header-anchor" href="#基本-v2">¶</a>基本</h4>
<ol>
<li>如果<code>a[i] &lt; b[i] </code>：说明a[i] 需要向a[i+1]借位：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[i<span class="number">+1</span>]--;</span><br><span class="line">a[i]+=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>模拟减法：<code>c[i] = a[i] - b[i];</code></li>
<li>高精度减法的程序计算中都默认a 是大于 b来计算的，如果实际情况是a &lt; b，那么只需要交换一下a，b即可</li>
<li>下面提到的a、as都是指减法运算中较大的那一个（被减数），b、bs同理都是值减数</li>
</ol>
<p><strong>Q1: 如果a[i+1] == 0，这样借位会不会有问题</strong></p>
<ul>
<li><strong>A1：</strong> 不会，因为最多只会借一位。a[i+1]被借位后等于-1，因为<strong>a&gt;b</strong>(在模拟计算的算法中都转化为a&gt;b来计算，后文详解)，a[i+1]还可以向a[i+2]借位。借位后a[i+1] == 9，而b[i+1]最大也才为9。</li>
</ul>
<h4 id="算法步骤-v2"><a class="header-anchor" href="#算法步骤-v2">¶</a>算法步骤</h4>
<ol>
<li>高精度数的读取与存储：使用字符串方式读取，然后将每一个字符转为整数，<strong>逆向存储</strong>到一个整型数组中</li>
<li>模拟减法计算：相同位置进行相减，不够减时<strong>向高位借位</strong></li>
<li>去除前导0，再逆序输出</li>
</ol>
<p><strong>Q1：两个长整数a,b，并且a&gt;b，长度分别为n,m，那么c = a-b的长度最长为多少？</strong></p>
<ul>
<li><strong>A1：n</strong></li>
</ul>
<p><strong>Q2：两个正整数字符串as,bs，如何判断as和bs的大小（也即a和b的大小）？</strong></p>
<ul>
<li><strong>A2</strong> ：<code>if( as.size() &lt; bs.size() || (as.size() == bs.size() &amp;&amp; as &lt; bs))</code> 成立，那么说明 <code>as &lt; bs ---&gt; 长整数a &lt; b</code></li>
</ul>
<p><strong>Q3：如果a&lt;b，如何计算a-b的值呢？</strong></p>
<ul>
<li><strong>A3：</strong> 交换a和b的值，然后计算a-b，结果输出一个负号</li>
</ul>
<h4 id="计算高精度减法函数"><a class="header-anchor" href="#计算高精度减法函数">¶</a>计算高精度减法函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">200</span><span class="number">+10</span>],b[<span class="number">200</span><span class="number">+10</span>],c[<span class="number">200</span><span class="number">+10</span>];</span><br><span class="line"><span class="function">string <span class="title">Sub</span><span class="params">(string as,string bs)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line"></span><br><span class="line">    string cs = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//预处理，比较as和bs的大小，来确定正负号和决定是否交换</span></span><br><span class="line">    <span class="comment">// 处理后要求as比bs大，计算都默认as比bs大</span></span><br><span class="line">    <span class="keyword">if</span>(as.<span class="built_in">size</span>() &lt; bs.<span class="built_in">size</span>() || (as.<span class="built_in">size</span>() == bs.<span class="built_in">size</span>() &amp;&amp; as &lt; bs))&#123;</span><br><span class="line">        cs += <span class="string">&#x27;-&#x27;</span>;  <span class="comment">//结果字符串加一个负号</span></span><br><span class="line">        as.<span class="built_in">swap</span>(bs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> alen = as.<span class="built_in">size</span>(),blen = bs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> clen = alen;    <span class="comment">//因为as是较大的数，</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串转整型数组，逆序存储</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alen;i++)</span><br><span class="line">        a[i] = as[alen - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=blen;i++)</span><br><span class="line">        b[i] = bs[blen - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//模拟减法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=clen;i++)&#123;</span><br><span class="line">        <span class="comment">//模拟a[i]向a[i+1]借位</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;b[i])&#123;</span><br><span class="line">            a[i<span class="number">+1</span>]--;</span><br><span class="line">            a[i] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c[i] = a[i] - b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span>(c[clen]==<span class="number">0</span> &amp;&amp; clen&gt;<span class="number">1</span>) clen--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逆向重组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=clen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        cs+=c[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string as,bs,cs;</span><br><span class="line">    <span class="built_in">getline</span>(cin,as);</span><br><span class="line">    <span class="built_in">getline</span>(cin,bs);</span><br><span class="line">    cs = <span class="built_in">Sub</span>(as,bs);</span><br><span class="line">    cout&lt;&lt;cs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度乘法"><a class="header-anchor" href="#高精度乘法">¶</a>高精度乘法</h3>
<h4 id="基本-v3"><a class="header-anchor" href="#基本-v3">¶</a>基本</h4>
<ol>
<li>本质上还是使用字符串来模拟整数的乘法计算过程</li>
</ol>
<hr>
<p>$\qquad\qquad\qquad b_3 \qquad\qquad\qquad b_2 \qquad\qquad\qquad b_1$<br>
$\times\qquad\qquad\qquad\qquad\qquad\qquad a_2 \qquad\qquad\qquad a_1$<br>
$—————————————————————————$<br>
$\qquad\qquad\qquad b_3\ast a_1 \qquad\qquad b_2\ast a_1 \qquad\qquad b_1\ast a_1$<br>
$\quad b_3\ast a_1 \qquad b_2\ast a_1 \qquad\qquad b_1\ast a_1$<br>
$—————————————————————————$<br>
$\qquad c_4 \quad\quad\qquad c_3 \qquad\qquad\qquad c_2 \qquad\qquad\qquad c_1$</p>
<hr>
<ol start="2">
<li>观察式子的下标可以发现 <code>c[i+j-1] += a[i]*b[j]</code></li>
</ol>
<p><strong>高精度乘法算式的模拟</strong></p>
<ol>
<li>下面的模拟是按照乘法结果的每一行来模拟的，即先把 $a_1$ 与b相乘的加到c中去，再把 $a_2$ 与b相乘的加到c中去</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alen;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=blen;j++)&#123;</span><br><span class="line">        c[i+j<span class="number">-1</span>] += a[i]*b[j];  <span class="comment">//前一项的进位也加在c[i+j-1]中</span></span><br><span class="line">        c[i+j] += c[i+j<span class="number">-1</span>] / <span class="number">10</span>;    <span class="comment">//因为是要处理多行，所以可能会有多次进位</span></span><br><span class="line">        c[i+j<span class="number">-1</span>] %= <span class="number">10</span>;     <span class="comment">//留位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q1：设整数A的长度为n，整数B的长度为m，那么A*B的长度最大为多少，最小为多少</strong></p>
<ul>
<li><strong>A1：</strong> A*B的长度最长不会超过n+m，最短不会低于max(n,m)</li>
</ul>
<h4 id="算法步骤-v3"><a class="header-anchor" href="#算法步骤-v3">¶</a>算法步骤</h4>
<p>时间复杂度O(n*m)</p>
<ol>
<li>高精度数的读取与存储：使用字符串方式读取，然后将每一个字符转为整数，<strong>逆向存储</strong>到一个整型数组中</li>
<li>模拟乘法计算</li>
<li>去除前导0</li>
<li>逆序重组</li>
</ol>
<h4 id="高精度乘法函数"><a class="header-anchor" href="#高精度乘法函数">¶</a>高精度乘法函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N+N];</span><br><span class="line"><span class="function">string <span class="title">Mult</span><span class="params">(string as,string bs)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line"></span><br><span class="line">    string cs = <span class="string">&quot;&quot;</span>; <span class="comment">//不能写成string cs = &quot; &quot;;</span></span><br><span class="line">    <span class="type">int</span> alen = as.<span class="built_in">size</span>(),blen = bs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> clen = alen + blen;</span><br><span class="line">    <span class="comment">// 字符串逆序转为整型数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alen;i++)</span><br><span class="line">        a[i] = as[alen - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=blen;i++)</span><br><span class="line">        b[i] = bs[blen - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟乘法算式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alen;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=blen;j++)&#123;</span><br><span class="line">            c[i+j<span class="number">-1</span>] += a[i]*b[j];</span><br><span class="line">            c[i+j] += c[i+j<span class="number">-1</span>] / <span class="number">10</span>;</span><br><span class="line">            c[i+j<span class="number">-1</span>] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c[clen] == <span class="number">0</span> &amp;&amp; clen&gt;<span class="number">1</span>)</span><br><span class="line">        clen--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=clen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        cs += c[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="高精度除法（长数-短数）"><a class="header-anchor" href="#高精度除法（长数-短数）">¶</a>高精度除法（长数/短数）</h3>
<p>这里的高精度除法指的是一个长数（被除数）和一个短数（除数）做高精度除法</p>
<h4 id="基本-v4"><a class="header-anchor" href="#基本-v4">¶</a>基本</h4>
<ol>
<li>将长数做字符串处理转为整数存入数组，但与高精度加减法和乘法不同，除法的长数不需要做逆向存储</li>
<li>模拟的过程是<strong>从长数的高位开始</strong>与除法进行除法与取模 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=clen;i++)&#123;</span><br><span class="line">    r = r*<span class="number">10</span> + a[i];    <span class="comment">//构造被除数,依次称10进位</span></span><br><span class="line">    c[i] = r/x; <span class="comment">//得到商</span></span><br><span class="line">    r %= x;    <span class="comment">//除剩的余数再进入到下一轮除法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>Q1：设长整数A的长度为n，短整数B的长度为m，那么A/B的长度最大为多少，最小为多少</strong></p>
<ul>
<li><strong>A1：</strong> A/B的长度最长不会超过n，最短为1</li>
</ul>
<h4 id="算法步骤-v4"><a class="header-anchor" href="#算法步骤-v4">¶</a>算法步骤</h4>
<ol>
<li>高精度数的读取与存储：使用字符串方式读取，然后将每一个字符转为整数，<strong>正向存储</strong>到一个整型数组中</li>
<li>从高位开始进行模拟除法计算</li>
<li>去除前导0</li>
<li>正序重组</li>
</ol>
<h4 id="高精度除法函数"><a class="header-anchor" href="#高精度除法函数">¶</a>高精度除法函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">10000</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> a[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Div</span><span class="params">(string as,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> alen = as.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> clen = alen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正向存储</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alen;i++)&#123;</span><br><span class="line">        a[i] = as[i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=clen;i++)&#123;</span><br><span class="line">        r = r*<span class="number">10</span> + a[i];</span><br><span class="line">        c[i] = r/x;</span><br><span class="line">        r %= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去除前导0，但不到clen</span></span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c[k] == <span class="number">0</span> &amp;&amp; k&lt;clen)&#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string cs=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;=clen;i++)&#123;</span><br><span class="line">        cs += c[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求余数"><a class="header-anchor" href="#求余数">¶</a>求余数</h4>
<p>同求商类似，最后只需要返回r即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">10000</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> a[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dremainder</span><span class="params">(string as,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> alen = as.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> clen = alen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正向存储</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alen;i++)&#123;</span><br><span class="line">        a[i] = as[i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=clen;i++)&#123;</span><br><span class="line">        r = r*<span class="number">10</span> + a[i];</span><br><span class="line">        c[i] = r/x;</span><br><span class="line">        r %= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法</category>
        <category>高精度</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器部署code-server</title>
    <url>/2022/08/15/386e2e093cea/</url>
    <content><![CDATA[<h2 id="部署-code-server"><a class="header-anchor" href="#部署-code-server">¶</a>部署 code-server</h2>
<ol>
<li>首先，我们需要下载 <strong>code-server</strong>，我们这里需要下载<a href="https://github.com/coder/code-server">最新版本的 code-server</a></li>
</ol>
<span id="more"></span>
<ol start="2">
<li>之后，我们使用 tar 工具解压下载得到的压缩包，之后进入解压好的文件目录中：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压缩 tar.gz 压缩包</span></span><br><span class="line">tar xf code-server-3.1.1.tar.gz <span class="comment">#3.1.1版本为例，具体按照包名而定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压得到的文件夹</span></span><br><span class="line"><span class="built_in">cd</span> code-server-3.1.1-linux-x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>设置登录密码启动</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PASSWORD=<span class="string">&quot;设置登录密码&quot;</span> </span><br><span class="line"><span class="comment">#这里我们是在服务器上面设置了名为 PASSWORD 的环境变量为 &#123;YOUR_CODE_SERVER_PASSWORD&#125;</span></span><br><span class="line"><span class="comment">#这样后面 code-server 启动后就会直接读取这一环境变量并将之作为你的登录密码。</span></span><br><span class="line"></span><br><span class="line">./code-server --host=<span class="string">&quot;0.0.0.0&quot;</span> <span class="comment">#启动服务</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>验证登录</li>
</ol>
<p>之后，code-server 进程就在远程服务器上启动并开始监听 8080 端口了，同时可以看到 code-server 正在使用我们自定义的密码（custom password）作为认证密码。这里，我们还需要将 code-server 默认监听的 8080 端口在服务器防火墙中设置开放，之后我们才能直接通过 <code>&#123;服务器 IP 地址&#125;:&#123;code-server 端口&#125;</code> 的 URL 地址在浏览器中直接访问 code-server。</p>
<p>如果一切顺利，此时我们在 iPad 上面用浏览器直接访问 {服务器 IP 地址}:{code-server 端口}，输入刚刚设置的密码，就能够打开一个完整的在线版 VS Code:</p>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2code-server1.2fypthb8vlhc.jpg" alt="云服务器部署code-server1"></p>
<h2 id="Docker部署"><a class="header-anchor" href="#Docker部署">¶</a>Docker部署</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker run -it -d -p 8080:8080 \</span><br><span class="line">  -v <span class="string">&quot;<span class="variable">$PWD</span>:/home/coder/project&quot;</span> \</span><br><span class="line">  -e PASSWORD=<span class="string">&#x27;设置你的登录密码&#x27;</span> \</span><br><span class="line">  -u <span class="string">&quot;<span class="subst">$(id -u)</span>:<span class="subst">$(id -g)</span>&quot;</span> \</span><br><span class="line">  codercom/code-server:latest</span><br></pre></td></tr></table></figure>
<hr>
<p>引用： <a href="https://www.bbsmax.com/A/x9J2YBAKz6/">https://www.bbsmax.com/A/x9J2YBAKz6/</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>实用工具教程</category>
      </categories>
  </entry>
  <entry>
    <title>服务器部署Komga漫画阅读器</title>
    <url>/2022/09/13/6576edfe5dd3/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>本地本子存太多了，突发奇想想搭建一个在线看漫画的服务，遂找到了Komga。<br>
下面记录一下如何在服务器的docker上部署</p>
<span id="more"></span>
<h2 id="安装步骤"><a class="header-anchor" href="#安装步骤">¶</a>安装步骤</h2>
<ol>
<li>
<p>服务器端需要安装Java环境，至少在JDK17及以上</p>
<ul>
<li>Centos为例：</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看云端yum库中目前支持安装的jdk软件包</span><br><span class="line">yum search java|grep jdk </span><br><span class="line"></span><br><span class="line">#选择版本安装jdk</span><br><span class="line">yum install -y java-17-openjdk</span><br><span class="line"></span><br><span class="line">#安装完成后，验证是否安装成功</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="https://github.com/gotson/komga/releases/">Komga的GitHub地址</a>，下载最新版本的jar文件，上传到服务器即可</p>
</li>
<li>
<p>在 CentOS 安装</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在komga中创建子目录</span></span><br><span class="line"><span class="built_in">mkdir</span> config </span><br><span class="line"><span class="built_in">mkdir</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line"><span class="built_in">cd</span> config</span><br><span class="line"><span class="built_in">touch</span> database.sqlite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行komga,版本号具体而论</span></span><br><span class="line">java -jar komga-***.jar</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p>运行<br>
在浏览器中输入 <a href="http://xn--IP-fr5c86lx7z:8080">http://服务器IP:8080</a>，就能看到主界面了，登录即可<br>
如果有其它服务在使用8080端口会导致安装失败，把另一个服务暂时关闭即可</p>
</li>
<li>
<p>docker运行</p>
</li>
</ol>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker create \</span><br><span class="line">  --name=komga \</span><br><span class="line">  --<span class="keyword">user</span> <span class="number">1000</span>:<span class="number">1000</span> \</span><br><span class="line">  -p <span class="number">3080</span>:<span class="number">8080</span> \ <span class="comment">#我这里选择3080端口映射</span></span><br><span class="line">  --mount type=bind,source=/path/to/config,target=/config \ <span class="comment">#/path/to/config 是刚才创建的文件</span></span><br><span class="line">  --mount type=bind,source=/path/to/data,target=/data \ <span class="comment">#/path/to/data 也是刚才创建的文件</span></span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  gotson/komga</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动docker</span></span><br><span class="line">docker start komga</span><br></pre></td></tr></table></figure>
<hr>
<p>内容部分来自互联网</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>实用工具教程</category>
      </categories>
      <tags>
        <tag>comic,Komga</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-计算机系统概述</title>
    <url>/2023/07/15/fefd9012fd96/</url>
    <content><![CDATA[<h2 id="简介-v4"><a class="header-anchor" href="#简介-v4">¶</a>简介</h2>
<p>操作系统系列其一，主要是针对中国大陆考研所要求的内容对操作系统的知识体系进行总结和梳理，对于重点内容会使用黑体加粗，本篇内容主要包含以下几点：</p>
<ul>
<li>操作系统的基本概念</li>
<li>操作系统发展历程</li>
<li>程序运行环境</li>
<li>操作系统结构</li>
<li>操作系统引导</li>
<li>虚拟机</li>
</ul>
<span id="more"></span>
<h2 id="大纲"><a class="header-anchor" href="#大纲">¶</a>大纲</h2>
<ul>
<li>操作系统的基本概念
<ul>
<li>操作系统的特征</li>
<li>操作系统接口</li>
</ul>
</li>
<li>操作系统的发展历程
<ul>
<li>批处理阶段</li>
<li>分时操作系统</li>
<li>实时操作系统</li>
</ul>
</li>
<li>操作系统的运行环境
<ul>
<li><strong>处理器的运行模式$\star$</strong></li>
<li><strong>中断和异常</strong></li>
</ul>
</li>
<li>操作系统结构</li>
<li>操作系统引导</li>
<li>虚拟机</li>
<li>典型例题</li>
</ul>
<h2 id="操作系统的基本概念"><a class="header-anchor" href="#操作系统的基本概念">¶</a>操作系统的基本概念</h2>
<p>操作系统（英语：Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统<strong>软件程序</strong>，同时也是计算机系统的内核与基石。</p>
<h3 id="操作系统的特征"><a class="header-anchor" href="#操作系统的特征">¶</a>操作系统的特征</h3>
<ol>
<li>并发<br>
并发：两个或者多个事件在<strong>同一个时间间隔内发生</strong>。这些事件在宏观上是同时发生的，在微观上是交替发生的。操作系统的并发是通过分时实现的<br>
并行：是指两个或者多个事件<strong>在同一时刻发生</strong></li>
<li>共享<br>
资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用
<ol>
<li>互斥共享方式：系统中的某些资源，可以提供给多个进程使用，但在同一时间段内，只允许一个进程访问</li>
<li>同时共享方式：系统中的某些资源，允许一个时间段内，多个进程&quot;同时&quot;对该资源进行访问</li>
</ol>
</li>
<li>虚拟<br>
把一个物理上的实体变为若干个逻辑上的对应物。</li>
<li>异步<br>
在多道程序环境下，运行多个程序并发执行，但是由于资源有限，进程的执行并不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性<br>
只有具有并发性才可能导致异步性</li>
</ol>
<h3 id="操作系统作为接口"><a class="header-anchor" href="#操作系统作为接口">¶</a>操作系统作为接口</h3>
<ol>
<li>命令接口
<ol>
<li>联机命令接口又称交互式命令接口。例如Linux的terminal终端</li>
<li>脱机命令接口又称批处理命令接口。例如Windows的bat批处理</li>
</ol>
</li>
<li><strong>程序接口</strong><br>
程序接口是一组系统调用（System call），也称广义命令。操作系统提供给应用程序的接口就是系统调用。</li>
</ol>
<h2 id="操作系统的发展历程"><a class="header-anchor" href="#操作系统的发展历程">¶</a>操作系统的发展历程</h2>
<h3 id="手工操作阶段（无操作系统）"><a class="header-anchor" href="#手工操作阶段（无操作系统）">¶</a>手工操作阶段（无操作系统）</h3>
<p>缺点：人机速度矛盾</p>
<ol>
<li>用户独占全机，资源利用率低</li>
<li>CPU等待手工操作，CPU利用不充分</li>
</ol>
<h3 id="批处理阶段（开始出现操作系统）"><a class="header-anchor" href="#批处理阶段（开始出现操作系统）">¶</a>批处理阶段（开始出现操作系统）</h3>
<ol>
<li>
<p>单道批处理系统</p>
<ul>
<li>优点：缓解人机速度矛盾</li>
<li>缺点：资源利用率低</li>
</ul>
</li>
<li>
<p>多道批处理系统<br>
多道程序系统是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行 (系统由一个程序转而运行另一个程序时需要使用中断机构中断正在运行的程序) 。两个或两个以上程序在计算机系统中同处于开始和结束之间的状态。其技术运行的特征：多道、宏观上并行、微观上串行。</p>
<ul>
<li>优点：多道程序并发执行，资源利用率高</li>
<li>缺点：没有人机交互功能</li>
</ul>
</li>
</ol>
<h3 id="分时操作系统"><a class="header-anchor" href="#分时操作系统">¶</a>分时操作系统</h3>
<ol>
<li>优点：提供人机交互功能</li>
<li>缺点：不能优先处理紧急任务</li>
</ol>
<h3 id="实时操作系统"><a class="header-anchor" href="#实时操作系统">¶</a>实时操作系统</h3>
<p>优点：能优先处理紧急任务</p>
<h2 id="操作系统的运行环境"><a class="header-anchor" href="#操作系统的运行环境">¶</a>操作系统的运行环境</h2>
<h3 id="处理器的运行模式-star"><a class="header-anchor" href="#处理器的运行模式-star">¶</a>处理器的运行模式$\star$</h3>
<p>在计算机系统中，CPU通常执行两种不同性质的程序：</p>
<ol>
<li>操作系统的内核程序</li>
<li>用户自编的应用程序</li>
</ol>
<p>其中，内核程序是应用程序的管理者。因此，内核程序需要执行一些特权指令，而应用程序不可以执行这些指令</p>
<ol>
<li>特权指令：不允许用户直接使用的指令，如I/O指令、置中断指令、存取用于内存保护的寄存器等的指令</li>
<li>非特权指令：是用户可以直接使用的指令，它不能直接访问系统中的软硬件资源，仅能访问用户的地址空间</li>
</ol>
<p>在具体实现上，可以将CPU的运行模式划分为用户态和核心态（或内核态、管态）。（通过修改PSW中的标志位）<br>
应用程序运行在用户态，操作系统内核程序运行在核心态。应用程序向操作系统请求服务时通过访管指令，从而产生中断事件将操作系统转换为核心态。</p>
<p>内核是计算机上配置的底层软件，大多数操作系统的内核包括四个方面：</p>
<ol>
<li>时钟管理<br>
时钟的第一功能是计时，其次，通过时钟中断管理可以实现进程的切换。</li>
<li>中断机制</li>
<li>原语<br>
原语是一些可被调用的公用小程序，它们具有以下特点：
<ol>
<li>处于操作系统的最底层，是最接近硬件的部分</li>
<li>原语的运行具有原子性，其操作只能一气呵成的完成（不可中断）</li>
<li>运行时间较短，且调用频繁</li>
</ol>
</li>
<li>系统控制的数据结构及处理<br>
常见的操作一般有以下三种：
<ol>
<li>进程管理：进程状态管理、调度和分派、创建和撤销进程控制块（PCB）</li>
<li>存储器管理：存储器的空间分配和回收、内存信息保护程序等</li>
<li>设备管理：缓冲区管理、设备分配和回收等</li>
</ol>
</li>
</ol>
<h3 id="中断和异常"><a class="header-anchor" href="#中断和异常">¶</a>中断和异常</h3>
<h4 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h4>
<ul>
<li>中断：也称外中断，是指来自CPU执行指令外部的事件（与当前执行的指令无关）<br>
如设备发出的I/O结束中断、时钟中断，表示一个固定的时间片已到</li>
<li>异常：也称内中断，是指来自CPU执行指令内部的事件（与当前执行的指令有关）<br>
如程序的非法操作码、地址越界、运算溢出。<br>
异常不能被屏蔽，一旦出现，就应该立即处理</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-1.6ezeeqb9yz80.webp" alt="操作系统-概述-1"></p>
<h4 id="分类"><a class="header-anchor" href="#分类">¶</a>分类</h4>
<ul>
<li>
<p>外中断可分为可屏蔽中断和不可屏蔽中断</p>
</li>
<li>
<p>异常可分为故障、自陷和终止</p>
<ul>
<li>故障：通常是由指令执行引起的异常，如非法操作码、缺页故障、除数为0、运算溢出等</li>
<li>自陷：是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序（要先传递需要内核执行的参数，再进入自陷）</li>
<li>终止：是指出现了使得CPU无法继续执行的硬件故障</li>
</ul>
</li>
</ul>
<h4 id="中断和异常的处理过程"><a class="header-anchor" href="#中断和异常的处理过程">¶</a>中断和异常的处理过程</h4>
<p>不同的中断信号（通过“中断向量表”查询）需要用不同的<strong>中断处理程序</strong>（一定是内核程序，要在内核态运行）来处理</p>
<h3 id="系统调用"><a class="header-anchor" href="#系统调用">¶</a>系统调用</h3>
<p>系统调用，是指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。<br>
应用程序可以通过系统调用来请求获得操作系统内核的服务</p>
<blockquote>
<p>tips:程序运行由用户态转到核心态，会用到访管指令。因为访管指令是在用户态使用的，所以它不可能是特权指令</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-2.34ppuunptik0.webp" alt="操作系统-概述-2"></p>
<h2 id="操作系统结构"><a class="header-anchor" href="#操作系统结构">¶</a>操作系统结构</h2>
<h3 id="分层法"><a class="header-anchor" href="#分层法">¶</a>分层法</h3>
<ol>
<li>优点：
<ul>
<li>便于系统的调试和验证，简化了系统的设计和实现</li>
<li>易拓展和维护</li>
</ul>
</li>
<li>缺点：
<ul>
<li>合理定义各层比较困难</li>
<li>效率较差</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-3.ki05mv4zwsw.webp" alt="操作系统-概述-3"></p>
<h3 id="模块化"><a class="header-anchor" href="#模块化">¶</a>模块化</h3>
<p>模块化是将操作系统按功能划分为具有一定独立性的模块。内核=主模块+可加载的内核模块</p>
<ol>
<li>优点：
<ul>
<li>提高了操作系统设计的正确性、可维护性和可理解性</li>
<li>增强了操作系统的可适应性</li>
<li>加速了操作系统的开发过程</li>
<li>如何模块可直接调用其他模块，效率高</li>
</ul>
</li>
<li>缺点：
<ul>
<li>模块的接口规定很难满足对接口的实际需求</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-4.6rrbq02ueck0.webp" alt="操作系统-概述-4"></p>
<h3 id="宏内核"><a class="header-anchor" href="#宏内核">¶</a><a href="https://zh.wikipedia.org/zh-cn/%E6%95%B4%E5%A1%8A%E6%80%A7%E6%A0%B8%E5%BF%83">宏内核</a></h3>
<ol>
<li>优点：
<ul>
<li>高性能</li>
</ul>
</li>
<li>缺点：
<ul>
<li>内核代码庞大，难以维护</li>
</ul>
</li>
</ol>
<h3 id="微内核"><a class="header-anchor" href="#微内核">¶</a><a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E5%85%A7%E6%A0%B8">微内核</a></h3>
<ol>
<li>优点：
<ul>
<li>方便维护</li>
</ul>
</li>
<li>缺点：
<ul>
<li>CPU状态切换频繁（核心态和用户态之间切换）性能差</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-5.1mepr7v3km00.webp" alt="操作系统-概述-5"></p>
<h3 id="外核"><a class="header-anchor" href="#外核">¶</a><a href="https://zh.wikipedia.org/zh-cn/Exokernel">外核</a></h3>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-6.6vhflxp90rk0.webp" alt="操作系统-概述-6"></p>
<h2 id="操作系统引导"><a class="header-anchor" href="#操作系统引导">¶</a>操作系统引导</h2>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-7.5c1rjn3jp1c0.webp" alt="操作系统-概述-7"></p>
<ol>
<li>CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序（先进行硬件自检，再开机）</li>
<li>将磁盘的第一块——主引导记录 读入内存，执行磁盘引导程序，扫描分区表</li>
<li>从活动分区（又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序</li>
<li>从根目录下找到完整的操作系统初始化程序（即 启动管理器）并执行，完成“开机”的一系列动作</li>
</ol>
<h2 id="虚拟机"><a class="header-anchor" href="#虚拟机">¶</a>虚拟机</h2>
<p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine, VM），每个虚拟机器都可以独立运行一个操作系统<br>
同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-8.1df9ei75zngg.webp" alt="操作系统-概述-8"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-9.2cn6k3jf58bo.webp" alt="操作系统-概述-9"></p>
<h2 id="典型例题"><a class="header-anchor" href="#典型例题">¶</a>典型例题</h2>
<p>待补充</p>
<hr>
<p>参考文献：<br>
《王道考研-操作系统复习指导》<br>
《Computer Systems A Programer’s Perspective Third Edition》<br>
<a href="https://zh.wikipedia.org/">中文维基百科</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>系统概述</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建TG贴纸下载Robot</title>
    <url>/2023/04/09/39658c8a0d3d/</url>
    <content><![CDATA[<h2 id="前情提要"><a class="header-anchor" href="#前情提要">¶</a>前情提要</h2>
<p>最近回家用TG贴纸下载机器人的时候发现太大的贴纸包无法下载，无奈只好自己搭建一个，正好在网上看到一个不错的，于是正好写这篇教程记录一下</p>
<span id="more"></span>
<h2 id="源码下载和必备环境"><a class="header-anchor" href="#源码下载和必备环境">¶</a>源码下载和必备环境</h2>
<ul>
<li>Robot源代码来源<a href="https://github.com/phoenixlzx/telegram-stickerimage-bot">Github</a></li>
<li>Imagemagick<a href="https://download.imagemagick.org/archive/releases/">下载</a></li>
<li>所需环境：
<ul>
<li>Node.js v8.0.0及以上</li>
<li>ImageMagick with webp support (Check with <code>identify -list format | grep -i 'webp' </code>on Linux systems)</li>
</ul>
</li>
</ul>
<h2 id="开始搭建Robot"><a class="header-anchor" href="#开始搭建Robot">¶</a>开始搭建Robot</h2>
<ol>
<li>因为 Imagemagick 没有 webp 支持，可以使用<code>identify -list format</code>查看支持的图片格式</li>
<li>Imagemagick源码编译webp</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先安装webp</span></span><br><span class="line">yum install libwebp -y</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载系统自带的ImageMagick</span></span><br><span class="line">yum remove ImageMagick -y</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载ImageMagick源码包，编译</span></span><br><span class="line">wget -c https://download.imagemagick.org/archive/releases/ImageMagick-7.1.1-4.tar.gz</span><br><span class="line">tar -zxf ImageMagick-7.1.1-4.tar.gz &amp;&amp; <span class="built_in">cd</span> ImageMagick-7.1.1-4</span><br><span class="line">./configure --with-webp</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否成功支持webp</span></span><br><span class="line">identify -list format | grep -i <span class="string">&#x27;webp&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>tips:
<ul>
<li><strong>编译时一定要带上 <code>--with-webp</code></strong></li>
<li><strong>ERROR:编译imagemagick时一直无法将webp成功一起编译无法使用机器人,输入以下命令后成功<code>sudo ldconfig /usr/local/lib</code></strong>（如果出现同样的问题尝试一下，未找到准确原因，可以参考Imagemagick<a href="https://imagemagick.org/script/install-source.php#linux">官方文档</a>）</li>
</ul>
</li>
</ul>
<ol start="3">
<li>
<p>Robot代码配置</p>
<ol>
<li><code>git clone https://github.com/phoenixlzx/telegram-stickerimage-bot.git</code></li>
<li>Get a bot token from <a href="https://telegram.me/BotFather">@BotFather</a></li>
<li>Copy <code>config.js.example</code> to <code>config.js</code> and edit as your needs</li>
<li><code>npm install &amp;&amp; npm start</code></li>
</ol>
</li>
<li>
<p>设置开机自启</p>
<ol>
<li>
<p>可以直接写一个shell脚本</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到目标项目目录下</span></span><br><span class="line">cd 你的Robot应用根目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>centos自启动配置(我的机器是Centos机器不同可能不一致)<br>
在CentOS 7中，开机启动脚本的位置为<code>/etc/rc.d/rc.local</code>文件</p>
</li>
</ol>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/rc.d/rc.local</span><br><span class="line"></span><br><span class="line"><span class="comment">#在开机时自动启动一个名为``auto-start.sh``的脚本，只需要在rc.local文件中添加如下内容：</span></span><br><span class="line">sh /path/to/auto-start.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#需要注意的是，rc.local 文件必须具有可执行权限，因此你需要运行以下命令来添加权限：</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="完成参考"><a class="header-anchor" href="#完成参考">¶</a>完成参考</h2>
<p><img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E6%90%AD%E5%BB%BATG%E8%B4%B4%E7%BA%B8%E4%B8%8B%E8%BD%BDRobot-1.5xf2bdnpjp80.webp" alt="搭建TG贴纸下载Robot-1"><br>
<img src="https://cdn.staticaly.com/gh/hiyoung3937/img_hiyoung@master/bolg/%E6%90%AD%E5%BB%BATG%E8%B4%B4%E7%BA%B8%E4%B8%8B%E8%BD%BDRobot-2.5vciz3o18d00.webp" alt="搭建TG贴纸下载Robot-2"></p>
<hr>
<p>参考文章：<br>
机器人源码：<br>
<a href="https://github.com/phoenixlzx/telegram-stickerimage-bot">https://github.com/phoenixlzx/telegram-stickerimage-bot</a></p>
<p>开机自启动node.js服务：<br>
<a href="https://juejin.cn/post/7215100409156157497">https://juejin.cn/post/7215100409156157497</a></p>
<p>imagemagick：<br>
<a href="https://imagemagick.org/script/install-source.php#linux">https://imagemagick.org/script/install-source.php#linux</a><br>
<a href="https://download.imagemagick.org/archive/releases/">https://download.imagemagick.org/archive/releases/</a></p>
<p>教程：<br>
<a href="https://halo.sherlocky.com/archives/imagemagick-heic">https://halo.sherlocky.com/archives/imagemagick-heic</a><br>
<a href="https://github.com/phoenixlzx/telegram-stickerimage-bot/issues/13">https://github.com/phoenixlzx/telegram-stickerimage-bot/issues/13</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>实用工具教程</category>
      </categories>
      <tags>
        <tag>TG_Robot</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-进程和线程</title>
    <url>/2023/07/26/b1f4b3c589a9/</url>
    <content><![CDATA[<h2 id="简介-v5"><a class="header-anchor" href="#简介-v5">¶</a>简介</h2>
<p>操作系统系列其二，主要是针对中国大陆考研所要求的内容对操作系统的知识体系进行总结和梳理，对于重点内容会使用黑体加粗，本篇内容主要包含以下几点：</p>
<ul>
<li>进程与线程的概念</li>
<li>CPU调度
<ul>
<li>经典调度算法</li>
</ul>
</li>
<li>同步与互斥
<ul>
<li>信号量</li>
<li>经典同步问题</li>
</ul>
</li>
<li>死锁</li>
</ul>
<h2 id="大纲-v2"><a class="header-anchor" href="#大纲-v2">¶</a>大纲</h2>
<h2 id="进程与线程"><a class="header-anchor" href="#进程与线程">¶</a>进程与线程</h2>
<h3 id="进程的概念"><a class="header-anchor" href="#进程的概念">¶</a>进程的概念</h3>
<p>在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程（Process）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性）<br>
为了使参与并发执行的每个程序（含数据）都能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块（Process Control Block, PCB）<br>
系统利用 PCB 来描述进程的基本情况和运行状态，进而控制和管理进程，<strong>PCB是进程存在的唯一标志</strong>。相应地，由程序段、相关数据段和 PCB 三部分构成了进程实体（又称进程映像）<br>
所谓创建进程，实质上是创建进程实体中的PCB，而撤销进程，实质上是撤销进程的PCB。值得注意的是，进程映像是静态的，进程则是动态的。</p>
<h3 id="进程的状态与转换"><a class="header-anchor" href="#进程的状态与转换">¶</a>进程的状态与转换</h3>
<p>进程在其生命周期内，由于系统中各进程之间的相互制约及系统的运行环境的变化，使得进程的状态也在不断地发生变化。通常进程有以下5种状态，前3种是进程的基本状态。</p>
<ul>
<li><strong>运行态</strong>。进程正在处理机上运行。在单处理机中，每个时刻只有一个进程处于运行态。</li>
<li><strong>就绪态</strong>。进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。<strong>系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</strong></li>
<li><strong>阻塞态</strong>，又称等待态。进程正在等待某一事件而暂停运行。即使处理机空闲，该进程也不能运行。系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。</li>
<li><strong>创建态</strong>。进程正在被创建，尚未转到就绪态。创建进程需要多个步骤，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。</li>
<li><strong>终止态</strong>。进程正从系统中消失，可能是进程正常结束或其他原因退出运行。进程需要结束运行时，系统首先将该进程置为终止态，然后进一步处理资源释放和回收等工作。</li>
</ul>
<p>注意区别就绪态和等待态：就绪态是指进程仅缺少处理器，只要获得处理机资源就立即运行；而等待态是指进程需要其他资源（除了处理机）或等待某一事件。</p>
<ul>
<li>进程的五态图</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-1.2sk8qiscjx00.webp" alt="操作系统-进程-1"></p>
<p>需要注意的是，一个进程从运行态变成阻塞态是主动的行为，而从阻塞态变成就绪态是被动的行为，需要其他相关进程的协助。</p>
<h3 id="进程组成"><a class="header-anchor" href="#进程组成">¶</a>进程组成</h3>
<ol>
<li>PCB
<ul>
<li>进程创建时，操作系统为它新建一个PCB，该（数据）结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。</li>
<li>进程执行时，系统通过其PCB了解进程的现行状态信息，以便操作系统对其进行控制和管理；进程结束时，系统收回其PCB，该进程随之消亡。</li>
</ul>
</li>
<li>程序段</li>
<li>数据段</li>
</ol>
<h3 id="进程控制"><a class="header-anchor" href="#进程控制">¶</a>进程控制</h3>
<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销己有进程、实现进程状态转换等功能。<br>
在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。<br>
控制原语所作的事：</p>
<ol>
<li>更新PCB中的信息</li>
<li>将PCB插入合适的队列</li>
<li>分配、回收资源</li>
</ol>
<h3 id="进程通信"><a class="header-anchor" href="#进程通信">¶</a>进程通信</h3>
<ol>
<li>
<p>共享存储<br>
在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如P操作、V操作），对共享空间的写/读进行控制。<br>
注意，进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-2.28y97hic6d7o.webp" alt="操作系统-进程-2"></p>
</li>
<li>
<p>信息传递<br>
在消息传递系统中，进程间的数据交换以格式化的消息 (Message) 为单位。<br>
进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</p>
<ol>
<li>直接通信方式。发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓队列上，接收进程从消息缓冲队列中取得消息</li>
<li>间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为信箱。该通信方式广泛应用于计算机网络中。</li>
</ol>
<blockquote>
<p>简单理解就是，甲要告诉乙某些事情，就要写信，然后通过邮差送给乙。直接通信就是邮差把信直接送到乙的手上；间接通信就是乙家门口有一个邮箱，邮差把信放到邮箱里。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-3.4rdrrenio8s0.webp" alt="操作系统-进程-3"></p>
</li>
<li>
<p>管道通信<br>
管道通信允许两个进程按生产者一消费者方式进行通信，生产者向管道的一端写，消费者从管道的另一端读。数据在管道中是先进先出的。</p>
<blockquote>
<p>注意：从管道读数据是一次性操作，数据一旦被读取，就释放空间以便写更多数据。普通管道只允许单向通信，若要实现父子进程双向通信，则需要定义两个管道</p>
</blockquote>
</li>
</ol>
<h3 id="线程和多线程模型"><a class="header-anchor" href="#线程和多线程模型">¶</a>线程和多线程模型</h3>
<h4 id="线程基本概念"><a class="header-anchor" href="#线程基本概念">¶</a>线程基本概念</h4>
<p>引入进程的目的是更好地使多道程序<strong>并发执行</strong>，提高资源利用率和系统吞吐量；<br>
而引入线程的目的则是<strong>减小</strong>程序在并发执行时所付出的<strong>时空开销</strong>，<strong>提高</strong>操作系统的<strong>并发性能</strong>。</p>
<p>线程最直接的理解就是“轻量级进程”，它是一个基本的 CPU 执行单元也是程序执行流的最小单位。</p>
<p>引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间也可以并发</strong>，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内地址空间等都是分配给进程的）。<strong>线程则作为处理机的分配单元</strong>。</p>
<h4 id="引入线程后的变化"><a class="header-anchor" href="#引入线程后的变化">¶</a>引入线程后的变化</h4>
<ol>
<li>资源分配、调度
<ul>
<li>传统进程机制中，进程是资源分配、调度的基本单位</li>
<li>引入线程后，线程是资源分配的基本单位、进程是调度的基本单位</li>
</ul>
</li>
<li>并发性
<ul>
<li>传统进程机制中，只能进程间并发</li>
<li>引入线程后，线程间也能并发</li>
</ul>
</li>
<li>系统开销
<ul>
<li>传统进程机制中，并发需要切换进程的运行环境，系统开销大</li>
<li>引入线程后，线程间并发，如果是在同一进程内的线程切换，不需要切换运行环境，系统开销小</li>
</ul>
</li>
</ol>
<h4 id="线程的属性"><a class="header-anchor" href="#线程的属性">¶</a>线程的属性</h4>
<ul>
<li>每个<strong>内核级</strong>线程都有一个线程ID、线程控制块（TCB）</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源，同一进程的不同线程共享进程的资源</li>
<li>同一进程内的线程切换，不会引起进程切换；不同进程内的线程切换，会引起进程切换</li>
</ul>
<h4 id="线程的实现方式"><a class="header-anchor" href="#线程的实现方式">¶</a>线程的实现方式</h4>
<p>线程的实现分为两类：用户级线程和内核级线程</p>
<ol>
<li>用户级线程
<ul>
<li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</li>
<li>线程的切换在用户态下即可完成，不需要系统干预</li>
<li><strong>用户级线程就是从用户视角能看到的线程，操作系统内核意识不到线程的存在</strong></li>
</ul>
</li>
<li>内核级线程
<ul>
<li><strong>内核级线程的管理工作</strong>由<strong>操作系统内核</strong>完成，线程的调度、切换都由内核完成，所有<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下完成</li>
<li>操作系统会为每个内核级线程建立相应的TCB，<strong>内核级线程</strong>就是从<strong>系统内核视角</strong>能看到的线程</li>
</ul>
</li>
<li>组合方式<br>
有些系统使用组合方式的多线程实现。<br>
在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。<br>
一些内核级线程对应多个用户级线程。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-5.23f9d0e482cg.webp" alt="操作系统-进程-5"></p>
<h4 id="多线程模型"><a class="header-anchor" href="#多线程模型">¶</a>多线程模型</h4>
<p>有些系统同时支持用户线程（“代码逻辑”的载体）和内核线程（“运行机会”的载体），由于用户级线程和内核级线程连接方式的不同，从而形成了下面三种不同的多线程模型。</p>
<ol>
<li>
<p>一对一模型<br>
一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br>
缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-6.6i2d0ihc5wg.webp" alt="操作系统-进程-6"></p>
</li>
<li>
<p>多对一模型<br>
多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<p><strong>！！！重点：操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-7.78i0uuy6rgk0.webp" alt="操作系统-进程-7"></p>
</li>
<li>
<p>多对多模型<br>
n用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。</p>
<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-8.k2jmzvx8avk.webp" alt="操作系统-进程-8"></p>
</li>
</ol>
<h4 id="例题"><a class="header-anchor" href="#例题">¶</a>例题</h4>
<ol>
<li>线程：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-4.66qc1cpsldo0.webp" alt="操作系统-进程-4"></li>
</ol>
<p>答：选B，操作系统会为每个<strong>内核级线程</strong>建立相应的TCB，意识不到用户级线程的存在</p>
<h2 id="CPU调度"><a class="header-anchor" href="#CPU调度">¶</a>CPU调度</h2>
<h3 id="基本概念"><a class="header-anchor" href="#基本概念">¶</a>基本概念</h3>
<ol>
<li>
<p>概念<br>
处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效的原则）选择一个进程并将处理机分配给它运行，以实现进程并发地执行</p>
</li>
<li>
<p>调度的层次<br>
作业：一个具体的任务<br>
用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</p>
<p>一个作业从提交到完成，往往要经历以下三级调度</p>
<ol>
<li>
<p>高级调度（作业调度） （外存-&gt;内存，发生频率最低）<br>
按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入时会建立PCB，调出时才撤销PCB</p>
<blockquote>
<p>无-&gt;创建态-&gt;就绪态</p>
</blockquote>
</li>
<li>
<p>中级调度（内存调度） （外存-&gt;内存，发生频率中等）<br>
按照某种策略决定将哪个处于挂起状态的进程重新调入内存</p>
<blockquote>
<p>挂起态-&gt;就绪态</p>
</blockquote>
</li>
<li>
<p>低级调度（进程调度） （内存-&gt;CPU，发生频率最高）<br>
按照某种策略从就绪队列中选取一个进程，将处理机分配给它，进程调度是操作系统中<strong>最基本的一种调度</strong></p>
<blockquote>
<p>就绪态-&gt;运行态</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="进程调度的时机、切换和过程"><a class="header-anchor" href="#进程调度的时机、切换和过程">¶</a>进程调度的时机、切换和过程</h3>
<p>临界资源：一个时间段只允许一个进程使用的资源。各进程互斥地访问临界资源（例如：打印机）<br>
临界区：访问临界资源的代码</p>
<h4 id="进程调度的时机"><a class="header-anchor" href="#进程调度的时机">¶</a>进程调度的时机</h4>
<ul>
<li>不能进行进程调度和切换的情况：
<ol>
<li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>进程在操作系统内核程序临界区中。</li>
<li>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之修改PCB中进程状态标志，并把PCB放到相应队列）</li>
</ol>
</li>
<li>需要进行进程调度和切换的情况：
<ol>
<li>当前运行的进程<strong>主动放弃</strong>处理机(进程正常终止、发生异常终止、请求阻塞等)</li>
<li>当前运行的进程<strong>被动放弃</strong>处理机(进程时间片耗尽、有优先级更高的进程)</li>
</ol>
</li>
</ul>
<h4 id="进程的切换与过程"><a class="header-anchor" href="#进程的切换与过程">¶</a>进程的切换与过程</h4>
<p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程</p>
<p>进程切换的过程主要完成了：</p>
<ol>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复</li>
</ol>
<p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁</strong>的进行<strong>进程调度、切换</strong>，必然会使<strong>整个系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少</p>
<h3 id="进程调度的方式"><a class="header-anchor" href="#进程调度的方式">¶</a>进程调度的方式</h3>
<ol>
<li>非剥夺调度方式，又称<strong>非抢占方式</strong>。即只允许进程主动放弃处理机。运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</li>
<li>剥夺调度方式，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程</li>
</ol>
<h3 id="调度算法的评价指标"><a class="header-anchor" href="#调度算法的评价指标">¶</a>调度算法的评价指标</h3>
<ol>
<li><strong>CPU利用率</strong>。<br>
$CPU利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间} $</li>
<li><strong>系统吞吐量</strong>。表示单位时间内CPU完成作业的数量<br>
$系统吞吐量=\frac{完成作业总数}{总共花费时间}$</li>
<li><strong>周转时间</strong>。是指从作业被提交给系统开始，到作业完成为止的这段时间间隔
<ul>
<li>
<p>(作业)周转时间=作业完成时间-作业提交时间</p>
</li>
<li>
<p>平均周转时间：所有作业周转时间的平均值<br>
$平均周转时间=\frac{各作业周转时间之和}{作业数}$</p>
</li>
<li>
<p>$带权周转时间=\frac{作业周转时间}{作业实际运行的时间}=\frac{作业完成时间-作业提交时间}{作业实际运行的时间}$</p>
</li>
<li>
<p>$平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}$</p>
</li>
</ul>
</li>
<li>等待时间。指进程/作业处于等待处理机状态时间之和<br>
等待时间=周转时间-运行时间</li>
<li>响应时间。指从用户提交请求到首次产生响应所用的时间</li>
</ol>
<h3 id="典型的调度算法"><a class="header-anchor" href="#典型的调度算法">¶</a>典型的调度算法</h3>
<p>注意各个算法的优缺点、性能、概念、是否会导致饥饿(某进程/作业长期<br>
得不到服务)、用于作业调度还是进程调度、抢占式还是非抢占式</p>
<ul>
<li>概念：</li>
<li>用于作业调度还是进程调度：</li>
<li>抢占式还是非抢占式：</li>
<li>优点：</li>
<li>缺点：</li>
<li>是否会导致饥饿：</li>
<li>性能：</li>
</ul>
<h4 id="先来先服务（FCFS）"><a class="header-anchor" href="#先来先服务（FCFS）">¶</a>先来先服务（FCFS）</h4>
<ul>
<li>概念：按照作业/进程到达的先后顺序进行服务</li>
<li>用于作业调度还是进程调度：既可用于作业调度，也可用于进程调度。</li>
<li>抢占式还是非抢占式：非抢占式的算法</li>
<li>优点：公平、算法实现简单</li>
<li>缺点：<strong>对长作业有利，对短作业不利</strong></li>
<li>是否会导致饥饿：不会</li>
<li>性能：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-9.6sqrtebbfw40.webp" alt="操作系统-进程-9"></p>
<h4 id="短作业优先（SJF）"><a class="header-anchor" href="#短作业优先（SJF）">¶</a>短作业优先（SJF）</h4>
<ul>
<li>概念：最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</li>
<li>用于作业调度还是进程调度：即可用于作业调度，也可用于进程调度。</li>
<li>抢占式还是非抢占式：非抢占式（但也有抢占版本）</li>
<li>优点：有“最短的”平均等待时间、平均周转时间</li>
<li>缺点：<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿</strong>现象</li>
<li>是否会导致饥饿：会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象</li>
<li>性能：
<ul>
<li>非抢占式：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-10.2bmjxg74b534.webp" alt="操作系统-进程-10"></li>
<li>抢占式：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-11.6rf0mv2mzq80.webp" alt="操作系统-进程-11"></li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：</p>
</blockquote>
<ol>
<li>如果题目中<strong>未特别说明</strong>，所提到的“短作业/进程优先算法”<strong>默认</strong>是<strong>非抢占式</strong>的</li>
<li>在<strong>在所有进程同时可运行时</strong>条件下，采用SJF调度算法的平均等待时间、平均周转时间最少（没有条件的表述是不严谨的）</li>
<li>如果选择题中遇到“SJF算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那应该选择该选项</li>
</ol>
<blockquote></blockquote>
<h4 id="最高相应比优先"><a class="header-anchor" href="#最高相应比优先">¶</a>最高相应比优先</h4>
<ul>
<li>概念：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务<br>
$响应比=\frac{等待时间+要求服务时间}{要求服务时间}\geq{1}$</li>
<li>用于作业调度还是进程调度：即可用于作业调度，也可用于进程调度</li>
<li>抢占式还是非抢占式：非抢占式的算法</li>
<li>优缺点：综合考虑了等待时间和运行时间,对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
<li>是否会导致饥饿：不会</li>
<li>性能：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-12.4sgyjy4ipx20.webp" alt="操作系统-进程-12"></p>
<p>这三种算法一般适合用于<strong>早期的批处理系统</strong>，并不区分任务的紧急程度，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色</p>
<hr>
<h4 id="时间片轮转"><a class="header-anchor" href="#时间片轮转">¶</a>时间片轮转</h4>
<ul>
<li>
<p>概念：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</p>
</li>
<li>
<p>用于作业调度还是进程调度：用于进程调度</p>
</li>
<li>
<p>抢占式还是非抢占式：抢占式，由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</p>
</li>
<li>
<p>优点：公平；响应快，适用于分时操作系统</p>
</li>
<li>
<p>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</p>
</li>
<li>
<p>是否会导致饥饿：不会</p>
</li>
<li>
<p>性能：时间片的大小对系统的性能影响很大</p>
</li>
</ul>
<h4 id="优先级调度"><a class="header-anchor" href="#优先级调度">¶</a>优先级调度</h4>
<ul>
<li>概念：调度时选择优先级最高的作业/进程</li>
<li>用于作业调度还是进程调度：既可用于作业调度，也可用于进程调度</li>
<li>抢占式还是非抢占式：抢占式、非抢占式都有</li>
<li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度</li>
<li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li>
<li>是否会导致饥饿：会</li>
<li>性能：</li>
</ul>
<h4 id="多级反馈队列"><a class="header-anchor" href="#多级反馈队列">¶</a>多级反馈队列</h4>
<ul>
<li>概念：融合了前几种算法的优点
<ul>
<li><strong>设置多级就绪队列</strong>，各级队列<strong>优先级从高到低</strong>，<strong>时间片从小到大</strong></li>
<li>新进程到达时先进入第1级队列，<strong>按FCFS原则</strong>排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li>
</ul>
</li>
<li>用于作业调度还是进程调度：用于进程调度</li>
<li>抢占式还是非抢占式：抢占式的算法</li>
<li>优点：
<ul>
<li>对各类型进程相对公平（FCFS的优点）；</li>
<li>每个新到达的进程都可以很快就得到响应（RR的优点）；</li>
<li>短进程只用较少的时间就可完成（SPF的优点）；</li>
<li>不必实现估计进程的运行时间（避免用户作假）；</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）</li>
</ul>
</li>
<li>缺点：</li>
<li>是否会导致饥饿：会</li>
<li>性能：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-13.1yqe6z8h27ts.webp" alt="操作系统-进程-13"></p>
<p>这三种算法适合用于<strong>交互式系统</strong>，更注重系统的响应时间、公平性、平衡性等指标</p>
<hr>
<h2 id="同步与互斥"><a class="header-anchor" href="#同步与互斥">¶</a>同步与互斥</h2>
<h3 id="基本概念-v2"><a class="header-anchor" href="#基本概念-v2">¶</a>基本概念</h3>
<h4 id="进程同步"><a class="header-anchor" href="#进程同步">¶</a>进程同步</h4>
<p>因为进程具有异步性的特征。操作系统要提供“<strong>进程同步机制</strong>”来解决异步问题，以防止程序产生不可预知的错误</p>
<h4 id="进程互斥"><a class="header-anchor" href="#进程互斥">¶</a>进程互斥</h4>
<p>各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，打印机、摄像头这样的I/O设备）</p>
<p>资源共享分为：互斥共享方式和同时共享方式</p>
<ul>
<li>互斥共享方式：一个时间段内只允许一个进程访问该资源</li>
<li>同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问</li>
</ul>
<p>我们把一个时间段内只允许一个进程使用的资源称为<strong>临界资源</strong>（如摄像头、打印机、一些变量和数据等）。对临界资源的访问，必须<strong>互斥地</strong>进行。可以把临界资源的访问过程分成四个部分：</p>
<ol>
<li>进入区（可理解为“上锁”）：负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志</li>
<li>临界区：访问临界资源的那段代码</li>
<li>退出区（可理解为“解锁”）：负责解除正在访问临界资源的标志</li>
<li>剩余区：代码中剩余的其他部分</li>
</ol>
<blockquote>
<p><strong>进入区</strong>和<strong>退出区</strong>是负责实现互斥的代码段;<strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段</p>
</blockquote>
<p><strong>进程互斥</strong>：指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，同步机制应该遵循以下原则：</p>
<ol>
<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li><strong>忙则等待</strong>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<h3 id="实现临界区互斥的基本方法"><a class="header-anchor" href="#实现临界区互斥的基本方法">¶</a>实现临界区互斥的基本方法</h3>
<h4 id="软件实现方法"><a class="header-anchor" href="#软件实现方法">¶</a>软件实现方法</h4>
<h5 id="算法一：单标志法"><a class="header-anchor" href="#算法一：单标志法">¶</a>算法一：单标志法</h5>
<p>算法思想：两个进程在<strong>访问完临界区</strong>后会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//turn表示当前运行进入临界区的进程号（turn 变量背后的逻辑：表达“谦让”）</span></span><br><span class="line"></span><br><span class="line">P0进程：</span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">0</span>);  <span class="comment">//1 进入区</span></span><br><span class="line">critial section;  <span class="comment">//2 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;  <span class="comment">//3 退出区</span></span><br><span class="line">remainder section;  <span class="comment">//4 剩余区</span></span><br><span class="line"></span><br><span class="line">P1进程：</span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">1</span>);  <span class="comment">//5 进入区</span></span><br><span class="line">critial section;  <span class="comment">//6 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;  <span class="comment">//7 退出区</span></span><br><span class="line">remainder section;  <span class="comment">//8 剩余区</span></span><br></pre></td></tr></table></figure>
<p>运行逻辑：turn 的初值为0，即刚开始只允许0号进程进入临界区。若P1先上处理机运行，则会一直卡在5。直到P1的时间片用完，发生调度，切换P0上处理机运行。代码1不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间即时切换回 P1，P1依然会卡在5。只有P0在退出区将 turn 改为 1 后，P1才能进入临界区。</p>
<p>缺点：两个进程必须交替的进入临界区，若某个进程不再进入临界区，则另一个进程也无法进入临界区（<strong>违背“空闲让进”原则</strong>）</p>
<h5 id="算法二：双标志先检查法"><a class="header-anchor" href="#算法二：双标志先检查法">¶</a>算法二：双标志先检查法</h5>
<p>算法思想：设置一个布尔型数组 flag[] ，<strong>数组中各个元素用来标记各进程想进入临界区的意愿</strong>，比如“flag[0] = ture”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i]设为 true，之后开始访问临界区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];  <span class="comment">//表示进入临界区的意愿（背后的含义：“表达意愿”）</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">P0进程：</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);  <span class="comment">//1 进入区，如果此时P1想要进入临界区，P0就一直循环等待</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;  <span class="comment">//2 进入区，标记为P0进程想要进入临界区</span></span><br><span class="line"></span><br><span class="line">critial section;  <span class="comment">//3 临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;  <span class="comment">//4 退出区，修改标记为P0不想进入临界区</span></span><br><span class="line">remainder section;  <span class="comment">//剩余区</span></span><br><span class="line"></span><br><span class="line">P1进程：</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);  <span class="comment">//5 进入区，如果此时P0想要进入临界区，P1就一直循环等待</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">//6 进入区，标记为P1进程想要进入临界区</span></span><br><span class="line"></span><br><span class="line">critial section;  <span class="comment">//7 临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;  <span class="comment">//8 退出区，修改标记为P1不想进入临界区</span></span><br><span class="line">remainder section;  <span class="comment">//剩余区</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>算法问题：若按照 1，5，2，6，3，7….的顺序执行，P0 和 P1 将会同时访问临界区。<br>
<strong>违反“忙则等待”原则</strong>，其原因在于进入区的“检查”和“上锁” ，<strong>两个处理不是一气呵成的</strong>。“检查”后，“上锁”前<strong>可能发生进程切换</strong>。</p>
<h5 id="算法三：双标志后检查法"><a class="header-anchor" href="#算法三：双标志后检查法">¶</a>算法三：双标志后检查法</h5>
<p>算法思想：双标志先检查法的改版。人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];  <span class="comment">//表示进入临界区的意愿（背后的含义：“表达意愿”）</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">P0进程：</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;  <span class="comment">//1 进入区，标记为P0进程想要进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);  <span class="comment">//2 进入区，如果此时P1想要进入临界区，P0就一直循环等待</span></span><br><span class="line"></span><br><span class="line">critial section;  <span class="comment">//3 临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;  <span class="comment">//4 退出区，修改标记为P0不想进入临界区</span></span><br><span class="line">remainder section;  <span class="comment">//剩余区</span></span><br><span class="line"></span><br><span class="line">P1进程：</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">//5 进入区，标记为P1进程想要进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);  <span class="comment">//6 进入区，如果此时P0想要进入临界区，P1就一直循环等待</span></span><br><span class="line"></span><br><span class="line">critial section;  <span class="comment">//7 临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;  <span class="comment">//8 退出区，修改标记为P1不想进入临界区</span></span><br><span class="line">remainder section;  <span class="comment">//剩余区</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>算法问题：若按照 1，5，2，6….的顺序执行，P0 和 P1 将都无法进入临界区<br>
因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又<strong>违背了“空闲让进”和“有限等待”原则</strong>，会因各进程都长期无法访问临界资源而 <strong>产生“饥饿”</strong> 现象</p>
<h5 id="算法四：Peterson算法"><a class="header-anchor" href="#算法四：Peterson算法">¶</a>算法四：Peterson算法</h5>
<p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试谦让</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];  <span class="comment">//表示进入临界区的意愿（背后的含义：“表达意愿”）</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;  <span class="comment">//turn表示优先让哪个进程进入临界区（背后的逻辑：表达“谦让”）</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">P0进程：</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;  <span class="comment">//1 进入区，标记为P0进程想要进入临界区</span></span><br><span class="line">turn = <span class="number">1</span> <span class="comment">//可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn = <span class="number">1</span>);  <span class="comment">//2 进入区，如果此时P1想要进入临界区并且P0表示谦让，P0就一直循环等待</span></span><br><span class="line"></span><br><span class="line">critial section;  <span class="comment">//3 临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;  <span class="comment">//4 退出区，修改标记为P0不想进入临界区</span></span><br><span class="line">remainder section;  <span class="comment">//剩余区</span></span><br><span class="line"></span><br><span class="line">P1进程：</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">//5 进入区，标记为P1进程想要进入临界区</span></span><br><span class="line">turn = <span class="number">0</span> <span class="comment">//可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn = <span class="number">0</span>);  <span class="comment">//6 进入区，如果此时P0想要进入临界区并且P1表示谦让，P1就一直循环等待</span></span><br><span class="line"></span><br><span class="line">critial section;  <span class="comment">//7 临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;  <span class="comment">//8 退出区，修改标记为P1不想进入临界区</span></span><br><span class="line">remainder section;  <span class="comment">//剩余区</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>算法分析：谁最后表达了谦让，谁就失去了行动的优先权<br>
算法问题：Peterson 算法用软件方法解决了进程互斥问题，遵循了<strong>空闲让进、忙则等待、有限等待 三个原则</strong>，但是<strong>依然未遵循让权等待</strong>的原则</p>
<h4 id="硬件实现方法"><a class="header-anchor" href="#硬件实现方法">¶</a>硬件实现方法</h4>
<h5 id="中断屏蔽方法"><a class="header-anchor" href="#中断屏蔽方法">¶</a>中断屏蔽方法</h5>
<p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关中断；</span><br><span class="line">临界区；</span><br><span class="line">开中断；</span><br></pre></td></tr></table></figure>
<p>优点：简单、高效<br>
缺点：不适用于多处理机；<strong>只适用于操作系统内核进程</strong>，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p>
<h5 id="硬件指令方法"><a class="header-anchor" href="#硬件指令方法">¶</a>硬件指令方法</h5>
<ol>
<li>TestAndSetLock 指令（TSL指令）<br>
TSL指令是用<strong>硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成。<br>
简而言之，相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</li>
</ol>
<ul>
<li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li>
<li>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”</li>
</ul>
<ol start="2">
<li>Swap指令（也叫 Exchange 指令，或简称 XCHG 指令）<br>
Swap 指令是<strong>用硬件实现的</strong>，执行的过程不允许被中断，只能一气呵成<br>
逻辑上来看 Swap 和 TSL 并无太大区别<br>
优缺点同TSL指令</li>
</ol>
<h3 id="互斥锁"><a class="header-anchor" href="#互斥锁">¶</a>互斥锁</h3>
<p>解决临界区最简单的工具就是互斥锁。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。<br>
函数 acquire()获得锁，而函数release()释放锁。 acquire()和release()的执行必须是原子操作，因此互斥锁通常使用硬件机制来实现<br>
互斥锁的主要缺点是<strong>忙等待</strong>。需要连续循环忙等的互斥锁，都可称为自旋锁，如TSL指令、swap指令、单标志法</p>
<h3 id="信号量"><a class="header-anchor" href="#信号量">¶</a>信号量</h3>
<p><strong>信号量S</strong>其实就是一个<strong>变量</strong>(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量</p>
<p>信号量只能被两个标准的原语wait(S)和signal(S)访问，其常简称为P、V操作，也即wait(S)称为P(S)，signal(S)称为V(S)，这对原语可用于实现系统资源的“<strong>申请</strong>”和“<strong>释放</strong>”。</p>
<h4 id="整型信号量"><a class="header-anchor" href="#整型信号量">¶</a>整型信号量</h4>
<p>用一个<strong>整数型的变量</strong>作为信号量，用来表示系统中某种资源的数量<br>
整型信号量的缺陷是存在“忙等”问题</p>
<h4 id="记录型信号量"><a class="header-anchor" href="#记录型信号量">¶</a>记录型信号量</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录型信号量的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> value;<span class="comment">//S.value 的初值表示系统中某种资源的数目</span></span><br><span class="line">   Struct process *L; <span class="comment">//链表L用来链接等待该资源的进程</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure>
<p>对信号量 S 的一次<strong>P操作</strong>意味着<strong>进程请求一个单位的该类资源</strong>，当<br>
S.value&lt;0 时表示该类资源已分配完毕，因此进程应<strong>调用 block 原语进行自我阻塞</strong>，并插入该类资源的等待队列S.L中。</p>
<p>对信号量 S 的一次<strong>V操作</strong>意味着<strong>进程释放一个单位的该类资源</strong>，若加1后仍是S.value&lt;=0，表示依然有进程在等待该类资源，因此应调用wakeup 原语<strong>唤醒等待队列中的第一个进程</strong></p>
<blockquote>
<p>注：若考试中出现 P(S)、V(S) 的操作，除非特别说明，否则默认 S 为记录型信号量</p>
</blockquote>
<h4 id="利用信号量实现同步"><a class="header-anchor" href="#利用信号量实现同步">¶</a>利用信号量实现同步</h4>
<p>用信号量实现进程同步：</p>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“<strong>一前一后</strong>”执行的两个操作（或两句代码）</li>
<li>设置<strong>同步信号量</strong>S, <strong>初始为0</strong></li>
<li><strong>在“前操作”之后执行 V(S)</strong></li>
<li><strong>在“后操作”之前执行 P(S)</strong></li>
</ol>
<blockquote>
<p>技巧口诀：前V后P<br>
理解：信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源</p>
</blockquote>
<h4 id="信号量机制实现前驱关系"><a class="header-anchor" href="#信号量机制实现前驱关系">¶</a>信号量机制实现前驱关系</h4>
<p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）<br>
因此，</p>
<ol>
<li>要为<strong>每一对前驱关系各设置一个同步信号量</strong></li>
<li>在“前操作”之后对相应的同步信号量执行 V 操作</li>
<li>在“后操作”之前对相应的同步信号量执行 P 操作</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-14.4m487fr8i3k0.webp" alt="操作系统-进程-14"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-15.6drok7ug71s0.webp" alt="操作系统-进程-15"></p>
<h4 id="利用信号量实现进程互斥"><a class="header-anchor" href="#利用信号量实现进程互斥">¶</a>利用信号量实现进程互斥</h4>
<ol>
<li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问应放在临界区）</li>
<li>设置互斥信号量 mutex，<strong>初值为 1</strong></li>
<li>在进入区 P(mutex)——<strong>申请资源</strong></li>
<li>在退出区 V(mutex)——<strong>释放资源</strong></li>
</ol>
<blockquote>
<p>注意：对<strong>不同的临界资源</strong>需要设置<strong>不同的互斥信号量</strong>。<strong>P、V操作必须成对出现</strong>。缺少P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒</p>
</blockquote>
<p>注意：同步和互斥之间的对比</p>
<p>互斥问题，信号量初值为1<br>
同步问题，信号量初值为0</p>
<p>除了互斥、同步问题外，还会考察有多个资源的问题，<strong>有多少资源就把信号量初值设为多少</strong>。申请资源时进行P操作，释放资源时进行 V 操作即可</p>
<h3 id="管程"><a class="header-anchor" href="#管程">¶</a>管程</h3>
<p>为了解决信号量机制导致的编写程序困难、易出错问题，引入管程机制来实现进程同步。</p>
<p>管程是一种特殊的软件模块</p>
<ol>
<li>局部于管程的<strong>共享数据结构</strong>说明；</li>
<li>对该数据结构进行操作的<strong>一组过程(即函数)</strong>；</li>
<li>对局部于管程的共享数据设置初始值的语句；</li>
<li>管程有一个名字</li>
</ol>
<p>管程的基本特征：</p>
<ol>
<li>局部于管程的数据只能被局部于管程的过程所访问；</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong>。</li>
</ol>
<h3 id="经典同步问题"><a class="header-anchor" href="#经典同步问题">¶</a>经典同步问题</h3>
<p>PV操作题目分析步骤：</p>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</li>
<li>设置信号量。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</li>
</ol>
<h4 id="生产者-消费者问题"><a class="header-anchor" href="#生产者-消费者问题">¶</a>生产者-消费者问题</h4>
<h5 id="问题描述："><a class="header-anchor" href="#问题描述：">¶</a>问题描述：</h5>
<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用（注：这里的“产品”理解为某种数据）<br>
生产者、消费者<strong>共享一个初始为空、大小为n的缓冲区</strong>。<br>
只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。<br>
只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。<br>
缓冲区是临界资源，各进程必须<strong>互斥地访问</strong>。</p>
<h5 id="问题分析"><a class="header-anchor" href="#问题分析">¶</a>问题分析</h5>
<ol>
<li>关系分析。生产者和消费者<strong>对缓冲区</strong>的互斥访问是<strong>互斥关系</strong>，同时生产者和消费者也是一个相互协作问题，只有生产者生产后，消费者才能消费，<strong>他们是同步关系</strong></li>
<li>整理思路。</li>
<li>信号量设置<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n;<span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">producer ()&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      生产一个产品;</span><br><span class="line">      P(empty);<span class="comment">//消耗一个空缓冲区</span></span><br><span class="line">      </span><br><span class="line">      P(mutex);</span><br><span class="line">      把产品放入缓冲区; <span class="comment">//实现互斥是在同一进程中进行一对PV操作</span></span><br><span class="line">      V(mutex);</span><br><span class="line"></span><br><span class="line">      V(full);<span class="comment">//增加一个产品</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer ()&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      P(full); <span class="comment">//实现两个进程同步关系，是在其中一个进程中执行P另一个执行V，这里符合“前V后P”</span></span><br><span class="line"></span><br><span class="line">      P(mutex);</span><br><span class="line">      从缓冲区取出一个产品; <span class="comment">//互斥的访问缓冲区，将缓冲区“夹紧”</span></span><br><span class="line">      V(mutex);</span><br><span class="line"></span><br><span class="line">      V(empty);<span class="comment">//增加一个空闲缓冲区</span></span><br><span class="line">      使用产品;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>思考：能否改变相邻P、V操作的顺序?<br>
若缓冲区中没有产品，即full=0，empty=n，此时将P(mutex)放在P(full)和P(empty)之前，若是按照P(mutex)、P(full)、P(mutex)的顺序执行就会导致死锁。<br>
因此，<strong>实现互斥的P操作一定要在实现同步的P操作之后</strong>。<br>
V操作不会导致进程阻塞，因此<strong>两个V操作顺序可以交换</strong>。</p>
</blockquote>
<h4 id="多生产者-多消费者问题"><a class="header-anchor" href="#多生产者-多消费者问题">¶</a>多生产者-多消费者问题</h4>
<h5 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h5>
<p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。<br>
用PV操作实现上述过程</p>
<h5 id="问题分析-v2"><a class="header-anchor" href="#问题分析-v2">¶</a>问题分析</h5>
<p>互斥关系：对缓冲区（盘子）的访问要互斥地进行<br>
同步关系（一前一后）：</p>
<ol>
<li>父亲将苹果放入盘子后，女儿才能取苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子</li>
<li>只有<strong>盘子为空</strong>时，<strong>父亲或母亲</strong>才能放入水果
<ul>
<li>(“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果)</li>
</ul>
</li>
</ol>
<p>信号量设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">//盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">//盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">//盘子中还可以放多少个水果</span></span><br><span class="line"></span><br><span class="line">dad ()&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      准备一个苹果;</span><br><span class="line">      P(plate);</span><br><span class="line"></span><br><span class="line">      P(mutex);</span><br><span class="line">      把苹果放入盘子;</span><br><span class="line">      V(mutex);</span><br><span class="line"></span><br><span class="line">      V(apple);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom ()&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      准备一个橘子;</span><br><span class="line">      P(plate);</span><br><span class="line"></span><br><span class="line">      P(mutex);</span><br><span class="line">      把橘子放入盘子;</span><br><span class="line">      V(mutex);</span><br><span class="line"></span><br><span class="line">      V(orange);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter ()&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      P(apple);</span><br><span class="line"></span><br><span class="line">      P(mutex);</span><br><span class="line">      从盘中取出苹果;</span><br><span class="line">      V(mutex);</span><br><span class="line"></span><br><span class="line">      V(plate);</span><br><span class="line">      吃掉苹果;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">son ()&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      P(orange);</span><br><span class="line"></span><br><span class="line">      P(mutex);</span><br><span class="line">      从盘中取出橘子;</span><br><span class="line">      V(mutex);</span><br><span class="line"></span><br><span class="line">      V(plate);</span><br><span class="line">      吃掉橘子;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="要点分析"><a class="header-anchor" href="#要点分析">¶</a>要点分析</h5>
<p>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系</p>
<p>比如，如果从单个进程行为的角度来考虑的话，我们会有以下结论：<br>
如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果<br>
如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果<br>
这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？<br>
正确的分析方法应该<strong>从“事件”的角度</strong>来考虑，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”</p>
<p><strong>盘子变空事件-&gt;放入水果事件</strong>。<br>
“盘子变空事件”既可由儿子引发，也可由女儿引发；<br>
“放水果事件”既可能是父亲执行，也可能是母亲执行。<br>
这样的话，就可以用一个同步信号量解决问题了</p>
<h4 id="吸烟者问题-可以生产多个产品的单生产者问题"><a class="header-anchor" href="#吸烟者问题-可以生产多个产品的单生产者问题">¶</a>吸烟者问题(可以生产多个产品的单生产者问题)</h4>
<h5 id="问题描述-v2"><a class="header-anchor" href="#问题描述-v2">¶</a>问题描述</h5>
<p>假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（<strong>让三个抽烟者轮流地抽烟</strong>）</p>
<h5 id="问题分析-v3"><a class="header-anchor" href="#问题分析-v3">¶</a>问题分析</h5>
<ol>
<li>关系分析：供应者与三个吸烟者分别是同步关系，三个吸烟者对吸烟这个动作互斥（不需要专门再设置一个互斥信号量表示对桌子的使用（桌子可以抽象为容量为1的缓冲区），因为吸烟只能是轮流进行的）</li>
<li>整理思路：显然有四个进程<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-16.3l6rm03rt2a0.webp" alt="操作系统-进程-16"></li>
<li>信号量设置<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;<span class="comment">//桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;<span class="comment">//桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;<span class="comment">//桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;<span class="comment">//抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//用于实现“三个抽烟者轮流抽烟”</span></span><br><span class="line"></span><br><span class="line">provider ()&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">         将组合一放桌上;</span><br><span class="line">         V(offer1);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">         将组合二放桌上;   </span><br><span class="line">         V(offer2);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">         将组合三放桌上;</span><br><span class="line">         V(offer3);</span><br><span class="line">      &#125;</span><br><span class="line">      i = (i+<span class="number">1</span>)%<span class="number">3</span>; <span class="comment">//实现轮流</span></span><br><span class="line">      P(finish);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1 ()&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         P(offer1);</span><br><span class="line">         从桌上拿走组合一；卷烟；抽掉；</span><br><span class="line">         </span><br><span class="line">         V(finish);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">smoker2 ()&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         P(offer2);</span><br><span class="line">         从桌上拿走组合二；卷烟；抽掉；</span><br><span class="line">         </span><br><span class="line">         V(finish);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3 ()&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         P(offer3);</span><br><span class="line">         从桌上拿走组合三；卷烟；抽掉；</span><br><span class="line">         </span><br><span class="line">         V(finish);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理-CPU</title>
    <url>/2023/06/24/524b2effcffb/</url>
    <content><![CDATA[<h2 id="简介-v6"><a class="header-anchor" href="#简介-v6">¶</a>简介</h2>
<p>计算机组成原理系列其四，主要是针对中国大陆考研所要求的内容对计算机组成原理的知识体系进行总结和梳理，本篇内容是计算机的CPU相关内容介绍，主要包含以下几点：</p>
<ul>
<li>CPU的功能和基本结构</li>
<li>指令的执行过程</li>
<li>CPU内的数据通路</li>
<li>控制器的功能和原理</li>
<li>指令流水线</li>
<li>多处理器</li>
</ul>
<span id="more"></span>
<h2 id="大纲-v3"><a class="header-anchor" href="#大纲-v3">¶</a>大纲</h2>
<ul>
<li>CPU的基本结构
<ul>
<li>运算器</li>
<li>控制器</li>
</ul>
</li>
<li>指令的执行过程
<ul>
<li>指令周期</li>
<li>指令周期的数据流</li>
<li>指令的执行方案</li>
</ul>
</li>
<li>CPU内的数据通路
<ul>
<li>基本结构</li>
<li>例题分析</li>
</ul>
</li>
<li>控制器
<ul>
<li>微程序控制器
<ul>
<li>基本概念</li>
<li>编码方式</li>
<li>地址形成方式</li>
<li>格式</li>
</ul>
</li>
</ul>
</li>
<li>指令流水线
<ul>
<li>定义</li>
<li>基本实现</li>
<li>冒险和处理
<ul>
<li>结构冒险</li>
<li>数据冒险</li>
<li>控制冒险</li>
</ul>
</li>
<li>流水线的性能指标</li>
<li>高级流水线技术</li>
</ul>
</li>
<li>多处理器概念
<ul>
<li>SISD、SIMD、MIMD</li>
<li>硬件多线程</li>
<li>多核处理器</li>
</ul>
</li>
</ul>
<h2 id="CPU的基本结构"><a class="header-anchor" href="#CPU的基本结构">¶</a>CPU的基本结构</h2>
<p>CPU主要由运算器和控制器两大部分组成</p>
<blockquote>
<p>Tips：CPU内部的寄存器大致分为两类：</p>
<ol>
<li>用户可见的寄存器：通用寄存器组、PSW、PC等</li>
<li>用户不可见寄存器：MAR、MDR、IR等</li>
</ol>
</blockquote>
<h3 id="运算器"><a class="header-anchor" href="#运算器">¶</a>运算器</h3>
<p>运算器是计算机对数据进行加工处理的中心，其主要有：</p>
<ul>
<li>算术逻辑单元（ALU）：进行算术、逻辑运算</li>
<li>程序状态寄存器（PSW）：保留计算机中算术逻辑运算或指令的结果产生的各种状态信息，如溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。PSW中这些位参与并决定微操作的形成</li>
<li>暂存寄存器</li>
<li>通用寄存器组</li>
<li>累加寄存器（ACC）</li>
<li>移位器</li>
<li>计数器（CT）</li>
</ul>
<h3 id="控制器"><a class="header-anchor" href="#控制器">¶</a>控制器</h3>
<p>控制器的基本功能是执行指令，每条指令的执行由控制器发出的一组微操作实现，其主要部件有：</p>
<ul>
<li>程序计数器（PC）：指出将要执行的指令在主存中的地址（即指令的地址）</li>
<li>指令寄存器（IR）：存放当前正在执行的指令</li>
<li>存储器地址寄存器（MAR）：存放要访问的主存单元的地址</li>
<li>存储器数据寄存器（MDR）：存放向主存写入信息或从主存读出的信息</li>
<li>指令译码器</li>
<li>时序系统</li>
<li>微操作信号发生器</li>
</ul>
<h2 id="指令的执行过程"><a class="header-anchor" href="#指令的执行过程">¶</a>指令的执行过程</h2>
<p>在了解指令的执行之前要先明确指令执行过程中的不同周期的含义</p>
<ol>
<li><span id="时钟周期">时钟周期</span>：也称节拍或T周期，它是CPU中最小最基本的时间单位，是处理操作的最基本单位</li>
<li>机器周期：也称为CPU周期。在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作。完成一个基本操作所需要的时间称为机器周期。一般情况下，一个机器周期由若干个时钟周期组成。</li>
<li>指令周期：CPU每取出一条指令并执行这条指令，都要完成一系列的操作，这一系列操作所需要的时间通常叫做一个指令周期。</li>
<li>存取周期：存储器进行一次读或写操作所需的时间称为存储器的访问时间（或读/写时间），而连续启动两次独立的读或写操作所需的最短时间，称为存取周期（或存储周期）。机器周期通常由存取周期确定</li>
</ol>
<p>指令周期常常用<strong>若干个</strong>CPU周期数来表示，机器周期时间又包含<strong>若干个</strong>时钟周期。<br>
每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。</p>
<h3 id="指令周期"><a class="header-anchor" href="#指令周期">¶</a>指令周期</h3>
<p>通常一个指令周期包含取指、间址、执行、中断四个周期，但不是所有指令都包含这四个周期，有些指令可能没有间址周期。</p>
<table>
    <thead>
        <tr>
            <th colspan="4" align="center">指令周期</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td align="center">取指周期</td>
            <td align="center">间址周期</td>
            <td align="center">执行周期</td>
            <td align="center">中断周期</td>
        </tr>
    </tbody>
</table>
<p>以上四个工作周期都有CPU访存操作，但是访存的目的不同。<br>
取指周期：取指令<br>
间址周期：取有效地址<br>
执行周期：取操作数<br>
中断周期：保存程序断点</p>
<p>为了区别不同的工作周期，会在CPU中设置4个标志触发器FE、IND、EX和INT分别对应取指、间址、执行、中断周期。</p>
<p>冯·诺伊曼机中指令和数据均以二进制形式存储在存储器中，CPU根据指令周期的不同阶段区分它们</p>
<h3 id="指令周期的数据流"><a class="header-anchor" href="#指令周期的数据流">¶</a>指令周期的数据流</h3>
<p>可以参考网络或书本视频，这里不详细说明</p>
<h3 id="指令执行方案"><a class="header-anchor" href="#指令执行方案">¶</a>指令执行方案</h3>
<ol>
<li>单指令周期：所以指令都选用相同的执行时间，指令之间串行执行</li>
<li>多指令周期：不同的指令采用不同的执行步骤，指令之间串行执行</li>
<li>流水线方案：指令间可以并行执行</li>
</ol>
<h2 id="CPU内的数据通路"><a class="header-anchor" href="#CPU内的数据通路">¶</a>CPU内的数据通路</h2>
<p>本节会在大题中考察，最好结合视频和实际例题学习<br>
数据在功能部件之间传送的路径称为数据通路，也包括了数据通路上流经的部件，如ALU、通用寄存器、状态寄存器等。</p>
<p>数据通路的功能是实现CPU内部的运算器与寄存器及寄存器之间的数据交换。数据通路由控制部件控制。</p>
<p>数据流向有三种方向</p>
<ol>
<li>
<p>寄存器之间</p>
</li>
<li>
<p>流入ALU中计算</p>
</li>
<li>
<p>内存与CPU之间</p>
</li>
</ol>
<h3 id="数据通路的基本结构"><a class="header-anchor" href="#数据通路的基本结构">¶</a>数据通路的基本结构</h3>
<ol>
<li>CPU内部单总线结构：将所有寄存器的输入端和输出端都连接到一条总线上</li>
<li>CPU内部多总线结构：将所有寄存器的输入端和输出端都连接到多条总线上</li>
<li>专用数据通路：根据指令执行过程中的数据和地址流动方向安排连接线路，避免使用共享总线</li>
</ol>
<h3 id="例题分析"><a class="header-anchor" href="#例题分析">¶</a>例题分析</h3>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-CPU-1.2mxlqg6xcc80.webp" alt="计组-CPU-1"></p>
<p>分析：<br>
对主存来说MemR表示要进行读操作，MemW进行写操作。<br>
指令$ADD (R_0),R_1$：<br>
$(R_0)$是目的操作数，$(R_0)$加括号表示寄存器中保存的是操作数在主存中的地址，需要进行一次间接寻址在主存中找到所需的操作数。<br>
$R_1$是源操作数，操作数就保存在寄存器$R_1$中<br>
对于ADD指令，执行完的数据要保存再到$(R_0)$中</p>
<ol>
<li>分析指令功能和指令周期<br>
功能：$((R_0))+(R_1)-&gt;(R_0)$<br>
指令周期：取指周期、间址周期、执行周期</li>
<li>各阶段指令流程</li>
</ol>
<p>取指周期：公共操作</p>
<table>
<thead>
<tr>
<th style="text-align:center">时序</th>
<th style="text-align:center">微操作</th>
<th style="text-align:center">有效控制信号</th>
<th style="text-align:center">具体功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">(PC)-&gt;MAR</td>
<td style="text-align:center">PCout,MARin</td>
<td style="text-align:center">将PC经内部总线送至MAR</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">M(MAR)-&gt;MDR</td>
<td style="text-align:center">MemR,MARout,MDRinE</td>
<td style="text-align:center">主存通过数据总线将MAR所指单元内容发送至MDR</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">(MDR)-&gt;IR</td>
<td style="text-align:center">MDRout,IRin</td>
<td style="text-align:center">将MDR的内容发生到IR</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">指令译码</td>
<td style="text-align:center">-</td>
<td style="text-align:center">操作字开始控制CU</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">(PC)+1-&gt;PC</td>
<td style="text-align:center">-</td>
<td style="text-align:center">当PC+1有效时，使PC内容+1</td>
</tr>
</tbody>
</table>
<p>间址周期：完成取数操作，被加数在主存中，加数已经放在寄存器$R_1$中</p>
<table>
<thead>
<tr>
<th style="text-align:center">时序</th>
<th style="text-align:center">微操作</th>
<th style="text-align:center">有效控制信号</th>
<th style="text-align:center">具体功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">$(R_0)$-&gt;MAR</td>
<td style="text-align:center">R0out,MARin</td>
<td style="text-align:center">将$R_0$中地址(形式地址)送至存储器地址寄存器</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">M(MAR)-&gt;MDR</td>
<td style="text-align:center">MemR,MARout,MDRinE</td>
<td style="text-align:center">主存通过数据总线将MAR所指单元的内容(有效地址)送至MDR中</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">(MDR)-&gt;Y</td>
<td style="text-align:center">MDRout,Yin</td>
<td style="text-align:center">将MDR中数据通过数据总线送至Y</td>
</tr>
</tbody>
</table>
<p>执行周期：在ALU中完成加法操作，并将结果返回主存中（也就是($(R_0)$)）</p>
<table>
<thead>
<tr>
<th style="text-align:center">时序</th>
<th style="text-align:center">微操作</th>
<th style="text-align:center">有效控制信号</th>
<th style="text-align:center">具体功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">$(R_1)$+Y-&gt;Z</td>
<td style="text-align:center">R1out,ALUin,CU向ALU发ADD信号</td>
<td style="text-align:center">$R_1$的内容和Y相加，结果送至Z寄存器</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">(Z)-&gt;MDR</td>
<td style="text-align:center">Zout,MDRin</td>
<td style="text-align:center">将运算结果送至MDR</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">(MDR)-&gt;M(MAR)</td>
<td style="text-align:center">MemW,MDRoutE,MARout</td>
<td style="text-align:center">将数据写入内存</td>
</tr>
</tbody>
</table>
<h2 id="控制器的功能和工作原理"><a class="header-anchor" href="#控制器的功能和工作原理">¶</a>控制器的功能和工作原理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-CPU-2.t2e63h3bku8.webp" alt="计组-CPU-2"></p>
<p>上图是计算机硬件系统的五大功能部件及其连接关系。它们通过数据总线、地址总线和控制总线连接在一起</p>
<p>控制器是计算机系统的指挥中心，其主要功能有：</p>
<ol>
<li>从主存中取去一条指令，并指出下一条指令在主存中的位置</li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</li>
<li>指挥并控制CPU、主存、输入和输出设备之间的数据流动方向</li>
</ol>
<h3 id="硬布线控制器"><a class="header-anchor" href="#硬布线控制器">¶</a>硬布线控制器</h3>
<p>硬布线控制器是将控制部件做成产生专门固定时序控制信号的逻辑电路<br>
简单了解即可</p>
<h3 id="微程序控制器"><a class="header-anchor" href="#微程序控制器">¶</a>微程序控制器</h3>
<p>微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，使每条机器指令转化为一段微程序并存入一个专门的存储器（控制存储器），微操作控制信号由微指令产生</p>
<p>微程序设计思想就是将每条机器指令编成一个微程序，每个微程序包含若干个微指令，每条微指令对应一个或多个微操作命令</p>
<h4 id="基本概念-v3"><a class="header-anchor" href="#基本概念-v3">¶</a>基本概念</h4>
<ul>
<li>
<p><strong>指令</strong>：对<strong>程序</strong>执行步骤的描述</p>
</li>
<li>
<p><strong>微指令</strong>：对<strong>指令</strong>执行步骤的描述</p>
</li>
<li>
<p><strong>程序</strong>：是由多条<strong>指令序列</strong>组成，而一条指令由多个微指令组成</p>
</li>
<li>
<p><strong>微程序</strong>：由<strong>微指令序列</strong>组成，每一种<strong>指令</strong>对应一个微程序，即微程序和(机器)指令是一一对应的</p>
</li>
<li>
<p><strong>微命令和微操作</strong>：一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本、不可再分解的操作。微命令是微操作的控制信号，微操作是微命令的执行过程</p>
</li>
<li>
<p><strong>微指令和微周期</strong>：微指令是若干微命令的集合。存放微指令的控制存储器的单元地址称为微地址（每条微指令都对应一条存储地址）。微周期是指执行一条微指令所需的时间，通常为一个<a href="#%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F">时钟周期</a>。</p>
</li>
<li>
<p><strong>主存储器与控制存储器</strong>：主存储器即主存（RAM、内存）用于存放程序和数据，在CPU外。控制存储器（CM）用于存放微程序，在CPU内部，用ROM实现</p>
</li>
<li>
<p><strong>程序和微程序</strong>：程序是指令的有序集合用于完成特定的功能；微程序是微指令是有序集合，一条指令的功能由一段微程序实现（指令是对微指令功能的“封装”）</p>
</li>
<li>
<p>对于用户而言，计算机系统中的微程序的结构和功能是透明的，无需知道。</p>
</li>
<li>
<p>一条指令一般用取指、间址、执行和中断周期组成，其中取指、间址、中断周期的微程序是共用的，一般只有执行周期的微程序不同。</p>
<ul>
<li>如果某指令系统有N条机器指令，则控制存储器(CM)中微程序个数至少是N+1个（间址和中断可以没有）</li>
</ul>
</li>
<li>
<p>注意区别以下寄存器</p>
<ul>
<li>地址寄存器（MAR）：用于存放主存的读、写地址</li>
<li>微地址寄存器（CMAR）：用于存放控制存储器的读、写微指令的地址</li>
<li>指令寄存器（IR）：存放从主存中读出的指令</li>
<li>微指令寄存器（CMDR）：存放从控制存储器中读出的微指令</li>
</ul>
</li>
</ul>
<h4 id="微指令的编码方式"><a class="header-anchor" href="#微指令的编码方式">¶</a>微指令的编码方式</h4>
<p>微指令的编码方式即微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。</p>
<ol>
<li>
<p><strong>直接编码（直接控制）方式</strong><br>
直接编码无需译码，微指令的微命令字段中每位都代表一个微命令。<br>
N个微命令对应N位操作字段</p>
</li>
<li>
<p><strong>字段直接编码方式</strong><br>
将为直流电微命令字段分成若干小字段，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关<br>
分段原则：</p>
<ol>
<li>互斥性微命令分在同一字段内，相容性微命令分在不同字段内</li>
<li>每个小段内包含的信息位不能太多</li>
<li>每个小段还有留出一个状态，表示本字段不发出任何微命令。类如，某字段的长度为三位时，最多只能表示7个互斥的微命令。</li>
</ol>
</li>
<li>
<p>字段间接编码方式<br>
一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，又称隐式编码</p>
</li>
<li>
<p>例题<br>
1.<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-CPU-3.4818iu93y580.webp" alt="计组-CPU-3"><br>
答：分别包含7、3、12、5和6个微命令，则需要3、2、4、3、和3比特位，共15位</p>
<ol start="2">
<li></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-CPU-4.d7lip76u3yw.webp" alt="计组-CPU-4"><br>
答：共有32条指令，每个微程序平均由4条微指令组成，则对应的微指令为$32\times4=128$条，公共微指令2两条，则整个系统的微指令条数为130条，则至少要8个比特位（$2^7=128$ &lt; 130 &lt; $2^8=256$）</p>
</li>
</ol>
<h4 id="微指令的地址形成方式"><a class="header-anchor" href="#微指令的地址形成方式">¶</a>微指令的地址形成方式</h4>
<ol>
<li><strong>直接由微指令的下地址字段指出</strong><br>
微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，又称为断定方式</li>
<li>增量计数器法<br>
(CMAR)+1-&gt;CMAR，适用于后继微指令的地址连续的情况</li>
<li>根据机器指令的操作码形成<br>
当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成</li>
</ol>
<h4 id="微指令的格式"><a class="header-anchor" href="#微指令的格式">¶</a>微指令的格式</h4>
<p>微指令的格式与微指令的编码方式有关，有两种</p>
<ol>
<li>水平型微指令<br>
从编码方式看，直接编码、字段直接编码、字段间接编码和混合编码都属于水平型编码。一条水平型微指令定义并执行几种并行的基本操作<br>
优点：微程序短，执行速度快<br>
缺点：微指令长，编写程序较麻烦</li>
</ol>
<table>
    <tr>
        <td align="center">$A_1$</td>
        <td align="center">$A_2$</td>
        <td align="center">...</td>
        <td align="center">$A_n$</td>
        <td align="center">判断测试字段</td>
        <td align="center">后继地址字段</td>
    </tr>
    <tr>
        <td colspan="4" align="center">操作控制</td>
        <td colspan="2" align="center">顺序控制</td>>
    </tr>
</table>
<ol start="2">
<li>垂直型微指令<br>
在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能。一条垂直型微指令只能定义并执行一种基本操作<br>
优点：微指令短、简单、便于编写微程序<br>
缺点：微程序长、执行速度慢、工作效率低</li>
</ol>
<table>
    <tr>
        <td align="center">$\mu OP$</td>
        <td align="center">$Rd$</td>
        <td align="center">Rs</td>
    </tr>
    <tr>
        <td align="center">微操作码</td>
        <td align="center">目的地址</td>
        <td align="center">源地址</td>>
    </tr>
</table>
<ol start="3">
<li>混合型微指令<br>
在垂直型的基础上增加一些不太复杂的并行操作</li>
</ol>
<h2 id="指令流水线"><a class="header-anchor" href="#指令流水线">¶</a>指令流水线</h2>
<p>提高指令运行效率可以采用指令流水线的方式，可以从两方面提高处理机的并行性</p>
<ol>
<li>时间上的并行性：即流水线技术</li>
<li>空间上的并行性：超标量处理机</li>
</ol>
<h3 id="指令流水线的定义"><a class="header-anchor" href="#指令流水线的定义">¶</a>指令流水线的定义</h3>
<p>将一条指令的执行过程分解为若干阶段，每个阶段由相应的功能部件完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-CPU-5.5p4mbj58csw0.webp" alt="计组-CPU-5"></p>
<h3 id="流水线的基本实现"><a class="header-anchor" href="#流水线的基本实现">¶</a>流水线的基本实现</h3>
<p>建议观看相应视频加以学习。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-CPU-6.enoo1nhf8ew.webp" alt="计组-CPU-6"></p>
<ul>
<li><strong>流水线的数据通路</strong>
<ul>
<li>IF段包括程序计数器（PC）、指令存储器、下条指令地址的计算逻辑</li>
<li>ID段包括操作控制器、取操作数逻辑、立即数符号拓展模块</li>
<li>EX段包括算术逻辑单元（ALU）、分支地址计算模块、</li>
<li>MEM段主要包括数据存储读写模块</li>
<li>WB段主要包括寄存器写入控制模块</li>
</ul>
</li>
<li>每个流水段后面都需要增加一个流水寄存器，用于锁存本段处理完成的数据和控制信号（即锁存器或缓冲寄存器，目的是便于统一每一段时间使其统一）</li>
</ul>
<h3 id="流水线的冒险和处理"><a class="header-anchor" href="#流水线的冒险和处理">¶</a>流水线的冒险和处理</h3>
<h4 id="结构冒险——“互斥”"><a class="header-anchor" href="#结构冒险——“互斥”">¶</a>结构冒险——“互斥”</h4>
<p>由于多条指令在同一时刻争用同一硬件资源形成的冲突，也称资源冲突<br>
解决办法：</p>
<ol>
<li>前一指令访存时，使后续指令暂停一个时钟周期</li>
<li>增加硬件资源，设置单独的数据存储器和指令存储器</li>
</ol>
<h4 id="star-数据冒险——“同步问题”"><a class="header-anchor" href="#star-数据冒险——“同步问题”">¶</a>$\star$ 数据冒险——“同步问题”</h4>
<p>在一个指令中，下一条指令会用到当前指令计算出的结果，此时这两条指令就会产生数据冲突</p>
<ol>
<li>
<p>RAW（read after write）：又称先写后读相关性。<br>
比如下面指令序列，如果第二条指令，在第一条指令写x5之前，第二条指令先读x5，就会引起逻辑错误。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add x5, x4, x6</span><br><span class="line">add x4, x5, x2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>WAW（write after write）：又称先写后写相关性。<br>
比如下面指令序列，如果第二条指令，在第一条指令写x5之前，第二条指令先写x5寄存器，就会引起逻辑错误。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add x5, x4, x6</span><br><span class="line">add x5, x3, x2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>WAR（write after read）：又称先读后写相关性。<br>
比如下面的指令序列，第一条指令会读取x4，第二条指令会写x4。在流水线中，如果第二条指令比第一条指令先写x4，则第一条指令就会读出错误的值。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add x5, x4, x6</span><br><span class="line">add x4, x3, x2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解决办法：</p>
<ol>
<li>将后续指令暂停一到几个时钟周期</li>
<li>设置专用数据通路</li>
<li>编译器对指令编译优化，调整指令顺序</li>
</ol>
<h4 id="控制冒险"><a class="header-anchor" href="#控制冒险">¶</a>控制冒险</h4>
<p>又称分支冒险，指令流水时，处理器遇到分支指令，如执行转移、调用或返回时，会修改PC值，会造成断流，不能在流水开始阶段就判断出分支结果。<br>
解决办法：</p>
<ol>
<li>对转移指令进行分支预测</li>
<li>预先加载成功与不成功两个控制流方向上的目标指令</li>
<li>提高分支预测成功率</li>
</ol>
<h3 id="流水线的性能指标"><a class="header-anchor" href="#流水线的性能指标">¶</a>流水线的性能指标</h3>
<h4 id="流水线的吞吐率（TP）"><a class="header-anchor" href="#流水线的吞吐率（TP）">¶</a>流水线的吞吐率（TP）</h4>
<p>在单位时间内流水线所完成的任务数量，公式：<br>
$TP=\frac{n}{T_k}$<br>
n是任务数，$T_K$是处理完n个任务所用的总时间</p>
<p>设k为流水线段数，$\bigtriangleup t$为时钟周期，在输入流水线的任务连续的理想情况下，一条k段流水线能在k+n-1个时钟周期内完成n个任务。<br>
此时流水线的吞吐率为：$TP=\frac{n}{(k+n-1) \ast (\bigtriangleup t)}$，当$n \rightarrow \infty$，得最大吞吐率${TP_{max}}=\frac{1}{\bigtriangleup t}$</p>
<h4 id="流水线的加速比（S）"><a class="header-anchor" href="#流水线的加速比（S）">¶</a>流水线的加速比（S）</h4>
<p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比，称为流水线的加速比。公式：<br>
$S=\frac{T_0}{T_k}$<br>
${T_0}$表示不使用流水线时的执行时间；${T_k}$表示使用流水线的总时间。<br>
对于一条k段流水线，当连续输入任务数$n \rightarrow \infty$，得最大加速比${S_{max}=k}$</p>
<h4 id="流水线的效率（E）"><a class="header-anchor" href="#流水线的效率（E）">¶</a>流水线的效率（E）</h4>
<p>流水线的设备利用率称为流水线的效率。<br>
在时空图上，流水线的效率定义为完成n个任务占用的时空区有效面积，与n个任务所用的时间及k个流水段所围成的时空区总面积之比。因此，流水线的效率包含了时间和空间两个因素。<br>
$E=\frac{n个任务占用k时空区域的有效面积}{n个任务所用的时间与k个流水段所围成的时刻区域总面积}=\frac{T_0}{k\ast{T_k}}$<br>
当$n\rightarrow \infty，E_{max}=1$</p>
<h3 id="高级流水线技术"><a class="header-anchor" href="#高级流水线技术">¶</a>高级流水线技术</h3>
<ol>
<li>
<p>超标量流水线技术（多发技术，在空间上）<br>
也称为动态多发射技术。每个时钟周期内可并发多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件。<br>
超标量计算机不能调整指令的执行顺序（但有些CPU可以，支持乱序执行），因此通过编译优化技术，把可并行执行的指令搭配起来，挖掘更多的指令并行性。</p>
</li>
<li>
<p>超流水线技术（在时间上）<br>
<strong>在一个时钟周期内再分段</strong>，在一个时钟周期内一个功能部件使用多次。不能调整指令的执行顺序，靠编译程序解决优化问题。</p>
</li>
<li>
<p>超长指令字<br>
由编译程序挖掘出指令间潜在的并行性，将<strong>多条能并行操作</strong>的指令组合成一条具有多个操作码字段的超长指令字（可达几百位），为此需要采用多个处理部件</p>
</li>
</ol>
<h2 id="多处理器的基本概念"><a class="header-anchor" href="#多处理器的基本概念">¶</a>多处理器的基本概念</h2>
<h3 id="SISD、SIMD、MIMD的基本概念"><a class="header-anchor" href="#SISD、SIMD、MIMD的基本概念">¶</a>SISD、SIMD、MIMD的基本概念</h3>
<h4 id="单指令流单数据流SISD"><a class="header-anchor" href="#单指令流单数据流SISD">¶</a>单指令流单数据流SISD</h4>
<ol>
<li>
<p><strong>特性</strong>：<br>
各指令序列<strong>只能并发、不能并行</strong>，每条指令处理一两个数据<br>
不是数据级并行技术</p>
</li>
<li>
<p>硬件组成：<br>
一个处理器+一个主存储器<br>
若采用指令流水线，需设置多个功能部件，采用多模块交叉存储器</p>
</li>
</ol>
<h4 id="单指令流多数据流SIMD"><a class="header-anchor" href="#单指令流多数据流SIMD">¶</a>单指令流多数据流SIMD</h4>
<ol>
<li>
<p><strong>特性</strong>：<br>
各指令序列<strong>只能并发、不能并行</strong>，但每条指令可同时处理很多个具有相同特征的数据，是一种<strong>数据级并行技术</strong></p>
</li>
<li>
<p>硬件组成：<br>
一个指令控制部件(CU)+多个处理单元/执行单元（如ALU）＋多个局部存储器＋一个主存储器<br>
每个执行单元有各自的寄存器组、局部存储器、地址寄存器<br>
不同执行单元执行同一条指令，处理不同的数据</p>
</li>
</ol>
<h4 id="多指令流单数据流MISD"><a class="header-anchor" href="#多指令流单数据流MISD">¶</a>多指令流单数据流MISD</h4>
<p>多条指令并行执行，处理同一个数据。现实中不存在这种计算机</p>
<h4 id="多指令流多数据流MIMD"><a class="header-anchor" href="#多指令流多数据流MIMD">¶</a>多指令流多数据流MIMD</h4>
<ol>
<li><strong>特性</strong>：<br>
各指令序列并行执行,分别处理多个不同的数据<br>
是—种线程级并行、甚至是线程级以上并行技术</li>
</ol>
<h3 id="硬件多线程基本概念"><a class="header-anchor" href="#硬件多线程基本概念">¶</a>硬件多线程基本概念</h3>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-CPU-7.539hye5dkb40.webp" alt="计组-CPU-7"></p>
<h3 id="多核处理器基本概念"><a class="header-anchor" href="#多核处理器基本概念">¶</a>多核处理器基本概念</h3>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-CPU-8.2ag0m5vhvv8k.webp" alt="计组-CPU-8"></p>
<h2 id="典型例题-v2"><a class="header-anchor" href="#典型例题-v2">¶</a>典型例题</h2>
<p>待补充</p>
<hr>
<p>参考文献：<br>
《王道考研-计算机组成原理复习指导》<br>
《Computer Systems A Programer’s Perspective Third Edition》</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计组</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理-存储系统</title>
    <url>/2023/04/27/78ffecc46533/</url>
    <content><![CDATA[<h2 id="简介-v7"><a class="header-anchor" href="#简介-v7">¶</a>简介</h2>
<p>计算机组成原理系列其二，主要是针对中国大陆考研所要求的内容对计算机组成原理的知识体系进行总结和梳理，本篇内容是计算机内部和外部的存储介绍，主要包含以下几点：</p>
<ul>
<li>存储器的分类与层次化的存储器基本结构</li>
<li>主存与外(辅)存</li>
<li>主存的拓展和外存的结构</li>
<li>Cache</li>
<li>虚拟内存</li>
</ul>
<span id="more"></span>
<h2 id="大纲-v4"><a class="header-anchor" href="#大纲-v4">¶</a>大纲</h2>
<ul>
<li>存储系统
<ul>
<li>存储器概述
<ul>
<li>多种角度进行分类</li>
<li>存储器的性能指标</li>
<li>多层次的存储系统</li>
</ul>
</li>
<li>主存储器(主存)
<ul>
<li>SRAM和DRAM简介</li>
<li>DRAM的工作原理
<ul>
<li>DRAM的刷新</li>
<li>DRAM的地址引脚复用</li>
</ul>
</li>
<li>ROM
<ul>
<li>特点</li>
<li>类型</li>
</ul>
</li>
<li>多模块存储器
<ul>
<li>单体多字存储器和双端口RAM</li>
<li>多体并行存储器
<ul>
<li>高位交叉编址(顺序方式)</li>
<li>低位交叉编址(交叉方式)</li>
<li>两者的性能分析</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>主存储器和CPU的连接
<ul>
<li>连接原理</li>
<li>主存的容量扩展
<ul>
<li>位扩展法</li>
<li>字扩展法</li>
<li>字位同时扩展法</li>
</ul>
</li>
</ul>
</li>
<li>外部存储器
<ul>
<li>磁盘存储器(机械硬盘)
<ul>
<li>磁盘的组成</li>
<li>磁盘的性能指标</li>
</ul>
</li>
<li>磁盘阵列和固态硬盘</li>
</ul>
</li>
<li>高速缓冲存储器(Cache)(重难点)
<ul>
<li>Cache的工作原理
<ul>
<li>Cache的命中率</li>
</ul>
</li>
<li>Cache和主存的映射方式
<ul>
<li>直接映射</li>
<li>全相联映射</li>
<li>组相联映射</li>
</ul>
</li>
<li>Cache中主存块的替换算法
<ul>
<li>近期最少使用（LRU）算法</li>
</ul>
</li>
<li>Cache的写策略
<ul>
<li>Cache写命中
<ul>
<li>全写法</li>
<li>写回法</li>
</ul>
</li>
<li>Cache写不命中
<ul>
<li>写分配法</li>
<li>非写分配法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>虚拟内存</li>
<li>典型例题</li>
</ul>
</li>
</ul>
<h2 id="存储器概述"><a class="header-anchor" href="#存储器概述">¶</a>存储器概述</h2>
<h3 id="计算机中的存储器可以按照多种角度进行分类"><a class="header-anchor" href="#计算机中的存储器可以按照多种角度进行分类">¶</a>计算机中的存储器可以按照多种角度进行分类</h3>
<ol>
<li>按照层次分类
<ul>
<li>主存：我们通常称为内存，CPU可以直接随机的对其访问，上联CPU和Cache，下联辅存</li>
<li>辅存：我们通常称为硬盘，用来存放需要永久保存的数据，计算机中的绝大多数数据都保存在辅存中，运行时调入内存和CPU计算</li>
<li>高速缓冲存储器：简称Cache，位于CPU和内存之间，是为了解决CPU和内存之间的速度不匹配问题</li>
</ul>
</li>
<li>按照存储介质分类
<ul>
<li>磁表面：磁盘、磁带、</li>
<li>半导体存储器：RAM和ROM</li>
<li>光存储器：光盘</li>
</ul>
</li>
<li>按照存取方式分类
<ul>
<li>RAM（Random-access memory）：顾名思义，RAM的任何一个存储单元都可以随机存取，可以视为一个巨大的数组，其存取时间和存储单元的物理位置无关，缺点是具有易失性（断电后信息会丢失）</li>
<li>ROM（Read-only memory）：虽然名字叫Read-noly但现代的ROM可以进行多次读写，“只读”的概念没有保留，但其仍保留了非易失性（断电后信息不会丢失）</li>
<li>DAM（串行访问存储器）：对存储单元进行读、写操作时，需要按照其物理地址的先后顺序寻址，如磁带、磁盘、光盘等</li>
</ul>
</li>
<li>按信息的可保存性分类
<ul>
<li>RAM</li>
<li>ROM</li>
</ul>
</li>
</ol>
<h3 id="存储器的性能指标"><a class="header-anchor" href="#存储器的性能指标">¶</a>存储器的性能指标</h3>
<ol>
<li>存储容量 = 存储字数 $\times$ 字长（如$ 1M \times 8位 =\rangle 地址位: 1 \times {10}^{20}个\ 数据位: 8bit$ ），存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量</li>
</ol>
<blockquote>
<p>在题目中常会遇到，某计算机存储器按字节编址，主存的地址空间大小为64MB，翻译过来就是地址位有$64M = 2^{26}$，即地址位为26位，按照字节编址其数据位就是 $1Byte = 2^{3}$，3位</p>
</blockquote>
<ol start="2">
<li>存储速度：$数据传输率 = \frac{数据的宽度}{存取周期}$
<ol>
<li>存取时间（$ T_a $）：从启动一次存储器操作到完成该操作所经历的时间，分为读出和写入时间</li>
<li>存取周期（$ T_m $）：是连续两次独立访问存储器操作之间所需的最小时间间隙</li>
</ol>
</li>
</ol>
<blockquote>
<p>Tips：$T_a \neq T_m$，通常来说，存取周期大于存取时间，因为在完成一次存取操作后，任何一个存储器都需要一个恢复时间<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-1.14gebcx5l3kw.webp" alt="计组-存储系统-1"></p>
</blockquote>
<h3 id="多层次的存储系统"><a class="header-anchor" href="#多层次的存储系统">¶</a>多层次的存储系统</h3>
<p>一图总结：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-2.2b9y7c0mamsk.webp" alt="计组-存储系统-2"></p>
<blockquote>
<p>Tips: 在Cache——主存层和主存——辅存层中，上一层的内容都只是下一层的一个副本，Cache（或主存）中的内容只是主存（或辅存）中内容的一部分</p>
</blockquote>
<h2 id="主存储器"><a class="header-anchor" href="#主存储器">¶</a>主存储器</h2>
<h3 id="SRAM和DRAM简介"><a class="header-anchor" href="#SRAM和DRAM简介">¶</a>SRAM和DRAM简介</h3>
<p>RAM（随机存储器）分为SRAM（Static RAM）和DRAM（Dynamic RAM）两种，他们都具有易失性，其主要区别是是否需要刷新。SRAM常用来制作Cache，DRAM常用来制作内存。SRAM没什么考点，考试的重点是二者的区别</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-3.3af0k98u1960.webp" alt="计组-存储系统-3"></p>
<center style="color:#FF69B4;font-size:16px;text-decoration">两者的区别</center>
<h3 id="DRAM的工作原理"><a class="header-anchor" href="#DRAM的工作原理">¶</a>DRAM的工作原理</h3>
<p>DRAM是利用存储元电路中栅极电容上的电荷来储存信息的，其具有集成度高、容量大、价格低、功耗低等优点，但其速度较SRAM慢，是破坏性读出。因此需要它需要进行刷新来保证其存储的信息不丢失</p>
<h4 id="DRAM的刷新"><a class="header-anchor" href="#DRAM的刷新">¶</a>DRAM的刷新</h4>
<p>DRAM上电容的电荷一般只能维持1~2ms，即使不断电也其信息也会消失，每隔一段时间必须刷新一次，通常取2ms，称为一个刷新周期。常用的刷新方式有以下三种：</p>
<ul>
<li>集中刷新：在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。集中刷新的时间不能进行读/写操作，故称为“死时间”或访存“死区”</li>
<li>分散刷新：对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期$T_c$分成两段，前半段$T_m$用来读\写或维持信息，后半段$T_r$用来刷新。优点是没有停止读/写的死时间，缺点是存取周期长了</li>
<li>异步刷新：既可以缩短“死时间”，又充分利用最大刷新间隔为2ms的特点，具体操作为：在2ms内对128行各刷新一遍。将刷新周期除以行数，得到两次刷新操作之间时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-5.usticucqmkw.webp" alt="计组-存储系统-5"></p>
<center style="color:#FF69B4;font-size:16px;text-decoration">DRAM芯片的栅极电容</center>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-4.3m70245q54u0.webp" alt="计组-存储系统-4"></p>
<center style="color:#FF69B4;font-size:16px;text-decoration">DRAM的刷新</center>
<h4 id="地址引脚复用"><a class="header-anchor" href="#地址引脚复用">¶</a>地址引脚复用</h4>
<p>（考试常考，需记住）DRAM芯片容量较大，地址位数较多，为了减少芯片的地址引脚数，通常采用地址引脚复用技术，行地址和列地址通过相同的引脚分前后两次输入，这样就可以减少一半的地址引脚</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-6.3zg25ew1rc80.webp" alt="计组-存储系统-6"></p>
<h3 id="ROM"><a class="header-anchor" href="#ROM">¶</a>ROM</h3>
<h4 id="特点"><a class="header-anchor" href="#特点">¶</a>特点</h4>
<ol>
<li>结构简单，位密度比可读写存储器高</li>
<li>具有非易失性</li>
</ol>
<h4 id="ROM的类型"><a class="header-anchor" href="#ROM的类型">¶</a>ROM的类型</h4>
<p>考试只需记住各个类型的名称即可，无需细究</p>
<ul>
<li>MROM（Mask ROM，掩模式只读存储器）
<ul>
<li>MROM的主要优点是存储内容固定，掉电后信息仍然存在,可靠性高。缺点是信息一次写入（制造）后就不能修改</li>
</ul>
</li>
<li>PROM（Programmable ROM，可编程只读存储器）
<ul>
<li>仅只能编写一次，第一次写入的信息就被永久性地保存起来</li>
</ul>
</li>
<li>EPROM（Erasable Programmable ROM，可编程可擦除只读存储器）
<ul>
<li>用户可以自己写入信息，且可以多次修改，但修改的次数有限</li>
</ul>
</li>
<li>Flash（Flash Memory，快擦除读写存储器）
<ul>
<li>可以长期保存信息，也可以在线进行快速擦除和重写</li>
</ul>
</li>
<li>SSD（Soild State Drives，固态硬盘）</li>
</ul>
<h3 id="双端口RAM和多模块存储器"><a class="header-anchor" href="#双端口RAM和多模块存储器">¶</a>双端口RAM和多模块存储器</h3>
<p>多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率。常用的有单体多字存储器和多体并行存储器</p>
<h4 id="单体多字存储器和双端口RAM"><a class="header-anchor" href="#单体多字存储器和双端口RAM">¶</a>单体多字存储器和双端口RAM</h4>
<p>仅做简单了解，这里不详细说明，考试重点在多体并行存储器</p>
<h4 id="多体并行存储器"><a class="header-anchor" href="#多体并行存储器">¶</a>多体并行存储器</h4>
<p>多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，也具有独立的读写控制电路、地址寄存器和数据寄存器。其目的是为了解决一个存期周期中恢复时间较长问题，分为高位交叉编址和低位交叉编址</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-8.7bi4xtajf5w0.webp" alt="计组-存储系统-8"></p>
<center style="color:#FF69B4;font-size:16px;text-decoration">图1-1 二者对比</center>
<h5 id="高位交叉编址（顺序方式）"><a class="header-anchor" href="#高位交叉编址（顺序方式）">¶</a>高位交叉编址（顺序方式）</h5>
<p>高位交叉编址的实际效果相当于单纯的扩容，并没有解决存储周期恢复时间较长的问题。通过分析其地址存储方式可知，它是在一条存储器上顺序分布的，在<strong>连续取址</strong>时每个存储器还是需要时间来恢复，不能多条存储器并行操作</p>
<ol>
<li>高位地址表示体号，低位地址为体内地址</li>
<li>一个体内的地址是连续的，只需要一个地址寄存器，也有利于存储器的扩充</li>
<li>多模块串行，性能无提升</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-7.103n5a5rllf4.webp" alt="计组-存储系统-7"></p>
<h5 id="低位交叉编址（交叉方式）"><a class="header-anchor" href="#低位交叉编址（交叉方式）">¶</a>低位交叉编址（交叉方式）</h5>
<p>低位交叉编址的低位地址表示体号，高位表示体内地址，每个模块按“模M”交叉编址，模块号 = 单元地址 % M。</p>
<ol>
<li>低位地址表示体号，高位地址表示体内地址（这种编址方法又称模M编址，M等于模块数）</li>
<li>相邻地址位于不同存储体中，每个存储体都需要寄存器</li>
<li>多模块并行，可以实现对存储器的流水线式访问，性能提升</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-9.3g2fx6g1rxg0.webp" alt="计组-存储系统-9"></p>
<h5 id="性能分析"><a class="header-anchor" href="#性能分析">¶</a>性能分析</h5>
<p>设存储周期为T，总线传送周期为r，交叉模数为m。<br>
为了实现流水线方式存取，每通过r时间延迟后启动下一个模块，应满足：<br>
$T = m \ast r$<br>
交叉存储器要求其 $模块数 \geq m $，以保证启动某模块后经过$m \ast r$时间后再次启动该模块时，它上次存取操作已经完成。</p>
<ul>
<li>对于高位多体交叉，连续读取n个字的时间：$t_2 = n \ast T$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-11.2b54iheeexzw.webp" alt="计组-存储系统-11"></p>
<ul>
<li>对于低位多体交叉，连续并行读取n个字的时间：$ t_1 = T + (n - 1) \ast r$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-10.2y7dgin4g4m0.webp" alt="计组-存储系统-10"></p>
<h2 id="主存储器和CPU的连接"><a class="header-anchor" href="#主存储器和CPU的连接">¶</a>主存储器和CPU的连接</h2>
<h3 id="连接原理"><a class="header-anchor" href="#连接原理">¶</a>连接原理</h3>
<ol>
<li>主存储器通过数据总线（CPU使用MDR与主存通过数据总线交互）、地址总线（CPU使用MAR向主存发送地址）、控制总线（包括片选线、读控制线、写控制线）与CPU连接</li>
<li>数据总线的$位数\times工作频率$与数据传输率成正比</li>
<li>地址总线的位数决定了可寻址的最大内存空间</li>
<li>控制总线指出了总线周期的类型和本次输入\输出的操作完成时刻</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-12.45z3cxqct7s0.webp" alt="计组-存储系统-12"></p>
<h3 id="主存的容量扩展"><a class="header-anchor" href="#主存的容量扩展">¶</a>主存的容量扩展</h3>
<p>因为单个存储芯片的容量有限，所以需要在字（扩展地址位）和位（扩展数据位）两个方法对其进行扩容来满足实际需求。通常有位扩展法、字扩展法和字位同时扩展法来扩展主存容量</p>
<h4 id="位扩展法"><a class="header-anchor" href="#位扩展法">¶</a>位扩展法</h4>
<p>CPU的数据线数与存储芯片的数据位数不一定相等，需要对其进行位扩展，即使用多个存储器对字长进行扩充，增加存储字长</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-13.31o11ycpoym0.webp" alt="计组-存储系统-13"></p>
<blockquote>
<p>Tips:CS位片选线，WE为读写控制线</p>
</blockquote>
<h4 id="字扩展法"><a class="header-anchor" href="#字扩展法">¶</a>字扩展法</h4>
<p>字扩展是指增加存储器中的字的数量，而位数不变。字扩展将芯片的地址线、数据线、读写控制线并联，而由片选信号来区分各地址的范围<br>
如下图，用4片$16K\times8$位的RAM芯片组成$64K\times8$ 位的存储器。4片RAM芯片的数据线$D_0\sim D_7$和WE都分别连在一起。将$A_{15} A_{14}$用作片选信号，$A_{15} A_{14} = 00$ 时，译码器输出端0有效，选中最左边的1号芯片$A_{15} A_{14} = 01$时，译码器输出端1有效，选中2号芯片，以此类推（在同一时间内只能有一个芯片被选中）。各芯片的地址分配如下：</p>
<blockquote>
<p>第一片，最低地址：<strong>00</strong>00000000000000；最高地址：<strong>00</strong>11111111111111<br>
第二片，最低地址：<strong>01</strong>00000000000000；最高地址：<strong>01</strong>11111111111111<br>
第三片，最低地址：<strong>10</strong>00000000000000；最高地址：<strong>10</strong>11111111111111<br>
第四片，最低地址：<strong>11</strong>00000000000000；最高地址：<strong>11</strong>11111111111111</p>
</blockquote>
<p><strong>注意</strong>：仅采用宇扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在某一时刻只需选中部分芯片，所以通过片选信号CS或来用译码器设计连接到相应的芯片</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-14.4nnyi7j6l4o0.webp" alt="计组-存储系统-14"></p>
<h4 id="字位同时扩展法"><a class="header-anchor" href="#字位同时扩展法">¶</a>字位同时扩展法</h4>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-15.2lsqoibfdl40.webp" alt="计组-存储系统-15"></p>
<blockquote>
<p>$2/4译码器$：有两条线可生成两个片选信号，即可控制四个芯片，同理还有$3/8译码器$</p>
</blockquote>
<h2 id="外部存储器"><a class="header-anchor" href="#外部存储器">¶</a>外部存储器</h2>
<h3 id="磁盘存储器（机械硬盘）"><a class="header-anchor" href="#磁盘存储器（机械硬盘）">¶</a>磁盘存储器（机械硬盘）</h3>
<h4 id="磁盘的组成"><a class="header-anchor" href="#磁盘的组成">¶</a>磁盘的组成</h4>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-16.3lnb492kpwc0.webp" alt="计组-存储系统-16"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-17.1by39dhoi5q8.webp" alt="计组-存储系统-17"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-18.35tatq7l13i0.webp" alt="计组-存储系统-18"></p>
<h4 id="磁盘的性能指标（重点）"><a class="header-anchor" href="#磁盘的性能指标（重点）">¶</a>磁盘的性能指标（重点）</h4>
<ol>
<li>主机对磁盘的读写是以扇区为单位</li>
<li>每个磁道存储的数据量相同，越靠近内侧的磁道存储密度越大</li>
<li>磁盘的容量
<ol>
<li>非格式化容量：指理论上可以保存的数据量大小，由道密度和位密度计算</li>
<li>格式化容量，是指按照某种特定的记录格式所能存储信息的总量，格式化的容量要比非格式化的容量要小（会保留一部分容量备用）</li>
</ol>
</li>
<li>平均存取时间（重点）
<ol>
<li>寻道时间：磁头移动到目的磁道的时间</li>
<li>旋转延迟时间：磁头定位到要读写扇区的时间</li>
<li>传输时间：传输数据所花费的时间</li>
</ol>
</li>
</ol>
<blockquote>
<p>Tips：由于寻道和查找扇区的距离远近不一，所以寻道时间和旋转延迟时间通常取平均值</p>
<ol>
<li>平均旋转延迟时间：存取一个扇区的平均旋转延迟时间取旋转半周磁道的时间</li>
<li>平均寻道时间：取磁头从盘面最内圈转到最外圈的时间的一半</li>
<li>传输时间：$\frac{需要读取的数据量}{数据传输的速率}$</li>
</ol>
</blockquote>
<h3 id="磁盘阵列和固态硬盘"><a class="header-anchor" href="#磁盘阵列和固态硬盘">¶</a>磁盘阵列和固态硬盘</h3>
<ol>
<li>磁盘阵列(了解)<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-19.6ks1muz1yrc0.webp" alt="计组-存储系统-19"></li>
<li>SSD<br>
数据的读写以页为单位，擦除以块为单位。只有在一页所属的块整个被擦除后，才能写这一页<br>
在反复的写后，SSD的闪存块会磨损，SSD页会磨损，寿命有限<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-20.4aqiotbjtfu0.webp" alt="计组-存储系统-20"></li>
</ol>
<center style="color:#FF69B4;font-size:16px;text-decoration">一个页相当于一个扇区，一个块相当于一个磁道</center>
<h2 id="高速缓冲存储器（Cache）"><a class="header-anchor" href="#高速缓冲存储器（Cache）">¶</a>高速缓冲存储器（Cache）</h2>
<p>Cache作为本章的重点和难点，其核心问题主要分为三点：</p>
<ol>
<li>Cache和主存的映射方式</li>
<li>Cache中主存块的替换算法</li>
<li>Cache的写策略<br>
下面将重点从这三个方面来理解Cache在计算机中的工作方式和为什么需要Cache</li>
</ol>
<h3 id="Cache的工作原理"><a class="header-anchor" href="#Cache的工作原理">¶</a>Cache的工作原理</h3>
<p>之所以要在CPU和主存之间增加一层Cache正是为了解决CPU和主存之间速度不匹配的问题，正如外存和主存一样，Cache中的内容是主存中的一个<strong>副本</strong>。因为计算机的程序访问具有<a href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8%E6%80%A7">局部性原理</a>，所以我们可以在CPU和主存之间增加Cacha层来提高计算机的整体运行速度</p>
<h4 id="Cache的命中率"><a class="header-anchor" href="#Cache的命中率">¶</a>Cache的命中率</h4>
<p>CPU欲访问的信息已在Cache中的比率称为Cache的命中率。<br>
设一个程序执行期间，Cache的总命中次数为$N_c$，访问主存的总次数为$N_m$，则命中率H为：$H = \frac{N_c}{N_c+N_m}$</p>
<p>设$t_c$为命中时的Cache访问时间，$t_m$为未命中时的访问时间，$1-H$表示未命中率，则Cache-主存系统的平均访问时间$T_a$为：$T_a=H\ast{t_c}+(1-H){t_m}$（此命中率为CPU对Cache和主存同时访问）<br>
若为，先访问Cache再访问主存则时间为：$t=H\ast{t_c}+(1-H)({t_c+t_m})$</p>
<h3 id="Cache和主存的映射方式"><a class="header-anchor" href="#Cache和主存的映射方式">¶</a>Cache和主存的映射方式</h3>
<p>主存与Cache之间以“块”为单位进行数据交换（注：在操作系统中将主存中的“块”称为“页/页面”，Cache中的“块”称为“行”，在这里统一称为块，便于描述）<br>
地址映射是指把主存的地址空间映射到Cache地址空间，即把存放在主存中的信息按照某种规则装入Cache。地址映射的方式主要有以下三种：</p>
<ol>
<li>直接映射</li>
<li>全相联映射</li>
<li>组相联映射</li>
</ol>
<h4 id="直接映射"><a class="header-anchor" href="#直接映射">¶</a>直接映射</h4>
<p>直接映射是主存中的每一块只能装入Cache中的<strong>唯一位置</strong>。若该位置已有内容，则产生冲突，需要将原来的块替换出去。直接映射实现简单，即使Cache中有许多地址空缺也不能占用，但这使得直接映射的块冲突概论最高，空间利用率最低<br>
直接映射关系可以定义为：Cache行号 = 主存块号 % Cache总行数</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-21.1ee484vug6qo.webp" alt="计组-存储系统-21"></p>
<hr>
<p><strong>重点说明</strong>：在映射这一章中最任意糊涂的就是映射的地址结构，首先看直接映射的地址结构，它由三部分组成，分别是标记、Cacha行号和块内地址：</p>
<ul>
<li>主存块号
<ul>
<li>标记</li>
<li>Cacha行号</li>
</ul>
</li>
<li>主存的块内地址
<ul>
<li>块内地址</li>
</ul>
</li>
</ul>
<p>根据上面的层次结构我们可以看出，一个Cache行由两个大部分组成（主存块号、块内地址，时刻记住Cache中的内容是主存的一个<strong>副本</strong>），其中主存块号又被分为标记和Cache行号。</p>
<ol>
<li>这里的Cache行号是怎么来的？ 其实它来源于直接映射的定义，因为对主存块号进行取模操作即对<strong>主存块号$ % 2^c $相当于留下最后c位二进制数</strong>。换句话说，若Cache共有$ 2^c $行，那么主存块号的低c位即为对应的Cache行号</li>
<li>这里可能会迷惑为什么低c位就是对应的Cache行号，其实对于取模操作，用二进制来表示的话就是取低c就可以直接得到，思维不要局限在十进制上</li>
<li>CPU给出的访存地址是指访问主存的地址，CPU根据给出的访存地址的低c位（也就是<strong>Cacha行号</strong>）来在Cache中定位它，如果在Cache中该行有数据，然后再比较<strong>标记位</strong>且Cache行的有效位为<strong>1</strong>，则表示Cache中的这一行就是要找的访存地址（即Cache命中）</li>
</ol>
<p>例题：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-22.5sw0abrb0h80.webp" alt="计组-存储系统-22"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-23.3vfbfofqjgk0.webp" alt="计组-存储系统-23"></p>
<p>解析：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-24.1arnhqx10jz4.webp" alt="计组-存储系统-24"></p>
<p>如果以上内容还没有看懂可以<a href="https://www.bilibili.com/video/BV1cU4y1C7xY/">点击此处</a>查看视频讲解</p>
<p>上面内容搞清楚以后，本章的难点也就是没有了，考试的重点也多在上面</p>
<hr>
<h4 id="全相联映射"><a class="header-anchor" href="#全相联映射">¶</a>全相联映射</h4>
<p>与直接映射不同，全相联映射的每一块可以装入Cache中的任何位置，每行的标记用于指出该行取自主存的哪一块。优点是比较灵活，冲突概率低，空间利用率高；缺点是速度较慢</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-25.2foywfyp58ro.webp" alt="计组-存储系统-25"></p>
<h4 id="组相联映射"><a class="header-anchor" href="#组相联映射">¶</a>组相联映射</h4>
<p>组相联映射是将Cache分成Q个大小相等的组，<strong>组间采用直接映射、组内采用全相联映射</strong>，假设每组有r个Cache行，则称为r路组相联</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-26.30ymiqt5jxi0.webp" alt="计组-存储系统-26"></p>
<center style="color:#FF69B4;font-size:16px;text-decoration">如图为二路组相联</center>
<p>组相联映射可定义为：Cache组号 = 主存块号 % Cache组数（Q）</p>
<p>组相联映射地址结构为：</p>
<table>
<th>标记</th>  <th>组号</th>  <th>块内地址</th>
</table>
<p>若Cache共有$2^q$组，则主存块号的低q位即为对应的Cache组号<br>
例题：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-27.50n9o6mukus0.webp" alt="计组-存储系统-27"></p>
<p>解析：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-28.4o8jckddlzs0.webp" alt="计组-存储系统-28"></p>
<h3 id="Cache中主存块的替换算法"><a class="header-anchor" href="#Cache中主存块的替换算法">¶</a>Cache中主存块的替换算法</h3>
<p>在使用全相联映射或者组相联映射时，就需要考虑Cache和主存中数据的替换问题，直接映射则无需考虑。在计组中该部分内容简要带过，重点内容在操作系统中会学习到</p>
<p>常用的替换算法有：</p>
<ol>
<li>随机（RAND）算法</li>
<li>先进先出（FIFO）算法</li>
<li>近期最少使用（LRU）算法</li>
<li>最不常用（LFU）算法</li>
</ol>
<p>这里重点说一下LRU算法，其余内容在操作系统中学习<br>
LRU的一个快速手算方法是：可以从当前块从左向右找到最长时间未使用的内存块来替换，而无需像下面一样使用计数器</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-29.3uptcuv48ei0.webp" alt="计组-存储系统-29"></p>
<h3 id="Cache的写策略"><a class="header-anchor" href="#Cache的写策略">¶</a>Cache的写策略</h3>
<p>Cache中的内容是主存块的副本，当对Cache中内容进行更新时，需要使用写操作策略使Cache内容和主存内容保持一致。分为两种情况</p>
<ul>
<li>Cache写命中
<ul>
<li>全写法</li>
<li>写回法：为了减少写回主存的开销，每个Cache行需要设置一个修改位（<strong>脏位</strong>），若脏位为1则表示修改过，为0则未修改过（不要忘记脏位！考试常考到，还有也不要忘记有效位，Cache映射时会用到）</li>
</ul>
</li>
<li>Cache写不命中
<ul>
<li>写分配法</li>
<li>非写分配法</li>
</ul>
</li>
</ul>
<ol>
<li>
<p>Cache写命中</p>
<ol>
<li>
<p>全写法<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-30.16z2zkvrq7ts.webp" alt="计组-存储系统-30"><br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-32.bp5ao39bx28.webp" alt="计组-存储系统-32"></p>
</li>
<li>
<p>写回法<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-31.wge20sniudc.webp" alt="计组-存储系统-31"></p>
</li>
</ol>
</li>
<li>
<p>Cache写不命中</p>
<ol>
<li>
<p>写分配法<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-33.5uht10j6wrw0.webp" alt="计组-存储系统-33"></p>
</li>
<li>
<p>非写分配法<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-34.2is4ved3uhu0.webp" alt="计组-存储系统-34"></p>
</li>
</ol>
</li>
</ol>
<h2 id="虚拟内存"><a class="header-anchor" href="#虚拟内存">¶</a>虚拟内存</h2>
<p>这一章主要内容在操作系统中会重点学习，在这里就不再提及了</p>
<h2 id="典型例题-v3"><a class="header-anchor" href="#典型例题-v3">¶</a>典型例题</h2>
<p>待补充</p>
<hr>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计组</tag>
        <tag>存储系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理-指令系统</title>
    <url>/2023/05/27/65aa9fb0b19f/</url>
    <content><![CDATA[<h2 id="简介-v8"><a class="header-anchor" href="#简介-v8">¶</a>简介</h2>
<p>计算机组成原理系列其三，主要是针对中国大陆考研所要求的内容对计算机组成原理的知识体系进行总结和梳理，本篇内容是计算机的指令系统介绍，主要包含以下几点：</p>
<ul>
<li>指令格式的基本内容</li>
<li>指令格式</li>
<li>寻址方式</li>
<li>汇编基础</li>
<li>CISC和RISC的基本概念</li>
</ul>
<span id="more"></span>
<h2 id="大纲-v5"><a class="header-anchor" href="#大纲-v5">¶</a>大纲</h2>
<ul>
<li>指令系统
<ul>
<li>指令系统简述</li>
<li>指令的基本格式</li>
<li>定长与变长指令字结构
<ul>
<li>定长操作码指令格式</li>
<li>拓展操作码指令格式</li>
</ul>
</li>
<li>寻址方式（重点）
<ul>
<li>指令寻址</li>
<li>数据寻址</li>
</ul>
</li>
<li>汇编基础
<ul>
<li>基础知识</li>
<li>常用指令</li>
</ul>
</li>
<li>CISC和RISC</li>
<li>典型例题</li>
</ul>
</li>
</ul>
<h2 id="指令系统简述"><a class="header-anchor" href="#指令系统简述">¶</a>指令系统简述</h2>
<p>指令是指示计算机执行某些操作的命令。一台计算机的所有指令的集合构成该机器的指令集。指令集体系结构（ISA）规定了：指令格式、数据类型和格式、操作数的存放方式、存储空间的大小和编址方式、寻址方式etc.</p>
<h2 id="指令的基本格式"><a class="header-anchor" href="#指令的基本格式">¶</a>指令的基本格式</h2>
<blockquote>
<p>Tips：几种字长的区别<br>
机器字长：CPU一次能处理数据的位数，通常与CPU的寄存器位数有关。<br>
存储字长：存储器中一个存储单元(存储地址)所存储的二进制代码的位数，即存储器中的MDR的位数。<br>
指令字长：计算机指令字的位数。<br>
数据字长：计算机数据存储所占用的位数。<br>
其中：<br>
机器字长、存储字长：一般不变，固定长度<br>
指令字长：长度可能会改变</p>
</blockquote>
<p>一条指令就是机器语言的一个语句，是一段有意义的二进制代码。一条指令通常包括操作码和地址码两部分</p>
<table>
<th>操作码字段</th>  <th>地址码字段</th>  
</table>
<p>操作码是识别指令、了解指令功能以及区分操作数地址内容的组成和使用方法等信息。<br>
地址码给出被操作的信息（指令或数据）的地址。<br>
指令的长度是指一条指令中所包含二进制代码的位数，指令的长度与机器字长没有<strong>固定的关系</strong>，不过主存一般按照字节编址，所有指令字长多为字节的整数倍。</p>
<h2 id="定长与变长指令字结构"><a class="header-anchor" href="#定长与变长指令字结构">¶</a>定长与变长指令字结构</h2>
<p>在一个指令系统中，若所有指令的长度都相等，则称为定长指令字结构、若各种指令的长度随指令功能而异，则称为变长指令字结构<br>
根据操作数地址码的数目不同可以分为</p>
<ol>
<li>零地址指令：如停机指令、空操作指令、关中断指令etc.</li>
<li>一地址指令：如加1、减1、求反、求补etc.</li>
<li>二地址指令：如算术和逻辑运算指令，需要给出源操作数和目的操作数</li>
<li>三地址指令</li>
<li>四地址指令</li>
</ol>
<h3 id="定长操作码指令格式"><a class="header-anchor" href="#定长操作码指令格式">¶</a>定长操作码指令格式</h3>
<p>定长操作码指令在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般n位操作码字段的定长指令系统最大能表示$2^n$条指令</p>
<h3 id="拓展操作码指令格式"><a class="header-anchor" href="#拓展操作码指令格式">¶</a>拓展操作码指令格式</h3>
<p>即定长指令字结构+可变长操作码，拓展操作码使得操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码<br>
例如：<br>
在下图中，指令字长为16位，其中4位作为基本操作码字段OP，另有3个4位长的地址字段$A_1、A_2、A_3$。若4位基本操作码全用于三地址指令，则有16条。下图中所示的三地址指令为15条，1111留作拓展操作码用（即1111 0000-1110 XXXX XXXX 为二地址指令），二地址指令为15条；（同理 1111 1111 0000-1110 XXXX 为一地址指令），一地址指令为15条；（1111 1111 1111 0000-1110 为零地址指令）有16条。<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-1.1rp8r9467jhc.webp" alt="计组-指令系统-1"></p>
<p>除上方拓展方法外，还有其他多种拓展方法比如：<br>
[0000-1110 <strong>XXXX</strong> <strong>XXXX</strong> <strong>XXXX</strong>]：表示三地址指令，有15条<br>
[1111 0000-1011 <strong>XXXX</strong> <strong>XXXX</strong>]：表示二地址指令，这里取12条，留2条拓展<br>
[1111 <em><strong>1100-1110|1111</strong></em>  <em><strong>0000-1111|0000-1101</strong></em>  <strong>XXXX</strong>]：表示一地址指令，这里取62条，留2条拓展<br>
[1111 1111 1110-1111 0000-1111]：表示零地址，这里有32条</p>
<p><strong>设地址长度为n，上一层留出m种状态，下一层可拓展出$m\times2^n$种状态</strong></p>
<p>下面来看一道例题可能会更明显一些：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-2.4rf8xhbhuv40.webp" alt="计组-指令系统-2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-3.memtamrvqow.webp" alt="计组-指令系统-3"></p>
<h2 id="寻址方式（重点）"><a class="header-anchor" href="#寻址方式（重点）">¶</a>寻址方式（重点）</h2>
<p>寻址方式是指寻找指令或操作数的有效地址的方式，分为指令寻址和数据寻址两大类<br>
指令中的地址码字段并不代表操作数的真是地址，这种称为形式地址(A)。<br>
形式地址结合寻址方式，可以找到操作数在存储器中的真实地址，称为有效地址(EA)<br>
注意，(A)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。例如，EA=(A)意思是有效地址是地址A中的数值</p>
<h3 id="指令寻址"><a class="header-anchor" href="#指令寻址">¶</a>指令寻址</h3>
<p>寻找下一条将要执行的指令地址称为指令寻址<br>
指令寻址有两种：顺序寻址和跳跃寻址</p>
<ol>
<li>顺序寻址<br>
通过程序计数器PC+1（这里的“1”是指一个指令字长），自动形成下一条指令的地址。{PC + “1” -&gt; PC}</li>
<li>跳跃寻址<br>
通过转移类指令实现，下一条指令不是由PC<strong>自动</strong>给出，而是由本条指令给出下条指令地址的计算方式。跳跃的结果是当前指令<strong>修改</strong>PC指，所以下一条指令仍然通过PC给出。跳跃寻址分为绝对地址（由标记符直接得到）和相对地址（相对于当前指令地址的偏移量）</li>
</ol>
<h3 id="数据寻址"><a class="header-anchor" href="#数据寻址">¶</a>数据寻址</h3>
<p>寻找本条指令的数据地址称为数据寻址<br>
数据寻址可分为三大类具体十种寻址方式，下图包含前九种还有一个堆栈寻址<br>
其中基址寻址、变址寻址和相对寻址称为偏移寻址<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-4.4flvt3d8ga20.webp" alt="计组-指令系统-4"></p>
<p>数据寻址的方式较多，为了区别不同方式，会在指令字中设置一个字段，用来指明属于那种寻址方式。</p>
<table>
    <th>操作码字段</th>  <th>寻址方式位</th>    <th>形式地址A</th>  
</table>
<p>寻址方式位结合形式地址A求出操作数的真实地址，称为有效地址EA</p>
<h4 id="隐含寻址"><a class="header-anchor" href="#隐含寻址">¶</a>隐含寻址</h4>
<p>隐含寻址是不明显地给出操作数地址，而是在指令中隐含操作数地址。<br>
例如，单地址的指令只显式的给出第一操作数地址，而规定累加器（ACC）作为第二操作数地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-5.2gd6wd9owbgg.webp" alt="计组-指令系统-5"></p>
<h4 id="立即-数-寻址"><a class="header-anchor" href="#立即-数-寻址">¶</a>立即(数)寻址</h4>
<p>立即寻址形式地址段给出的不是操作数地址，而是操作数本身，有称为立即数，使用补码表示<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-6.7kivdh4vw2o0.webp" alt="计组-指令系统-6"></p>
<h4 id="直接寻址"><a class="header-anchor" href="#直接寻址">¶</a>直接寻址</h4>
<p>直接寻址中的形式地址A就是操作数的真实地址EA，即<strong>EA=A</strong>。<br>
这与立即寻址不同，注意区别<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-7.3i71pa3ukfw0.webp" alt="计组-指令系统-7"></p>
<h4 id="间接寻址"><a class="header-anchor" href="#间接寻址">¶</a>间接寻址</h4>
<p>间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作的真实地址，而是操作数有效地址EA所在的存储单元的地址，也就是是操作数地址的地址，即<strong>EA=(A)</strong>。<br>
间接寻址可以是一次，也可以是多次<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-8.6t3djb6azuc0.webp" alt="计组-指令系统-8"></p>
<h4 id="寄存器寻址"><a class="header-anchor" href="#寄存器寻址">¶</a>寄存器寻址</h4>
<p>寄存器寻址是指在指令字中直接给出操作数所在的寄存器编号，即$EA = R_i$，其操作数在由$R_i$所指的寄存器内<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-9.8td6fu9fpko.webp" alt="计组-指令系统-9"></p>
<h4 id="寄存器间接寻址"><a class="header-anchor" href="#寄存器间接寻址">¶</a>寄存器间接寻址</h4>
<p>相对的，寄存器间接寻址是指在寄存器$R_i$中给出的是操作数所在的主存单元的地址，即$EA = (R_i)$<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-10.kz8h7t82q5c.webp" alt="计组-指令系统-10"></p>
<h4 id="相对寻址"><a class="header-anchor" href="#相对寻址">¶</a>相对寻址</h4>
<p>相对寻址是把PC的内容加上形式地址A而形成的操作数的有效地址，即<strong>EA = (PC)+A</strong>，其中A是相对于当前PC指的偏移量，可正可负，由补码表示。</p>
<p>可以理解为是以PC所指的地址作为“起点”，A为偏移量。</p>
<p>相对寻址广泛应用于转移指令<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-11.ckuowkosz5c.webp" alt="计组-指令系统-11"></p>
<h4 id="基址寻址"><a class="header-anchor" href="#基址寻址">¶</a>基址寻址</h4>
<p>基址寻址是指将CPU中基址寄存器(BR)的内容加上形式地址A，即<strong>EA = (BR)+A</strong>。其中BR既可以用专用的寄存器，也可以采用通用寄存器。</p>
<p>基址寄存器是面向操作系统的，其内容只能由操作系统或者程序决定，程序员无法修改其内容，但可以选择使用哪一个BR。</p>
<p>有利于多道程序设计，并可以用于编写浮动程序。<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-12.kdo6rp88rf4.webp" alt="计组-指令系统-12"></p>
<h4 id="变址寻址"><a class="header-anchor" href="#变址寻址">¶</a>变址寻址</h4>
<p>变址寻址是指有效地址EA是形式地址A和变址寄存器IX内容之和，即<strong>EA = (IX)+A</strong></p>
<p>IX是面向程序员的，在程序执行中，IX中的内容可以由程序员改变（作为偏移量），而形式地址A不变（作为基地址）。</p>
<p>这有利于处理循环程序和数组问题。<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-13.5vujno1n2t00.webp" alt="计组-指令系统-13"></p>
<h4 id="堆栈寻址"><a class="header-anchor" href="#堆栈寻址">¶</a>堆栈寻址</h4>
<p>堆栈是存储器中一块特定的、按后进先出（LIFO）原则管理的存储区，该存储区中读/写单元的地址是由一个特定的寄存器给出，该寄存器称为堆栈指针（SP）<br>
堆栈分为硬堆栈和软堆栈。<br>
硬堆栈：又称寄存器堆栈<br>
软堆栈：从主存中划出一段区域作为堆栈<br>
在使用堆栈的系统中，大部分指令表面上都表现为无操作数指令形式，因为操作数地址隐含使用了SP。一般来说，在读/写一个堆栈的一个单元前后都会自动地完成对SP内容的增量或减量操作。</p>
<p>记栈顶元素为$M_(sp)$<br>
栈顶在小地址方向：<br>
出栈：$M_(sp) \rightarrow ACC$，$(SP)+1 \rightarrow SP$<br>
入栈：$(SP)-1 \rightarrow SP$，$(X) \rightarrow M_(sp)$</p>
<p>栈顶在小地址方向：<br>
出栈：$M_(sp) \rightarrow ACC$，$(SP)-1 \rightarrow SP$<br>
入栈：$(SP)+1 \rightarrow SP$，$(X) \rightarrow M_(sp)$</p>
<h2 id="汇编基础"><a class="header-anchor" href="#汇编基础">¶</a>汇编基础</h2>
<p>这里只简单说明一些考研可能会涉及到的汇编知识，只要求在考试中能结合高级语言代码看懂汇编即可，不会要求写出汇编代码</p>
<h3 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h3>
<ol>
<li>常用的有两种汇编格式：AT&amp;T和Intel格式，AT&amp;T是Unix和Linux使用的格式，Intel格式即x86格式。</li>
<li>注意，x86格式中第一个为目的操作数，第二个为源操作数，方式从右向左</li>
<li>x86中主要的寄存器<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-14.414ill6fsdk0.webp" alt="计组-指令系统-14"></li>
<li>两者差别：<strong><a href="https://zhuanlan.zhihu.com/p/527208939">点我查看</a></strong><br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-15.4tr50nd0wrc0.webp" alt="计组-指令系统-15"></li>
</ol>
<h3 id="常用指令"><a class="header-anchor" href="#常用指令">¶</a>常用指令</h3>
<p>偷懒了，具体指令意思可以参考网络上的内容**<a href="https://zhuanlan.zhihu.com/p/53394807">点我查看</a>**，下面只列出一些书中出现的命令。</p>
<ol>
<li>数据传送指令
<ol>
<li>mov(move)：将第二个操作数内容复制到第一个中</li>
<li>push</li>
<li>pop</li>
</ol>
</li>
<li>算术和逻辑运算指令
<ol>
<li>add/sub</li>
<li>inc/dec(increase/decrease)：操作数自增1、自减1</li>
<li>imul/mul(multiply)：带符号整数乘法</li>
<li>idiv/div(divide)：带符号整数除法</li>
<li>and/or/xor：与、或、异或</li>
<li>not</li>
<li>neg(negative)</li>
<li>shr/shl：shr逻辑右移、shl逻辑左移</li>
</ol>
</li>
<li>控制流指令
<ol>
<li>jmp</li>
<li>jcondition</li>
<li>cmp/test</li>
<li>call/ret</li>
</ol>
</li>
</ol>
<h2 id="CISC和RISC"><a class="header-anchor" href="#CISC和RISC">¶</a>CISC和RISC</h2>
<p>CISC的英文全称是complex instruction set computer,既复杂指令系统。RISC的英文全称是reduced instruction set computer,既精简指令系统。CISC兼容性性强，指令繁多，长度可变，由微程序实现。而RISC则指令少，使用频率接近，主要是依靠硬件实现（通用寄存器、硬布线逻辑控制）。</p>
<p>CISC与RISC的具体区别以表格的形式呈现，如下图：</p>
<table>
    <tbody>
        <tr>
            <td>指令系统类型</td>
            <td>指令</td>
            <td>寻址方式</td>
            <td>实现方式</td>
            <td>其他</td>
        </tr>
        <tr>
            <td>CISC（复杂指令系统）</td>
            <td>数量多，使用频率差别大，可变长格式</td>
            <td>支持多种寻址方式</td>
            <td>微程序控制技术</td>
            <td>研制周期长</td>
        </tr>
        <tr>
            <td>RISC（精简指令系统）</td>
            <td>数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存</td>
            <td>支持方式少</td>
            <td>增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线</td>
            <td>优化编译，有效支持高级语言</td>
        </tr>
    </tbody>
</table>
<h2 id="典型例题-v4"><a class="header-anchor" href="#典型例题-v4">¶</a>典型例题</h2>
<p>待补充</p>
<hr>
<p>参考文献：<br>
《王道考研-计算机组成原理复习指导》<br>
《Computer Systems A Programer’s Perspective Third Edition》<br>
<a href="https://zhuanlan.zhihu.com/p/343652303">CISC与RISC的区别</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计组</tag>
        <tag>指令系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理-总线及I/O</title>
    <url>/2023/07/02/820a4a133c49/</url>
    <content><![CDATA[<h2 id="简介-v9"><a class="header-anchor" href="#简介-v9">¶</a>简介</h2>
<p>计算机组成原理系列其五，主要是针对中国大陆考研所要求的内容对计算机组成原理的知识体系进行总结和梳理，本篇内容是计算机的总线及I/O介绍，主要包含以下几点：</p>
<ul>
<li>总线的基本概念</li>
<li>总线事物和定时</li>
<li>I/O接口</li>
<li>I/O方式</li>
</ul>
<h2 id="大纲-v6"><a class="header-anchor" href="#大纲-v6">¶</a>大纲</h2>
<ul>
<li>总线
<ul>
<li><strong>分类$\star$</strong>
<ul>
<li>片内总线</li>
<li>系统总线</li>
</ul>
</li>
<li><strong>总线结构$\star$</strong></li>
<li><strong>总线的性能指标$\star$</strong></li>
<li>例题</li>
</ul>
</li>
<li>总线事物与定时
<ul>
<li>总线事物</li>
<li>总线定时</li>
</ul>
</li>
<li>I/O接口
<ul>
<li><strong>基本结构$\star$</strong></li>
<li>I/O接口的类型</li>
<li><strong>I/O端口及其编址方式$\star$</strong></li>
</ul>
</li>
<li>I/O方式
<ul>
<li>程序查询方式
<ul>
<li>程序查询方式-例题</li>
</ul>
</li>
<li><strong>程序中断方式$\star$</strong>
<ul>
<li>程序中断工作流程</li>
<li>多重中断</li>
<li>中断屏蔽技术</li>
<li>程序中断方式-例题</li>
</ul>
</li>
<li>DMA方式
<ul>
<li>特点</li>
<li><strong>DMA的传送方式$\star$</strong></li>
<li><strong>DMA的传送过程$\star$</strong></li>
<li><strong>DMA和中断方式的区别$\star$</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="总线"><a class="header-anchor" href="#总线">¶</a>总线</h2>
<p>总线是一组能为多个部件分时共享的公共信息传输路线。（一个总线包含多根信号线）<br>
总线的特点：分时和共享</p>
<ul>
<li>分时：同一时刻只允许有一个部件向总线发送信息</li>
<li>共享：总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享，多个部件可同时从总线上接收相同的信息</li>
</ul>
<h3 id="分类-v2"><a class="header-anchor" href="#分类-v2">¶</a>分类</h3>
<ol>
<li>按数据格式
<ol>
<li>串行</li>
<li>并行</li>
</ol>
</li>
<li>按功能
<ol>
<li>片内总线</li>
<li>系统总线</li>
<li>通信总线</li>
<li>I/O总线</li>
</ol>
</li>
<li>按时序控制
<ol>
<li>异步</li>
<li>同步</li>
</ol>
</li>
</ol>
<h4 id="片内总线"><a class="header-anchor" href="#片内总线">¶</a>片内总线</h4>
<p>片内总线是芯片内部的总线，是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线</p>
<h4 id="系统总线"><a class="header-anchor" href="#系统总线">¶</a>系统总线</h4>
<p>系统总线是计算机系统内各功能部件（CPU、主存、I/O接口）之间互相连接的总线。按传输信息内容的不同可分为三类：数据总线、地址总线和控制总线</p>
<ol>
<li>数据总线（DB）：传输各功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关</li>
<li>地址总线（AB）：用来指出数据总线上的源数据或目的数据所在的主存单元会I/O端口的地址，它是单向传输总线，其位数与主存地址空间的大小及设备数量有关</li>
<li>控制总线（CB）：传输的控制信息，包括CPU送出的控制命令和主存（或外设）返回CPU的反馈信息</li>
</ol>
<h3 id="总线结构"><a class="header-anchor" href="#总线结构">¶</a>总线结构</h3>
<ol>
<li>单总线结构：使用一条单一的系统总线来连接CPU、内存和I/O设备</li>
<li>双总线结构：一条主存总线、主存和通道之间传送数据；一条I/O总线，用于多个外部设备与通道之间传送数据</li>
<li>三总线结构：内存总线、I/O总线和DMA总线</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-1.3pgym6rj7r60.webp" alt="计组-总线和IO-1"></p>
<h3 id="总线的性能指标"><a class="header-anchor" href="#总线的性能指标">¶</a>总线的性能指标</h3>
<ol>
<li>
<p>总线传输周期（总线周期）。指一次总线操作所需的时间，包括申请阶段（总线仲裁）、寻址阶段、传输阶段和结束阶段。总线传输周期通常由若干总线时钟周期构成。</p>
</li>
<li>
<p>总线时钟周期。即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。</p>
</li>
<li>
<p>总线工作频率。总线上各种操作的频率，为总线周期的倒数。实际上指1秒内传送几次数据。若总线周期=N个时钟周期，则总线的工作频率 =$\frac{时钟频率}{N}$。</p>
</li>
<li>
<p>总线时钟频率。即机器的时钟频率，它为时钟周期的倒数。</p>
</li>
<li>
<p>总线宽度。又称总线位宽，它是总线上能同时传输的数据位数，通常指数据总线的根数，如32根称为32位总线。</p>
</li>
<li>
<p>总线带宽。可理解为总线的最大数据传输率，即单位时间内总线上最多可传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。${总线带宽} = {总线工作频率}\times \frac{总线宽度}{8}$。<br>
<strong>注意：总线带宽和总线宽度应加以区别</strong>。</p>
</li>
<li>
<p>总线复用。总线复用是指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。</p>
</li>
<li>
<p>信号线数。地址总线、数据总线和控制总线3种总线数的总和称为信号线数。其中，总线的最主要性能指标为总线宽度、总线（工作）频率、总线带宽<br>
总线带宽是指总线本身所能达到的最高传输速度，它是衡量总线性能的重要指标。</p>
</li>
</ol>
<p>三者关系：$总线带宽={总线宽度}\times{总线频率}$。<br>
例如，总线工作频率为 22MHz，总线宽度为16位，则总线带宽 = $22\times{(\frac{16}{8})}= 44MB/s$。</p>
<h3 id="例题-v2"><a class="header-anchor" href="#例题-v2">¶</a>例题</h3>
<ol>
<li><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-2.z2f90ho7onk.webp" alt="计组-总线和IO-2"></li>
</ol>
<blockquote>
<p>解：总线工作频率为1333MHz，即1秒内可以传送1333M次数据。总线宽度为64位即单条总线工作一次可以传送8Byte。因此总带宽为$3\times8\times1333MB/s \approx 32GB/s$</p>
</blockquote>
<ol start="2">
<li><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-3.4jcabw5l9ic0.webp" alt="计组-总线和IO-3"></li>
</ol>
<blockquote>
<p>每个时钟周期传送2次，故$每秒传送次数 = 时钟频率 \times 2 = 2.4G \times 2/s$<br>
$总线带宽 = 每秒传送次数\times 2B \times 2 = 2.4G \times 2 \times 2B \times2/s = 19.2GB/s$<br>
公式中的“$\times 2B$”是因为每次传送16bit数据；“$\times 2$”是因为采用点对点的双全工总线</p>
</blockquote>
<h2 id="总线事物与定时"><a class="header-anchor" href="#总线事物与定时">¶</a>总线事物与定时</h2>
<h3 id="总线事物"><a class="header-anchor" href="#总线事物">¶</a>总线事物</h3>
<ul>
<li>
<p>总线裁决：决定哪个主控设备使用总线。</p>
</li>
<li>
<p>寻址阶段：主控设备送出要访问设备的地址，同时送出有关命令（读或写等），启动从设备。</p>
</li>
<li>
<p>数据传输阶段：主、从设备间进行数据交换。</p>
</li>
<li>
<p>结束阶段：有关信息在总线上撤销，让出总线使用权。</p>
</li>
</ul>
<h3 id="总线定时"><a class="header-anchor" href="#总线定时">¶</a>总线定时</h3>
<ol>
<li>
<p>同步定时方式<br>
所谓同步定时方式，是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期。在一个总线周期中，发送方和接收方可以进行一次数据传送。适用于总线长度较短及总线所接部件的存取时间比较接近的系统。</p>
<p>优点∶传送速度快；总线控制逻辑简单。<br>
缺点∶可靠性较差。</p>
</li>
<li>
<p>异步定时方式<br>
在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的握手信号 来实现定时控制。通常，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的&quot;请求&quot;信号，经接口传送到从设备;从设备接到主设备的请求后，通过接口向主设备发出&quot;回答&quot;信号。</p>
<p>优点∶总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间 可靠地进行信息交换，自动适应时间的配合。<br>
缺点∶比同步控制方式稍复杂一些，速度比同步定时方式慢。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-4.6rm72p50e9c.webp" alt="计组-总线和IO-4"></p>
<ol>
<li>不互锁方式：主设备发出&quot;请求&quot;信号后，不必等到接到从设备的&quot;回答&quot;信号，而是经过一段时间便撤销&quot;请求&quot;信号。</li>
<li>半互锁方式：主设备发出&quot;请求&quot;信号后，必须在接到从设备的&quot;回答&quot;信号后，才撤销&quot;请求&quot;信号，有互锁的关系。</li>
<li>全互锁方式：主设备发出&quot;请求&quot;信号后，必须在从设备&quot;回答&quot;后才撤销&quot;请求&quot;信号；从设备发出&quot;回答&quot;信号后，必须在获知主设备&quot;请求&quot;信号已撤销后，再撤销其&quot;回答&quot;信号。</li>
</ol>
<h2 id="I-O接口"><a class="header-anchor" href="#I-O接口">¶</a>I/O接口</h2>
<p>I/O接口是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换</p>
<h3 id="基本结构"><a class="header-anchor" href="#基本结构">¶</a>基本结构</h3>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-5.5ji9ybjwlns0.webp" alt="计组-总线和IO-5"></p>
<ul>
<li>主机侧（内部接口）：与系统总线相连，实质上是与主存、CPU相连</li>
<li>设备侧（外部接口）：通过接口电缆与外设相连，外部接口数据传输可能是串行方式。因此I/O接口要有串并行转换功能</li>
<li>数据线：读写数据、状态字（命令字）、控制字、中断类型号</li>
<li>状态/控制寄存器：状态和设备寄存器在使用时间上是错开的，因此可以将二者合而为一</li>
<li>地址线：指明I/O端口</li>
<li>控制线：读/写I/O端口信号、中断请求信号</li>
</ul>
<h3 id="I-O接口的类型"><a class="header-anchor" href="#I-O接口的类型">¶</a>I/O接口的类型</h3>
<ol>
<li>按数据传送方式可分为</li>
</ol>
<ul>
<li>并行接口：一个字节或一个字所有位同时传送。</li>
<li>串行接口：一位一位地传送。</li>
</ul>
<p>注：这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，数据总是并行传送的。接口要完成数据格式转换。</p>
<ol start="2">
<li>按主机访问I/O设备的控制方式可分为</li>
</ol>
<ul>
<li>程序查询接口</li>
<li>中断接口</li>
<li>DMA接口</li>
</ul>
<ol start="3">
<li>按功能选择的灵活性可分为</li>
</ol>
<ul>
<li>可编程接口</li>
<li>不可编程接口</li>
</ul>
<h3 id="I-O端口及其编址方式"><a class="header-anchor" href="#I-O端口及其编址方式">¶</a>I/O端口及其编址方式</h3>
<p>I/O端口是指接口电路中可以被CPU直接访问的寄存器</p>
<ol>
<li>
<p><strong>统一编址</strong><br>
把I/O端口当做存储器的单元进行地址分配，用统一的访存指令就可以访问I/O端口，又称存储器映射方式。靠不同的地址码区分内存和I/O设备，I/O地址要求相对固定在地址的某部分</p>
<blockquote>
<p>如系统总线中地址线共10根，则可以访问的存储单元<br>
个数为2!&quot;= 1024个，假设要给10个I/O端口编址：</p>
<ol>
<li>0～9表示I/O地址，10～1023为主存单元地址</li>
<li>0～1013表示主存单元地址，1014～1023为IO地址</li>
<li>10～19表示I/O地址，0～9、20～1023为主存单元地址</li>
</ol>
</blockquote>
<ul>
<li>优点：不需要专门的输入/输出指令，所有访存指令都可直接访问端口，程序设计灵活性高端口有较大的编址空间读写控制逻辑电路简单</li>
<li>缺点：端口占用了主存地址空间，使主存地址空间变小外设寻址时间长（地址位数多，地址译码速度慢）</li>
</ul>
</li>
<li>
<p><strong>独立编址</strong><br>
I/O端口地址与存储器地址无关，独立编址CPU需要设置专门的输入/输出指令访问端口，又称I/O映射方式。<br>
靠不同的指令区分内存和I/O设备</p>
<ul>
<li>优点：使用专用I/O指令，程序编制清晰I/O端口地址位数少，地址译码速度快I/O端口的地址不占用主存地址空间</li>
<li>缺点：I/O指令类型少，一般只能对端口进行传送操作，程序设计灵活性差需要CPU提供存储器读/写、I/O设备读/写两组控制信号，增加了控制逻辑电路的复杂性</li>
</ul>
</li>
</ol>
<h2 id="I-O方式"><a class="header-anchor" href="#I-O方式">¶</a>I/O方式</h2>
<p>输入、输出系统实现主机与I/O设备之间的数据传送，可以采用不同的控制方式，常用的I/O方式有</p>
<ul>
<li>程序查询</li>
<li>程序中断</li>
<li>DMA方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-6.uastx180l28.webp" alt="计组-总线和IO-6"></p>
<h3 id="程序查询方式"><a class="header-anchor" href="#程序查询方式">¶</a>程序查询方式</h3>
<p>信息交换完全由CPU执行程序实现</p>
<ul>
<li>
<p>独占查询：CPU 100%时间都在查询I/O状态，完全串行</p>
</li>
<li>
<p>定时查询：确保数据不丢失的情况下，每隔一段时间CPU查询一次I/O状态</p>
</li>
<li>
<p>主要特点：CPU有“踏步”等待现象，CPU与I/O串行工作</p>
</li>
<li>
<p>优点：接口设计简单、设备量少。</p>
</li>
<li>
<p>缺点：CPU在信息传送过程中要花费很多时间用于查询和等待，而且在一段时间内只能和一台外设交换信息，效率大大降低</p>
</li>
</ul>
<h4 id="程序查询方式-例题"><a class="header-anchor" href="#程序查询方式-例题">¶</a>程序查询方式-例题</h4>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-7.bqtk39xfv8o.webp" alt="计组-总线和IO-7"></p>
<h3 id="程序中断方式"><a class="header-anchor" href="#程序中断方式">¶</a>程序中断方式</h3>
<p>程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-8.6804bnkccns0.webp" alt="计组-总线和IO-8"></p>
<h4 id="程序中断工作流程"><a class="header-anchor" href="#程序中断工作流程">¶</a>程序中断工作流程</h4>
<p>工作流程：</p>
<ol>
<li>
<p>中断请求<br>
中断源向CPU发送中断请求信号。</p>
</li>
<li>
<p>中断响应判优<br>
响应中断的条件。<br>
中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。<br>
优先级设置：</p>
<blockquote>
<ol>
<li>硬件故障中断属于最高级，其次是软件中断；</li>
<li>非屏蔽中断优于可屏蔽中断；</li>
<li>DMA请求优于I/O设备传送的中断请求</li>
<li>高速设备优于低速设备；</li>
<li>输入设备优于输出设备；</li>
<li>实时设备优于普通设备</li>
</ol>
</blockquote>
</li>
<li>
<p>CPU响应中断条件</p>
<ol>
<li>中断源有中断请求</li>
<li>CPU允许中断及开中断（异常和不可屏蔽中断不受此限制）</li>
<li>一条指令执行完（异常不受此限制）</li>
</ol>
</li>
<li>
<p>中断响应过程<br>
CPU响应中断后，经过某些操作，转去执行<strong>中断服务程序</strong>。这些操作是由<strong>硬件</strong>之间实现的，称为<strong>中断隐指令</strong>。（中断隐指令不是指令系统的一条真正的指令，只是一种虚拟的说法，本质上是硬件的一系列自动操作）。<br>
中断隐指令的操作：</p>
<ol>
<li>关中断。[关中断的目的：实现原子操作（操作必须一次性完成不可以中断）]<br>
在中断服务程序中，为了保护中断现场（即CPU主要寄存器中的内容）期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。</li>
<li>保存断点。<br>
为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即程序计数器（PC）的内容）保存起来。可以存入堆栈，也可以存入指定单元。</li>
<li>引出中断服务程序。<br>
引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC），有两种方法实现中断源：<strong>硬件向量法</strong>和软件查询法<br>
<strong>硬件向量法</strong>：
<ul>
<li>每个中断都有一个唯一的类型号，每个中断类型号都对应一个中断服务程序，每个中断服务程序都有一个入口地址，即中断向量。</li>
<li>由硬件产生向量地址，再由向量地址找到入口地址。</li>
<li>向量地址由系统固定不可改变，但其对应的中断服务程序入口地址可以改变<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-9.74ns3abw9n40.webp" alt="计组-总线和IO-9"></li>
</ul>
</li>
</ol>
</li>
<li>
<p>中断处理过程<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-10.6m6y8yjj9w80.webp" alt="计组-总线和IO-10"></p>
</li>
</ol>
<h4 id="多重中断"><a class="header-anchor" href="#多重中断">¶</a>多重中断</h4>
<ul>
<li>单重中断：执行中断服务程序时不响应新的中断请求。</li>
<li>多重中断：又称中断嵌套，执行中断服务程序时可响应新的中断请求</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-11.4kt9dq1duqa0.webp" alt="计组-总线和IO-11"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-12.3n6n8rscwhs0.webp" alt="计组-总线和IO-12"></p>
<h4 id="中断屏蔽技术"><a class="header-anchor" href="#中断屏蔽技术">¶</a>中断屏蔽技术</h4>
<p>中断屏蔽技术主要用于多重中断，CPU要具备多重中断的功能，须满足下列条件。</p>
<ul>
<li>在中断服务程序中提前设置开中断指令。</li>
<li>优先级别高的中断源有权中断优先级别低的中断源。<br>
每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起，便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。</li>
</ul>
<p><strong>例题</strong>：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-13.6aka607de7o0.webp" alt="计组-总线和IO-13"></p>
<h4 id="程序中断方式-例题"><a class="header-anchor" href="#程序中断方式-例题">¶</a>程序中断方式-例题</h4>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-14.64iha4hn1f80.webp" alt="计组-总线和IO-14"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-15.3zdlj927o8s0.webp" alt="计组-总线和IO-15"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-16.57dl6utndgg0.webp" alt="计组-总线和IO-16"></p>
<h3 id="DMA方式"><a class="header-anchor" href="#DMA方式">¶</a>DMA方式</h3>
<p>DMA方式是一种完全由硬件进行成组信息传送的控制方式，具有程序中断方式的优点，即在数据准备阶段，CPU和外设<strong>并行工作</strong>。<br>
主存和DMA接口之间有一条直接数据通路。由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，I/O与主机并行工作，程序和传送并行工作。</p>
<h4 id="特点-v2"><a class="header-anchor" href="#特点-v2">¶</a>特点</h4>
<ol>
<li>它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。</li>
<li>在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</li>
<li>主存中要开辟专用缓冲区，及时供给和接收外设的数据。</li>
<li>DMA传送速度快，CPU和外设并行工作，提高了系统效率。</li>
<li>DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</li>
</ol>
<h4 id="DMA的传送方式"><a class="header-anchor" href="#DMA的传送方式">¶</a>DMA的传送方式</h4>
<p>使用的是三总线结构<br>
周期窃取的是存储周期<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-17.69kjft85p280.webp" alt="计组-总线和IO-17"></p>
<h4 id="DMA的传送过程"><a class="header-anchor" href="#DMA的传送过程">¶</a>DMA的传送过程</h4>
<p>DMA 的数据传送过程分为预处理、数据传送和后处理了个阶段：</p>
<ol>
<li>预处理。<br>
由CPU完成一些必要的准备工作。
<ul>
<li>首先，<strong>CPU执行几条I/O指令</strong>，用以测试I/O设备状态，<strong>初始化DMA控制器中的有关寄存器</strong>、设置传送方向、启动该设备等。</li>
<li>然后，CPU继续执行原来的程序，直到I/O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O设备向DMA控制器<strong>发送DMA请求</strong>，再由DMA控制器向CPU发送总线请求（有时将这两个过程统称为DMA请求）用以传输数据。</li>
</ul>
</li>
<li>数据传送。<br>
DMA 的数据传输可以以单字节（或字）为基本单位，也可以以数据块为基本单位。对于以数据块为单位的传送（如硬盘），DMA占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由DMA控制器（而非通过CPU执行程序）实现的，<strong>即数据传送阶段完全由DMA（硬件）控制。</strong></li>
<li>后处理。<br>
DMA控制器<strong>向CPU发送中断请求</strong>，CPU执行中断服务程序做DMA结束处理，包括校验送入主存的数据是否正确、测试传送过程中是否出错（错误则转诊断程序）及决定是否继续使用DMA传送其他数据等。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/blog_config/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO-18.5ya9zmwbrrs0.webp" alt="计组-总线和IO-18"></p>
<h4 id="DMA和中断方式的区别"><a class="header-anchor" href="#DMA和中断方式的区别">¶</a>DMA和中断方式的区别</h4>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">中断</th>
<th style="text-align:center">DMA</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据传送</td>
<td style="text-align:center">程序控制 程序的切换-&gt;保存和恢复现场</td>
<td style="text-align:center">硬件控制 CPU只需进行预处理和后处理</td>
</tr>
<tr>
<td style="text-align:center">中断请求</td>
<td style="text-align:center">传送数据</td>
<td style="text-align:center">后处理</td>
</tr>
<tr>
<td style="text-align:center">响应</td>
<td style="text-align:center">指令执行周期结束后响应中断</td>
<td style="text-align:center">每个机器周期结束均可，总线空闲时即可响应DMA请求</td>
</tr>
<tr>
<td style="text-align:center">场景</td>
<td style="text-align:center">CPU控制，低速设备</td>
<td style="text-align:center">DMA控制器控制，高速设备</td>
</tr>
<tr>
<td style="text-align:center">优先级</td>
<td style="text-align:center">优先级低于DMA</td>
<td style="text-align:center">优先级高于中断</td>
</tr>
<tr>
<td style="text-align:center">异常处理</td>
<td style="text-align:center">能处理异常事件</td>
<td style="text-align:center">仅传送数据</td>
</tr>
</tbody>
</table>
<h2 id="典型例题-v5"><a class="header-anchor" href="#典型例题-v5">¶</a>典型例题</h2>
<p>待补充</p>
<hr>
<p>参考文献：<br>
《王道考研-计算机组成原理复习指导》<br>
《Computer Systems A Programer’s Perspective Third Edition》</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计组</tag>
        <tag>总线</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理-数据的表示和计算</title>
    <url>/2023/04/16/644b687ff221/</url>
    <content><![CDATA[<h2 id="简介-v10"><a class="header-anchor" href="#简介-v10">¶</a>简介</h2>
<p>计算机组成原理系列其一，主要是针对中国大陆考研所要求的内容对计算机组成原理的知识体系进行总结和梳理，本篇内容主要包含以下几点：</p>
<ul>
<li>数制的表示</li>
<li>计算机的内部编码</li>
<li>定点数和浮点数</li>
<li>C语言中的数据表示</li>
<li>数据的计算</li>
</ul>
<span id="more"></span>
<h2 id="大纲-v7"><a class="header-anchor" href="#大纲-v7">¶</a>大纲</h2>
<p><strong>重点内容会使用黑色加粗表示</strong></p>
<ul>
<li>数据的表示和计算
<ul>
<li>前置知识
<ul>
<li>数值转换</li>
<li><strong>计算机运算速度</strong></li>
<li><strong>CPU执行时间</strong></li>
</ul>
</li>
<li>数制
<ul>
<li>进位计数法
<ul>
<li>r位进位计数法</li>
<li>不同进制数相互转换方法</li>
</ul>
</li>
<li>定点数的表示
<ul>
<li>真值和机器数</li>
<li>机器数的定点表示</li>
<li><strong>原码、补码、反码、移码</strong></li>
<li>定点数的移位
<ul>
<li><strong>算术位移</strong></li>
<li>逻辑位移</li>
<li>循环位移</li>
</ul>
</li>
<li>定点数的加减法</li>
<li>溢出的判别方法</li>
</ul>
</li>
</ul>
</li>
<li><strong>浮点数</strong>
<ul>
<li>一般浮点数的表示</li>
<li>IEEE 754标准</li>
</ul>
</li>
<li><strong>C语言中的数据类型及强制类型转换</strong>
<ul>
<li>整数类型的转换</li>
<li>包含浮点数的转换</li>
<li>数据的存储和排列
<ul>
<li>大端法</li>
<li>小端法</li>
</ul>
</li>
</ul>
</li>
<li>拓展
<ul>
<li>乘2取整法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="前情提要-v2"><a class="header-anchor" href="#前情提要-v2">¶</a>前情提要</h2>
<ol>
<li>数值转换
<ul>
<li>计算机进行数据处理时，一次存取、加工和传送的数据长度称为字，对于不同的品牌CPU 1Word(一个字)通常由一个或多个（一般是字节的整数位）字节构成</li>
<li><strong>在描述存储容量和文件大小时，K、M、G、T常用2次幂表示</strong>
<ul>
<li>1Byte = 8bit</li>
<li>1KB = $ 2^{10} $ B = $ 8\times2^{10} $ bit</li>
<li>1MB = $ 2^{20} $ B = $ 8\times2^{20} $ bit</li>
<li>1GB = $ 2^{30} $ B = $ 8\times2^{30} $ bit</li>
<li>1TB = $ 2^{40} $ B = $ 8\times2^{40} $ bit</li>
</ul>
</li>
<li><strong>在描述速率、频率时，K、M、G、T常用10次幂表示</strong>
<ul>
<li>1K = $ 10 ^{3} $</li>
<li>1M = $ 10 ^{6} $</li>
<li>1G = $ 10 ^{9} $</li>
<li>1T = $ 10 ^{12} $</li>
<li>1P = $ 10 ^{15} $</li>
</ul>
</li>
</ul>
</li>
<li>常见秒单位：</li>
</ol>
<table>
    <tr>
        <th colspan="3">分数</th>
        <td rowspan="14"></td>
        <th colspan="3">倍数</th>
    </tr>
    <tr>
        <th>值</th>
        <th>符号</th>
        <th>名称</th>
        <th>值</th>
        <th>符号</th>
        <th>名称</th>
    </tr>
    <tr>
        <td>10<sup>−1</sup> s</td>
        <td>ds</td>
        <td>分秒</td>
        <td>10<sup>1</sup> s</td>
        <td>das</td>
        <td>十秒</td>
    </tr>
    <tr>
        <td>10<sup>−2</sup> s</td>
        <td>cs</td>
        <td>厘秒</td>
        <td>10<sup>2</sup> s</td>
        <td>hs</td>
        <td>百秒</td>
    </tr>
    <tr>
        <td>10<sup>−3</sup> s</td>
        <td><b>ms</b></td>
        <td><b>毫秒</b></td>
        <td>10<sup>3</sup> s</td>
        <td>ks</td>
        <td>千秒</td>
    </tr>
    <tr>
        <td>10<sup>−6</sup> s</td>
        <td><b>µs</b></td>
        <td><b>微秒</b></td>
        <td>10<sup>6</sup> s</td>
        <td>Ms</td>
        <td>兆秒</td>
    </tr>
    <tr>
        <td>10<sup>−9</sup> s</td>
        <td><b>ns</b></td>
        <td><b>纳秒</b></td>
        <td>10<sup>9</sup> s</td>
        <td>Gs</td>
        <td>吉秒</td>
    </tr>
    <tr>
        <td colspan="20">常用单位以粗体表示</td>
    </tr>
</table>
<h2 id="计算机的性能指标"><a class="header-anchor" href="#计算机的性能指标">¶</a>计算机的性能指标</h2>
<h3 id="几种字长区别"><a class="header-anchor" href="#几种字长区别">¶</a>几种字长区别</h3>
<p>参见<a href="https://blog.hiyoung.xyz/2023/05/27/65aa9fb0b19f/?highlight=%E5%AD%97%E9%95%BF#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F">计算机组成原理 - 指令系统</a></p>
<h3 id="数据通路带宽"><a class="header-anchor" href="#数据通路带宽">¶</a>数据通路带宽</h3>
<p>数据通路带宽是指数据总线一次所能并行传送信息的位数。这里所指的数据通路宽度是指外部数据总线的宽度，它与CPU内部的数据总线宽度（内部寄存器的大小）可能不同</p>
<p><a href="https://blog.hiyoung.xyz/2023/06/24/524b2effcffb/?highlight=%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF#CPU%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF">CPU内部的数据通路</a><br>
<a href="https://blog.hiyoung.xyz/2023/07/02/820a4a133c49/?highlight=%E6%80%BB%E7%BA%BF%E5%B8%A6%E5%AE%BD#%E6%80%BB%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">外部数据总线带宽</a></p>
<h3 id="运算速度"><a class="header-anchor" href="#运算速度">¶</a>运算速度</h3>
<ol>
<li>计算机运算速度
<ol>
<li><strong>CPU时钟周期</strong>。 通常为主频的倒数，是CPU中最小的时间单位，执行指令的每个动作至少需要1个时钟周期</li>
<li><strong>主频</strong>（CPU时钟频率）。 机器内部的主时钟的频率，是衡量机器速度的重要参数，以Hz为单位。</li>
<li><strong>CPI</strong>（Cycle Per Instruction），执行一条指令所需的时钟周期数。（不同指令的时钟周期数可能不同，CPI通常是一个平均值）</li>
</ol>
</li>
<li><strong>CPU执行时间</strong>，指运行一个程序所花费的时间<br>
CPU执行时间 = $ \frac {CPU时钟周期}{主频} $ = $\frac {(指令条数\times CPI)}{主频}$</li>
<li><strong>MIPS</strong>（Million Instruction Per Second），每秒执行多少百万条指令<br>
MIPS = $ \frac {指令条数}{执行时间 \times 10^{6}} $ = $\frac {主频}{CPI \times 10^{6}}$</li>
</ol>
<h2 id="数制"><a class="header-anchor" href="#数制">¶</a>数制</h2>
<h3 id="进制计数法"><a class="header-anchor" href="#进制计数法">¶</a>进制计数法</h3>
<ol>
<li>
<p>一个r进制数($ K_n K_{n-1} K_{n-2} …… K_{0} K_{-1} …… K_{-m} $)可以表示为：<br>
$ K_n r^n + K_{n-1}r^{n-1} + …… K_{0}r^{0} $ $+ K_{-1}r^{-1} + …… K_{-m}r^{-m} = \sum_{i=n}^{-m} K_ir^i $  其中r是基数，$r^i$ 是第i位的位权（整数位最低位规定为第0位），$K_i$的取值可以是0，1，…… r-1共r个数码中的任意一个</p>
</li>
<li>
<p>不同进制数之间的互相转换</p>
<ol>
<li>二进制与八进制和十六进制可以很方便的互相转换</li>
<li>任意进制转换为十进制数:将任意进制数的各位数码与他们的权值相乘，再将乘积相加即可<br>
例如：$ (11011.1)_2 = 1\times 2^4 + 1\times 2^3 + 0\times 2^2 + 1\times 2^1 + 1\times 2^0 + 1\times 2^{-1} = 27.5 $</li>
<li>十进制转换为任意进制数:<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_1.2mqt5bo8h940.webp" alt="计算机组成原理-数据的表示和计算_1"></li>
</ol>
</li>
</ol>
<h3 id="定点数的编码表示"><a class="header-anchor" href="#定点数的编码表示">¶</a>定点数的编码表示</h3>
<h4 id="真值和机器数"><a class="header-anchor" href="#真值和机器数">¶</a>真值和机器数</h4>
<ul>
<li>真值：日常生活中使用正负号表示的数字，例如：-19、20。真值是计算器所代表的实际值</li>
<li>机器数：计算机中通常把数的符号和数值部分一起编码，通常用“0”表示正、“1”表负。这种把符号和数值一起编码的数称为机器数。常用的有原码、补码、反码、移码。例如：0,101（这里的“,”仅区分符号位和数值位）表示+5</li>
</ul>
<h4 id="机器数的定点表示"><a class="header-anchor" href="#机器数的定点表示">¶</a>机器数的定点表示</h4>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_2.22ukywznz7pc.webp" alt="计算机组成原理-数据的表示和计算_2"></p>
<h4 id="原码、补码、反码、移码"><a class="header-anchor" href="#原码、补码、反码、移码">¶</a>原码、补码、反码、移码</h4>
<p>对于这几种码的相互转换、适用范围、原码和补码的表示范围、补码原码的加减运算等要重点关注</p>
<ol>
<li>
<p>用机器数的最高位表示符号位(单符号位)，其余各位表示数的绝对值<br>
例如：$ x_1 = +0.1101， x_2 = -0.1101 $，字长为8位，其原码表示为$ [x_1]_原$ = <strong>0</strong>，1101000 ， $ [x_2]_原$ = <strong>1</strong>，1101000，其中最高位为符号位</p>
</li>
<li>
<p>原码中的真值零有正零和负零两种形式，$ [+0]_原$ = <strong>0</strong>，0000和 $ [-0]_原$ = <strong>1</strong>，0000，而补码的零是唯一的</p>
</li>
<li>
<p>双符号位表示: 00表示正，11表示负，其中第一位数字表示真正的符号，第二位数字可以用于溢出判断，即01、10表示发生溢出需要进行右移保持符号位不变</p>
</li>
<li>
<p>四种码的相互转换<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_3.5y7wwxczfg80.webp" alt="计算机组成原理-数据的表示和计算_3"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_6.4bcyvq5qy7i0.webp" alt="计算机组成原理-数据的表示和计算_6"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_4.70ci39aa6ds0.webp" alt="计算机组成原理-数据的表示和计算_4"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_5.4kng8opzhgg0.webp" alt="计算机组成原理-数据的表示和计算_5"></p>
</li>
</ol>
<h4 id="定点数的移位"><a class="header-anchor" href="#定点数的移位">¶</a>定点数的移位</h4>
<p>定点数的移位主要包括：算数移位、逻辑移位、循环移位</p>
<ol>
<li>
<p>算术移位：算术移位的操作对象是有符号数，其在移位过程中的符号位要保持不变(只移动数值位，其右添补0或1看符号位，左移添补0或1)，左移一位相当于乘以2;右移一位相当于除以2</p>
<ul>
<li>对于正数由于$ [ x]_原 $ = $ [ x]_补 $ = $ [ x]_反 $ = 真值，因此对于移位(左移和右移)后的空位均添0补充</li>
<li>对于负数：
<ul>
<li>原码表示：左移和右移均添0补充</li>
<li>补码表示：左移添0补充，右移添1补充（对于补码来说，其由低向高位找到的第一个“1”，在此“1”的左边各位均与对应的反码相同，在此“1”右边(包括此“1”)均与对应的原码相同）</li>
<li>反码表示：左移和右移均添1补充</li>
<li>误差分析：
<ul>
<li>对于正数、负数原码，左移时高位丢1，结果出错；右移时低位丢1，影响精度</li>
<li>对于负数补码，左移时高位丢0，结果出错；右移时，地位丢1，影响精度</li>
<li>负数反码，左移时高位丢0，结果出错；右移时低位丢0，影响精度<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_7.chlpqzilg74.webp" alt="计算机组成原理-数据的表示和计算_7"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>逻辑移位：逻辑移位将操作数视作无符号数，其左移或右移时均添0补充</p>
</li>
<li>
<p>循环移位：将移出的数位又移入数据中，循环移位适合将数据的低字节数据和高字节数据互换<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_8.3es5wrkoezk0.webp" alt="计算机组成原理-数据的表示和计算_8"></p>
</li>
</ol>
<h4 id="定点数的加减法，乘除（此处不做重点说明）"><a class="header-anchor" href="#定点数的加减法，乘除（此处不做重点说明）">¶</a>定点数的加减法，乘除（此处不做重点说明）</h4>
<ul>
<li>补码的加减运算规则：
<ul>
<li>按二进制运算规则运算</li>
<li>若做加法，直接两数补码相加；若做减法，则先将减数转化为对于的负数再与被减数相加</li>
<li><strong>符号位与数值位一起运算</strong>，加、减结果的符号位也在运算中直接得出</li>
<li>最终的运算结果的高位丢弃，保持位数不变，运算结果也为补码</li>
</ul>
</li>
<li>例子：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_9.165chj9dvdmk.webp" alt="计算机组成原理-数据的表示和计算_9"></li>
</ul>
<h4 id="溢出的判别方法"><a class="header-anchor" href="#溢出的判别方法">¶</a>溢出的判别方法</h4>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_10.4a8i0a8tf160.webp" alt="计组-数据的表示和计算_10"></p>
<h2 id="浮点数"><a class="header-anchor" href="#浮点数">¶</a>浮点数</h2>
<p>对于浮点数的学习可以类比十进制的科学计数法来比较学习</p>
<h3 id="一般浮点数的表示"><a class="header-anchor" href="#一般浮点数的表示">¶</a>一般浮点数的表示</h3>
<ol>
<li>
<p>表示格式：$ N=(-1)^S \times M \times R^E $</p>
<ul>
<li>S取值为0或1，用来决定浮点数的符号</li>
<li>M是一个二进制定点小数，称为尾数，一般使用定点原码小数表示，尾数的位数反映了浮点数的精度</li>
<li>E是一个二进制定点整数，称为阶码，常用移码表示。阶码的值反映了浮点数小数点的实际位置，阶码的位数反映了浮点数的表示范围</li>
<li>R是基数，一般是隐含的，可以取值为2、4、8等</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_11.2qg14rvxh4s0.webp" alt="计组-数据的表示和计算_11"></p>
</li>
<li>
<p>浮点数的规格化<br>
浮点数的尾数位数决定了浮点数的有效位数，有效位越多，数据的精度越高，浮点数的规格化就是为了使得尾数保留更多的有效位数。规格化的操作是通过调整一个非规格化的浮点数的尾数和阶码的大小，使得非零的浮点数在尾数的最高数位上保证是一个有效值（即值为1）</p>
<ol>
<li>
<p>规格化操作</p>
<ul>
<li>左规：当运算结果的尾数最高数位不是有效位时，即$ \pm0.0……01XXX  $的形式时需要进行左规，左规时，尾数每左移一位、阶码减1(以基数为2，下同)。左规可能需要多次</li>
<li>右规：当运算结果的尾数的有效位进位到小数点前时，需要右规。尾数右移一位、阶码加1。右规需要进行一次</li>
<li>为何只需要进行一次？ 当浮点数运算的结果使尾数溢出（即使用双符号位表示时为01或10）时，Example：
<blockquote>
<p>$ a = +2^2 \times 00.1100 $<br>
$ b = +2^2 \times 00.1000 $<br>
$ a+b = 2^2 \times(00.1100+00.1000) = 2^2 \times 01.0100$<br>
$ \mathtt{=&gt;^{右规} 2^3 \times 00.1010} $</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>用原码表示的规格化尾数（基数为2）的形式如下：</p>
<ol>
<li>正数为0.1xx……xx的形式，最大值表示为0.11……1，最小值为0.100……0</li>
<li>负数为1.1xx……xx的形式，最大值表示为1.10……0，最小值表示为1.11……1</li>
</ol>
</li>
</ol>
</li>
<li>
<p>浮点数的加减运算<br>
浮点数的运算特点是阶码运算和尾数运算分开进行，加减运算分为以下几步</p>
<ol>
<li>对阶<br>
对阶的目的是使两个操作数的小数点位置对⻬，即使得两个数的阶码相等。为此，先求阶差，然后以小阶向大阶看⻬的原则，将阶码小的尾数右移一位(基数为2)，阶加1，直到两个数的阶码相等为止。尾数右移时，舍弃掉有效位会产生误差，影响精度<br>
（类比科学计数法将$ 98.11 \times 10^2 + 8.11 \times 10^3 $转变为$ 9.811 \times 10^3 + 8.11 \times 10^3$）</li>
<li>尾数求和<br>
将对阶后的尾数按定点数加(减)运算规则运算。运算后的尾数不一定是规格化的，因此，浮点数的加减运算需要进一步进行规格化处理。</li>
<li>规格化<br>
参照上方规格化规则，对于IEEE 754规格化的尾数形式为$ \pm 1.xxxx $，因为IEEE 754尾数的最高位默认隐含为1所以规格化时的主要区别就是要将有效位移到小数点左边一位（即小数点左边只能为1）</li>
<li>舍入<br>
在对阶和尾数右规时，可能会对尾数进行右移，为保证运算精度，一般将低位移出的两位保留下来，参加中间过程的运算，最后将运算结果进行舍入，还原表示成IEEE 754格式。<br>
常见的舍入方法有:</li>
</ol>
<ul>
<li>舍1入法:类似于十进制的“四舍五入”法。运算结果保留位的最高数位为0，则舍去;最高数位为1，则在尾数的末位加1。这样可能会使尾数溢出，此时需再做一次右规。</li>
<li>恒置1法:不论丢掉的最高数位是0还是1，都把右移后的尾数末位恒置1</li>
<li>截断法:直接截取所需位数，丢弃后面的所有位，这种舍入处理最简单</li>
</ul>
<ol start="5">
<li>溢出判断<br>
在尾数规格化和尾数舍入时，可能会对阶码执行加/减运算。因此，必须考虑指数溢出的问题。<br>
若一个正指数超过了最大允许值(127或1023)，则发生指数上滥，产生异常<br>
若一个负指数超过了最小允许值(-126或-1022)，则发生指数下溢，通常把结果按机器零处理。
<ul>
<li>右规和尾数舍入。数值很大的尾数舍入时，可能因为末位加1而发生尾数溢出，此时需要通过右规来调整尾数和阶。右规时阶加1，导致阶增大，因此需要判断是否发生了指数上溢。当调整前的阶码为11111110时，加1后，会变成11111111而发生指数上滥。</li>
<li>左规。左规时阶减1，导致阶减小，因此需要判断是否发生了指数下溢。其判断规则与指数上溢类似，左规一次，阶码减1，然后判断阶码是否为全0来确定是否指数下滥。</li>
<li>由此可见，浮点数的溢出并不是以尾数溢出来判断的，尾数溢出可以通过右规操作得到纠正。运算结果是否溢出主要看结果的指数是否发生了上溢，因此是由指数上滥来判断的。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="IEEE-754标准"><a class="header-anchor" href="#IEEE-754标准">¶</a>IEEE 754标准</h3>
<p>现代计算机中，一般都以IEEE 754标准存储浮点数，IEEE标准用: $V=(-1)^S \times M \times 2^E $来表示一个浮点数</p>
<h4 id="简介-v11"><a class="header-anchor" href="#简介-v11">¶</a>简介</h4>
<ul>
<li>符号: S决定这个数是正数还是负数</li>
<li>尾数: M是一个二进制小数，采用隐藏位的原码（隐藏位是指隐藏尾数了小数点左边的<strong>1</strong>）</li>
<li>阶码: E是对浮点数进行加权，权重是2的E次幂，使用移码表示
<ul>
<li>移码 = 原码+偏移值（float型为127，double型为1023）</li>
<li>在手算阶码时可以将其视为无符号数计算，然后再减去（加上）偏移值即可得到原码（移码也即阶码），使用十进制计算再转为二进制较为方便</li>
</ul>
</li>
</ul>
<p>在IEEE 754标准中:</p>
<blockquote>
<p>规格化的短浮点数的真值为：$ (-1)^S \times 1.M \times 2^{E-127} $<br>
规格化的短浮点数的真值为：$ (-1)^S \times 1.M \times 2^{E-1023} $</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_12.79wxgrh12mc0.webp" alt="计组-数据的表示和计算_12"></p>
<table>
    <tr>    <th>符号位</th>   <th>阶码</th>       <th>尾数</th> </tr>
    <tr>
            <td>sign</td>   <td>exponent</td>   <td>fraction</td>
    </tr>
</table>
<p>对于不同精度的浮点数，阶码与数值位分配的位数不一样，如下：</p>
<table>
    <tr> <th>精度</th>   <th>数符</th>   <th>阶码</th>   <th>尾数</th> <th>总位数</th> <th>偏移值</th></tr>
    <tr>
        <th>短浮点数(C中的float)</th>  <td>1</td>   <td>8</td>   <td>23</td>   <td>32</td>   <td>$127_{(10)}$ || $7F_{(16)}$</td>
    </tr>
    <tr>
        <th>长浮点数(C中的double)</th>  <td>1</td>   <td>11</td>   <td>52</td>   <td>64</td>   <td>$1023_{(10)}$ || $3FF_{(16)}$</td>
    </tr>
</table>
<p>对于32位的单精度浮点数，符号位分配是1位，阶码分配了8位，尾数分配了是23位（实际上是24位，隐藏了隐含小数点左边的<strong>1</strong>）。</p>
<p>根据这个标准，我们来尝试把一个十进制的小数转换为IEEE 754标准表示。</p>
<h4 id="规格化的值-v2"><a class="header-anchor" href="#规格化的值-v2">¶</a>规格化的值</h4>
<p>最普遍的情况，当exp的位模式不全为0（数值0），也不全为1（单精度255，双精度2047）<br>
例如：178.125</p>
<ol>
<li>
<p>先把浮点数分别把整数部分和小数部分转换成2进制</p>
<ol>
<li>
<p>整数部分用除2取余的方法，求得：10110010</p>
</li>
<li>
<p>小数部分用<a href="#%E4%B9%982%E5%8F%96%E6%95%B4%E6%B3%95">乘2取整</a>的方法，求得：001</p>
</li>
<li>
<p>合起来即是：10110010.001</p>
</li>
<li>
<p>转换成二进制的浮点数，即把小数点移动到整数位只有1，即为：1.0110010001 * 2^111，111是二进制，由于左移了7位，所以是111</p>
</li>
</ol>
</li>
<li>
<p>把浮点数转换二进制后，这里基本已经可以得出对应3部分的值了</p>
<ol>
<li>
<p>数符：由于浮点数是正数，故为0.(负数为1)</p>
</li>
<li>
<p>阶码 : 阶码的计算公式：阶数 + 偏移量， 阶码是需要作移码运算，在转换出来的二进制数里，阶数是111(十进制为7)，对于单精度的浮点数，偏移值为01111111(127)[偏移量的计算是：$ 2^{(e-1)} - 1 $， e为阶码的位数，即为8，因此偏移值是127]，即：111+01111111 = 10000110</p>
</li>
<li>
<p>尾数：小数点后面的数，即0110010001</p>
</li>
<li>
<p>最终根据位置填到对位的位置上：</p>
</li>
</ol>
</li>
</ol>
<table>
    <tr>    <th>数符</th>   <th>阶码</th>       <th>尾数</th> </tr>
    <tr>
        <td>0</td>   <td>1 0 0 0 0 1 1 0</td>   <td>0 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0</td>
    </tr>
</table>
<blockquote>
<p>阶码与尾数之间隐含小数点</p>
</blockquote>
<p>可能有个疑问：小数点前面的1去哪里了？由于尾数部分是规格化表示的，最高位总是“1”<br>
我们将尾数定义为M=1+f，小数字段被描述为小数值f，其中0&lt;=f&lt;1，其二进制表示为：<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/IEEE%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA.5ehdoqm3j6s.gif" alt="IEEE浮点表示"><br>
也就是二进制小数点在最高有效位的左边。<br>
我们也可以把M看成一个二进制表达式为下图的数字，也总能调整阶码使得尾数M的范围在1到2之间。<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/IEEE%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA_2.2g2up3og3j9c.gif" alt="IEEE浮点表示_2"></p>
<p>既然第一位总是1，那就可以直接隐藏不需要显示出来，同时也能够获得一个额外的精度位。</p>
<h4 id="非规格化的值-v2"><a class="header-anchor" href="#非规格化的值-v2">¶</a>非规格化的值</h4>
<p>当阶码全为0时，所表示的数<em>非规格化</em>的形式。这种情况下，阶码的值是1-Bias，尾数M=f，也就是小数字段的值，不包含隐含开头的1。<br>
非规格化有两个用途：</p>
<ul>
<li>一、是提供一种表示数值0的方法，因为使用规格化的数我们必须使M&gt;=1，无法表示0。</li>
<li>二、是表示那些非常接近0的数。</li>
</ul>
<h4 id="定点、浮点表示的区别"><a class="header-anchor" href="#定点、浮点表示的区别">¶</a>定点、浮点表示的区别</h4>
<p>在字长相同时，浮点数取字长的一部分作为阶码，所以表示的范围比定点数要大，但是由于字长固定也就意味着尾数部分的有效位数减少，精度就要比定点数有所降低</p>
<p><img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_13.11unr8wkk374.webp" alt="计组-数据的表示和计算_13"></p>
<h2 id="C语言中的数据类型及强制类型转换"><a class="header-anchor" href="#C语言中的数据类型及强制类型转换">¶</a>C语言中的数据类型及强制类型转换</h2>
<p>在C语言中常会用到强制类型转换，C中对定点整数的存储是使用补码形式，常见的转换有char-&gt;int-&gt;long-&gt;double和float-&gt;double。从前到后的范围和精度都是从小到大，转换的过程中没有损失</p>
<h3 id="整数类型的转换"><a class="header-anchor" href="#整数类型的转换">¶</a>整数类型的转换</h3>
<ol>
<li>无符号&lt;----&gt;有符号：不改变数据内容，只改变对其的解释方式</li>
<li>长整数 ----&gt;短整数：高位截断，只保留低位</li>
<li>短整数 ----&gt;长整数：
<ul>
<li>无符号数，进行高位“0”拓展</li>
<li>有符号数，高位用原符号位拓展</li>
</ul>
</li>
</ol>
<h3 id="包含浮点数的转换"><a class="header-anchor" href="#包含浮点数的转换">¶</a>包含浮点数的转换</h3>
<ul>
<li>int转换为float时，虽然不会发生溢出，但float尾数连隐藏位共24位，当int型数的第24~31位非0时，无法精确转换成24位浮点数的尾数，需进行舍入处理，影响精度。</li>
<li>int或float转化为double时，因double的有效位数更多，因此能保留精确値。</li>
<li>double转换为float时，因float表示范围更小，因此大数转换时可能会发生滥出。此外，由于尾数有效位数变少，因此高精度数转换时会发生舍入。</li>
<li>float或double转换为int时，因int没有小数部分，因此数据会向0方向截断(仅保留整数部分)，发生舍入。另外，因int表示范围更小，因此大数转换时可能会溢出。</li>
</ul>
<table>
    <tr> <th>机器字长</th> <th>char</th>   <th>short</th>   <th>int</th> <th>long</th> <th>float</th> <th>double</th>
    </tr>
    <tr>
        <th>32位机</th>   <td>1B</td>   <td>2B</td>   <td>4B</td>   <td>4B</td>   <td>4B</td> <td>8B</td>
    </tr>
    <tr>
        <th>64位机</th>   <td>1B</td>   <td>2B</td>   <td>4B</td>   <td>8B</td>   <td>4B</td> <td>8B</td>
    </tr>
</table>
<h3 id="数据的存储和排列"><a class="header-anchor" href="#数据的存储和排列">¶</a>数据的存储和排列</h3>
<ol>
<li>
<p>大端法和小端法<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_14.5vz9svbzlxg0.webp" alt="计组-数据的表示和计算_14"></p>
</li>
<li>
<p>数据按照“边界对齐”的方式存储<br>
<img src="https://cdn.jsdelivr.net/gh/hiyoung3937/img_hiyoung@master/bolg/%E8%AE%A1%E7%BB%84-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97_15.2iiz7phyxl20.webp" alt="计组-数据的表示和计算_15"></p>
</li>
</ol>
<h2 id="典型例题-v6"><a class="header-anchor" href="#典型例题-v6">¶</a>典型例题</h2>
<ul>
<li>P11-22</li>
<li>P17-20-23</li>
<li>P32-28-30</li>
<li>P51-(33,37)-(38,44)-41</li>
</ul>
<hr>
<h2 id="拓展-v2"><a class="header-anchor" href="#拓展-v2">¶</a>拓展</h2>
<h3 id="乘2取整法-v2"><a class="header-anchor" href="#乘2取整法-v2">¶</a>乘2取整法</h3>
<p>考虑一个十进制小数0.123，我们可以用“乘10取整”法得到它的每一位小数：第一位小数是0.123 *10=1.23，取整数1；第二位小数：0.23 *10=2.3，取整数2</p>
<p>上面的方法供你直观理解，下面我们从数学的角度分析其中的原理。</p>
<p>现在有一个十进制小数为0.625，要把它转换为二进制小数，我们需要找到它的每一位。记这个二进制小数点后第1位是$a_1$，第二位是$a_2$，……，那么这个小数的值就是$ a_1 \ast {\frac{1}{2}}^{-1}+a_2 \ast {\frac{1}{2}}^{-2}+a_3 \ast {\frac{1}{2}}^{-3}+… $ 。现在我们的目标是根据0.625找到对应的$ a_1，a_2，a_3$ ，…使得$ 0.625=a_1 \ast {\frac{1}{2}}^{-1}+a_2 \ast {\frac{1}{2}}^{-2}+a_3 \ast {\frac{1}{2}}^{-3}+… $</p>
<p>在等式两边同时乘以2，得到$1.25=a_1 \ast {\frac{1}{2}}^{0}+a_2 \ast {\frac{1}{2}}^{-1}+a_3 \ast {\frac{1}{2}}^{-2}+…$</p>
<p>我们发现，左边的整数部分1对应右边的$a_1$，也就是二进制小数的第一位，于是$a_1=1$，对于剩下的部分：</p>
<p>$0.25=a_2 \ast {\frac{1}{2}}^{-1}+a_3 \ast {\frac{1}{2}}^{-2}+…$</p>
<p>我们再次乘以2，得到$0.5=a_2 \ast {\frac{1}{2}}^{0}+a_3 \ast {\frac{1}{2}}^{-1}+… $于是$a_2=0$</p>
<p>再乘以2，得到$1=a_3 \ast {\frac{1}{2}}^{0}+…$， 于是$a_3=1$，到这里，所有的数都消耗完了，我们找到了0.625对应的二进制小数：0.101</p>
<hr>
<p>参考文献：<br>
《王道考研-计算机组成原理复习指导》<br>
《Computer Systems A Programer’s Perspective Third Edition》</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
        <tag>计算机数据表示</tag>
        <tag>浮点数</tag>
        <tag>补码</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2024/12/15/ecd032f05b10/</url>
    <content><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
</search>
